<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
 <title>데이터베이스 성능 모니터링</title>

 <indexterm zone="monitoring">
  <primary>모니터링</primary>
  <secondary>데이터베이스 서버</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
 </indexterm>

 <para>
  데이터베이스 관리자가 하는 일 가운데 하나는 
  <quote>이 데이터베이스 서버가 정상적으로 운영 되고 있는지</quote>
  를 지켜 보는 일이다.
  여기서는 이 일에 대한 부분을 다룬다.
 </para>

  <para>
   데이터베이스 운영 상태를 지켜 보거나, 성능을 분석하는 도구들은 
   여러가지가 있다. 
   이 장에서 다루는 대부분의 내용은 <productname>PostgreSQL</productname>
   통계수집기에 대한 것이지만, 
   <command>ps</command>, <command>top</command>, <command>iostat</command>, <command>vmstat</command>
   같은 유닉스에서 일반적으로 사용하는 모니터링 프로그램에 대한 
   설명도 함께 한다. 또한 <xref linkend="sql-explain"/>
   명령어로 살펴보아야 하는 최적화 되지 못한 쿼리들에 대한 해결 방법도 
   잠깐 다룬다. 물론 <command>EXPLAIN</command> 명령어에 대한 
   자세한 설명은 <xref linkend="using-explain"/>에서 다룬다.
  </para>

 <sect1 id="monitoring-ps">
  <title>표준 유닉스 도구들</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>프로세스 살펴 보기</secondary>
  </indexterm>

  <para>
   대부분의 유닉스 환경에서는 <productname>PostgreSQL</productname>
   서버의 동작 상태를 <command>ps</command> 쉘 명령어만으로도 대략적으로
   살펴 볼 수 있다. 왜냐하면 서버는 자신 하고 있는 각각의 
   하위 프로세스들의 명령어 이름들을 동적으로 바꾸어서 운영체제가 
   그것을 볼 수 있도록 하기 때문이다. 그래서 다음과 같은 간단한 
   명령어로 서버 상태를 살펴 볼 수 있다:

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (이 명령은 여러 유닉스 제각각이다. 윗 예제는 요즘 사용하는 리눅스 
   시스템에서 사용하는 명령어다. <command>ps</command> 명령의 옵션에 대한
   자세한 설명은 사용하고 있는 유닉스 운영체제 설명서를 
   설펴보는 것이 좋다.)
   윗 예제 출력 결과의 첫번째 줄은 데이터베이스 서버의 
   최상위 프로세스이며, 서버를 실행 할 때 사용했던 옵션들도 
   함께 보인다. (PostgreSQL 서버는 쓰레드 방식이 아니라, 
   다중 프로세스 방식으로 운영된다.  다중 프로세스 방식이란, 
   서버 관리자가 서버 실행 명령어를 OS 쉘에서 실행하면, 
   서버 최상위 프로세스 실행되고, 그 프로세스를 필요한 
   여러 프로세스를 실행하는 방식이다.  - 옮긴이)
   다음 다섯 줄은 이 최상위 프로세스가 실행한 서버 운영에 필요한 
   하위 프로세스들이다.  이것을 서버 백그라운드 프로세스라고 한다.
   이 프로세스들은 윗 예제와 꼭 같지는 않다. 
   <quote>autovacuum launcher</quote> 프로세스는 autovacuum 기능을 
   사용하지 않으면 보이지 않을 것이며, 
   서버 로그를 stderr 쪽으로 보내지 않고 따로 보관하는 
   기능을 사용한다면,  <quote>postgres: logger process</quote>
   같은 프로세스도 보일 것이다.
   나머지는 클라이언트가 접속해서 서버측에서 만든 
   세션 프로세스들이다.  이 세션 프로세스들은 
   다음과 같은 양식으로 보여준다:

<screen>
postgres: <replaceable>사용자</replaceable> <replaceable>데이터베이스</replaceable> <replaceable>호스트</replaceable> <replaceable>현재작업상태</replaceable>
</screen>

  사용자, 데이터베이스, (클라이언트) 호스트 정보는 
  그 프로세스가 종료 될 때까지 항상 같지만, 
  현재작업상태 정보는 그 세션의 작업 상태에 따라 
  바뀐다. 
  현재작업상태에 <literal>idle</literal>은 
  이 세션이 클라이언트의 명령을 대기하고 있음을 뜻한다.
  <literal>idle in transaction</literal>으로 표시되는 것은 
  그 세션이 현재, <command>BEGIN</command> 명령을 사용해서, 
  트랜잭션 영역 안에 있지만, 클라이언트 측에서 
  아무 작업도 안하고 있는 상태이다.
  <literal>SELECT</literal>과 같이 명령어 종류를 보여 주는 경우도 있고, 
  그 뒤에, <literal>waiting</literal>이 붙어 있는 경우도 있다. 
  이 경우는 다른 프로세스가 어떤 작업을 하고 있어, 
  이 세션이 해당 작업을 대기하고 있는 상태를 나타낸다.
  윗 예제를 보면, 15610 프로세스 때문에, 
  15606 프로세스가 작업을 대기하고 있음을 알 수 있다. 
  (윗 예제 화면에서는 다른 세션들이 없기 때문에, 
  15610 프로세스가 잠금 문제를 일으킨 프로세스로 
  파악 할 수 있다.  어떤 잠금을 사용하고 있기에, 
  다른 프로세스가 기다리고 있는지에 대한 자세한 정보는
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  뷰를 통해서 알 수 있다.)
  </para>

  <para>
   <xref linkend="guc-cluster-name"/> 환경 설정값으로 
   클러스터 이름을 지정하면 <command>ps</command> 명령 결과로 다음과 같이 보인다:
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>

  <para>
   <xref linkend="guc-update-process-title"/> 환경 설정값을 
   off로 지정했다면, 프로세스 현재작업상태 자리에는
   그 프로세스의 첫 작업에 대한 이름으로 지정되면, 
   그 프로세스가 종료될 때까지 그대로 유지된다.
   몇몇 OS에서는 이 프로세스 이름을 바꾸는 작업이 부하를 유발한다고
   사용하지 않는 경우도 있고, 또 몇몇 OS에서는 
   이 작업에 대해서 전혀 신경 쓰지 않는 경우도 있다.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname>에서는 
  이 부분 처리가 독특하다. 
  먼저 <command>/bin/ps</command> 명령 대신에, 
  <command>/usr/ucb/ps</command> 사용하고, 
  <option>w</option> 옵션을 두 개 지정하고, 
  서버 시작 최상위 프로세스의 이름이 
  각 세션 프로세스의 이름보다 짧게 지정한다면, 
  세션 프로세스들의 이름이 동적으로 바뀌는 것을 살펴볼 수 있다.
  하지만, 이 세가지 조건 중 하나라도 만족하지 않는다면, 
  모든 프로세스 이름은 서버 최상위 프로세스의 이름과 같게 보인다.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>통계 수집기</title>

  <indexterm zone="monitoring-stats">
   <primary>통계</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> <firstterm>통계 수집기
   statistics collector</firstterm>는 서버 운영 상태에 대한 정보를 수집하거나
   보고하기 위한 작업을 하는 백그라운드 시스템이다.  현재, 이 수집기는
   테이블이나 인덱스의 디스크 블록 단위 또는 개별 로우 단위의 접근
   회수를 수집할 수 있다.  또한 각 테이블에 저장 되어있는 총 로우 수를
   수집하며, 각 테이블에 대한 vacuum 작업과, analyze 작업에 관한 정보들도
   수집한다. 또한 사용자 정의 함수들의 호출 회수와, 그것들의 각각
   총 수행 시간들도 수집한다.
  </para>

  <para>
   또한 <productname>PostgreSQL</productname>에서는 현재 시스템에서 어떻게 
   운영 되고 있는지에 대한 동적 정보를 제공한다. 예를 들어 다른 서버 프로세스가
   현재 어떤 작업을 하고 있는지, 어떤 클라이언트들이 접속해 있는지를 
   알 수 있다. 이 기능은 수집기 프로세스와 별개로 제공하고 있는 기능이다.
  </para>


 <sect2 id="monitoring-stats-setup">
  <title>통계 수집기 환경설정</title>

  <para>
   통계 자료를 수집한다는 것은 궁극적으로는 그 만큼의 추가 비용을 서버가
   사용한다는 것을 의미한다. 그래서, 그 추가 비용을 얼마만큼 쓸 것인지에
   대한 결정을 서버 환경변수로 제어할 수 있다. 다음은 
   <filename>postgresql.conf</filename> 환경설정 파일에서 사용할 수 있는
   환경변수들이다. (이들에 대한 보다 자세한 부분은
   <xref linkend="runtime-config"/>을 참고하라.)
  </para>

  <para>
   <xref linkend="guc-track-activities"/> 설정값을 활성화하면 각각의
   서버 프로세스들은 현재 자신이 하고 있는 작업을 프로세스 이름으로 보여준다.
  </para>

  <para>
   <xref linkend="guc-track-counts"/> 설정값을 활성화하면 테이블과 인덱스의
   사용빈도를 통계 수집기가 수집한다.
  </para>

  <para>
   <xref linkend="guc-track-functions"/> 설정값을 활성화하면 사용자 정의
   함수들의 사용빈도를 통계 수집기가 수집한다.
  </para>

  <para>
   <xref linkend="guc-track-io-timing"/> 설정값을 활성화면 블록 읽기
   쓰기 회수를 통계 수집기가 수집한다.
  </para>

  <para>
   일반적으로 이 환경설정 변수들은 <filename>postgresql.conf</filename>에서
   그 값을 지정하면, 이것은 모든 서버의 프로세스들을 대상으로 작동하게 된다.
   하지만,  <xref linkend="sql-set"/> 명령을 이용해서, 개별 세션 단위로
   이 설정값을 변경할 수도 있다. (이 작업은 일반 사용자가 악의적으로
   사용될 가능성이 있기 때문에, 슈퍼유저만 사용할 수 있다.)
  </para>

  <para>
   통계 수집기가 만든 정보는 <xref linkend="guc-stats-temp-directory"/> 설정값으로
   지정한 디렉터리 (초기값은 <filename>pg_stat_tmp</filename>) 안에 있는
   임시파일로 저장되고, 그것을 여러 다른 PostgreSQL 프로세스들이 이용한다.
   보다 나은 성능을 위해서는 이 파일의 I/O 성능을 높이기 위해 이 디렉터리를
   메모리 기반 파일시스템에 두는 것도 좋은 방법이다. 이 통계 정보는 서버가
   중지 될 때 <filename>pg_stat</filename> 디렉터리 쪽으로 복사하는
   작업을 하기 때문에, 서버 중지, 재시작에도 자료를 그대로 유지할 수 있다.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>통계 정보 보기</title>

  <para>
    위에서 설명한 시스템의 현재 상태는 <xref
    linkend="monitoring-stats-dynamic-views-table"/> 뷰들을 통해서
    살펴볼 수 있고, 그 외 수집된 통계 정보는 아래 <xref
   linkend="monitoring-stats-views-table"/>에서 나열한 여러 뷰를
   통해서 살펴 볼 수 있다. 다른 방법으로는 <xref linkend="monitoring-stats-functions"/>에서 제공하는
   여러 통계 정보 보기 함수들을 이용해서 필요한 뷰를 직접 만들어서
   살펴 볼 수도 있을 것이다.
  </para>

  <para>
   여기서 중요한 점은 살펴 보고 있는 수집된 통계 정보는 현재 데이터베이스의
   정확한 현재 상태가 아니라는 점이다. 각 개별 프로세스들이 수집한 통계
   정보는 그 프로세스가 아무런 작업을 하고 있지 않을 때, 수집기에게 전달한다.
   즉 한 쿼리가 실행 되고 있다거나 트랜잭션 내에 있다면, 그 과정에
   생긴 통계 정보들은 반영되지 않고 있다는 것이다. 또한 통계 수집기의
   작업은 <varname>PGSTAT_STAT_INTERVAL</varname> (기본값은 500ms 이다)
   시간 간격으로 진행된다. 즉 이 만큼의 통계 정보 오차가 발생한다.
   하지만, <varname>track_activities</varname> 관련 정보는 항상 즉시 반영 된다.
  </para>

  <para>
   또 다른 중요한 점은 한 통계 정보는 해당 뷰나, 함수로 출력할 때,
   한 트랜잭션 내에서는 항상 같은 값을 출력한다. 즉, 트랜젹션이 끝날 때까지
   그 값을 유지한다. 이와 비슷하게 모든 세션들의 현재 쿼리에 대한 정보도
   하나의 트랜잭션 내에서는 같은 정보를 출력한다. 이것은 버그가 아니라
   특성이다. 이것은 한 트랜잭션 내에서 그 통계 정보가 일정하게 유지
   되도록해서 여러 다른 쿼리들에서 그 값을 일관성 있게 한다.  하지만 이것을
   원치 않는다면 각 쿼리들을 트랜잭션 단위로 분리해서 작업하면 된다.  다른
   방법으로 <function>pg_stat_clear_snapshot</function>() 함수를 사용해서,
   현재 스냅숏으로 지정된 통계 정보를 버리고 새 통계 정보를 사용할 수도 있다.
  </para>

  <para>
   하나의 트랜잭션 내에서 그 자신의 통계 정보 (아직까지 수집기 쪽으로 보내지
   않은 현재 작업 내역에 대한 정보)들은 다음과 같은 뷰에서 제공한다:
   <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname>, 
   <structname>pg_stat_xact_user_functions</structname>.
   이들의 통계 정보는 현재 트랜잭션 내에서도 자신의 세션 작업에 대한 통계치를
   반영 해서 다른 세션에서 수집된 정보와 자신의 세션에서 수집된 정보와 차이가 생길 수도 있다.
  </para>

  <para>
   Some of the information in the dynamic statistics views shown in <xref
   linkend="monitoring-stats-dynamic-views-table"/> is security restricted.
   Ordinary users can only see all the information about their own sessions
   (sessions belonging to a role that they are a member of).  In rows about
   other sessions, many columns will be null.  Note, however, that the
   existence of a session and its general properties such as its sessions user
   and database are visible to all users.  Superusers and members of the
   built-in role <literal>pg_read_all_stats</literal> (see also <xref
   linkend="default-roles"/>) can see all the information about all sessions.
  </para>

  <table id="monitoring-stats-dynamic-views-table">
   <title>동적 통계 정보 뷰들</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>뷰 이름</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       세션 프로세스들의 정보를 각각 하나의 로우로 보여준다.
       이 프로세스들은 현재 서버를 사용하고는 있는 - 클라이언트가
       서버로 접속 해서 만들어진 하위 서버 프로세스들이며, 이들의
       현재 상태, 실행 중인 쿼리들을 살펴 볼 수 있다.
       자세한 내용은 <xref linkend="pg-stat-activity-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>
       하나의 WAL 송신 프로세스에 대해서 하나의 로우로,
       대기 서버 쪽으로 보내는 리플리케이션 작업에 대한 통계 정보를
       보여준다. 자세한 내용은 <xref linkend="pg-stat-replication-view"/> 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>Only one row, showing statistics about the WAL receiver from
       that receiver's connected server.
       See <xref linkend="pg-stat-wal-receiver-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>At least one row per subscription, showing information about
       the subscription workers.
       See <xref linkend="pg-stat-subscription"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       SSL used on this connection.
       See <xref linkend="pg-stat-ssl-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       GSSAPI authentication and encryption used on this connection.
       See <xref linkend="pg-stat-gssapi-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
      <entry>One row for each backend running <command>CREATE INDEX</command> or <command>REINDEX</command>, showing
      current progress.
      See <xref linkend='create-index-progress-reporting'/>.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>VACUUM</command>, showing current progress.
       See <xref linkend='vacuum-progress-reporting'/>.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
      <entry>One row for each backend running
       <command>CLUSTER</command> or <command>VACUUM FULL</command>, showing current progress.
       See <xref linkend='cluster-progress-reporting'/>.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
   <title>수집된 통계 정보 뷰들</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>뷰 이름</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>WAL 아카이버 프로세스 작동에 대한 
       통계 정보를 하나의 로우로 보여준다.
       자세한 사항은
       <xref linkend="pg-stat-archiver-view"/> 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>
       백그라운드 라이터 프로세스의 작업 통계 정보.
       자세한 내용은 <xref linkend="pg-stat-bgwriter-view"/> 참조. 
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>한 로우에 하나씩 각 데이터베이스 전역 통계 정보를 보여
       준다. 자세한 내용은 <xref linkend="pg-stat-database-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       하나의 데이터베이스에서 그 전역에 걸쳐 발생한 대기 서버
       복제 작업 충돌에 의한 쿼리 실행 실패 통계 정보를 각각 하나의
       로우로 보여준다. 자세한 내용은 <xref linkend="pg-stat-database-conflicts-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블 사용에 대한 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-stat-all-tables-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</structname> 내용과 같은데, 시스템 테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</structname> 내용과 같은데, 시스템 테이블을 제외한
      현재 사용자 접근 할 수 있는 테이블에 대한 정보만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</structname> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다.
      (즉 <structname>pg_stat_all_tables</structname> 쪽으로 반영 되지
      <emphasis>않은</emphasis> 트랜잭션 내의 정보다).
      이 뷰에는 사용하는 실 로우 수, 사용하지 않는 로우(dead row) 수,
      vacuum과 analyze 작업에 관계된 정보는 제공하지 않는다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_xact_all_tables</structname> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_xact_all_tables</structname> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는 테이블에 대해서만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스 사용에 대한 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-stat-all-indexes-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry><structname>pg_stat_all_indexes</structname> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry><structname>pg_stat_all_indexes</structname> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-statio-all-tables-view"/> 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_statio_all_tables</structname> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry><structname>pg_statio_all_tables</structname> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는
      테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-statio-all-indexes-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry><structname>pg_statio_all_indexes</structname> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry><structname>pg_statio_all_indexes</structname> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       현재 접속한 데이터베이스에 속한 모든 시퀀스에 대해서
       한 로우씩 그 시퀀스에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-statio-all-sequences-view"/> 참조.
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry><structname>pg_statio_all_sequences</structname> 내용과 같은데,
      시스템 시퀀스에 대해서만 보여준다.
      (현재 사용하고 있는 시스템 시퀀스가 없음으로 이 뷰는
      항상 그 내용이 비어있을 것이다.)
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry><structname>pg_statio_all_sequences</structname> 내용과 같은데,
      시스템 시퀀스를 제외한 현재 사용자가 접근 할 수 있는
      시퀀스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       현재 데이터베이스에 만들어진 사용자 정의 함수들의
       실행에 대한 통계 정보를 보여준다.
       자세한 내용은 <xref linkend="pg-stat-user-functions-view"/> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry><structname>pg_stat_user_functions</structname> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다,
      (즉 <structname>pg_stat_user_functions</structname> 쪽으로 반영 되지
      <emphasis>않은</emphasis> 트랜잭션 내의 정보다).
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
      <command>VACUUM</command>, showing current progress.
      See <xref linkend='vacuum-progress-reporting'/>.</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   인덱스 별 통계 정보는 어느 인덱스가 많이 사용되며,
   어떻게 영향을 미치는 지를 조사하는데 특히 유용하게 쓰인다.
  </para>

  <para>
   <structname>pg_statio_</structname> 뷰들은 공유 버퍼의
   사용 빈도를 파악하는데 가장 기본이 되는 것들이다.
   이상적인 서버 운영 모습은 
   디스크 읽기 빈도 보다 공유 버퍼를 사용하는(buffer hit)
   빈도가 훨씬 높아서, 
   대부분의 작업이 커널 호출 작업 없이 이루워 지도록 
   하는 것이다.  한편, <productname>PostgreSQL</productname>
   에서는 단지 이 서버 기준으로 디스크를 읽은 것과
   서버의 공유 버퍼를 사용한 것에 대한 정보만 제공 할 
   뿐이다.  즉, 커널의 I/O 캐시 사용 빈도에 대해서는 
   제공하지 않는다.  다시 말하면, 
   정말 디스크를 읽은 것인지, OS의 I/O 캐시를 사용한 
   것인지는 이 뷰를 통해서는 알 수 없다.
   이런 세세한 부분까지 살펴 보려면, 
   OS 관련 도구들을 이용해야 할 것이다.
  </para>


  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title><structname>pg_stat_activity</structname> View</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>이 백엔드가 연결된 데이터베이스의 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>이 백엔드가 연결된 데이터베이스의 이름</entry>
    </row>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>이 백엔드의 프로세스 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>이 백엔드에 로그인 한 사용자의 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>이 백엔드에 로그인 한 사용자의 이름</entry>
    </row>
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>이 백엔드에 연결된 애플리케이션의 이름</entry>
    </row>
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>이 백엔드에 연결된 클라이언트의 IP 주소. 이 필드가 null이면 클라이언트가 
     서버 머신의 UNIX 소켓으로 연결이 되어 있다는 뜻이거나 autovacuum같은 내부 프로세스라는 뜻임
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry><structfield>client_addr</structfield>의 DNS를 역조회해서 찾은 클라이언트의 호스트명. 이 필드는 IP 연결했을 때와 <xref
      linkend="guc-log-hostname"/>이 활성화됐을 때만 null이 아닌 값으로 저장됨
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>이 백엔드와 교류하는 데 클라이언트가 쓰는 TCP 포트 넘버. <literal>-1</literal>은 UNIX 소켓이 사용됐을 때
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>이 프로세스가 시작된 시간. 예를 들어 클라이언트가 서버에 연결되었을 때
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>이 프로세스의 현재 트랜잭션이 시작된 시간이거나 어떤 트랜잭션도 수행되고 있지 않을 때 null로 표시함 
      현재 쿼리가 트랜잭션의 첫 번째 쿼리이면 이 칼럼은 <structfield>query_start</structfield> 칼럼과 같다.
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>현재 수행 중인 쿼리가 시작된 시간이거나 
      <structfield>state</structfield>가 <literal>active</literal>가 아닐 때에는 마지막 쿼리가 시작된 시간을 뜻함
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry><structfield>state</structfield>가 마지막으로 변경된 시간</entry>
    </row>
     <row>
      <entry><structfield>wait_event_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The type of event for which the backend is waiting, if any;
       otherwise NULL. Possible values are:
       <itemizedlist>
        <listitem>
         <para>
          <literal>LWLock</literal>: The backend is waiting for a lightweight lock.
          Each such lock protects a particular data structure in shared memory.
          <literal>wait_event</literal> will contain a name identifying the purpose
          of the lightweight lock.  (Some locks have specific names; others
          are part of a group of locks each with a similar purpose.)
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Lock</literal>: The backend is waiting for a heavyweight lock.
          Heavyweight locks, also known as lock manager locks or simply locks,
          primarily protect SQL-visible objects such as tables.  However,
          they are also used to ensure mutual exclusion for certain internal
          operations such as relation extension.  <literal>wait_event</literal> will
          identify the type of lock awaited.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>BufferPin</literal>: The server process is waiting to access to
          a data buffer during a period when no other process can be
          examining that buffer.  Buffer pin waits can be protracted if
          another process holds an open cursor which last read data from the
          buffer in question.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Activity</literal>: The server process is idle.  This is used by
          system processes waiting for activity in their main processing loop.
          <literal>wait_event</literal> will identify the specific wait point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Extension</literal>: The server process is waiting for activity
          in an extension module.  This category is useful for modules to
          track custom waiting points.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Client</literal>: The server process is waiting for some activity
          on a socket from user applications, and that the server expects
          something to happen that is independent from its internal processes.
          <literal>wait_event</literal> will identify the specific wait point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IPC</literal>: The server process is waiting for some activity
          from another process in the server.  <literal>wait_event</literal> will
          identify the specific wait point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>Timeout</literal>: The server process is waiting for a timeout
          to expire.  <literal>wait_event</literal> will identify the specific wait
          point.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>IO</literal>: The server process is waiting for a IO to complete.
          <literal>wait_event</literal> will identify the specific wait point.
         </para>
        </listitem>
       </itemizedlist>
      </entry>
     </row>
    <row>
     <entry><structfield>wait_event</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Wait event name if backend is currently waiting, otherwise NULL.
     See <xref linkend="wait-event-table"/> for details.
     </entry>
    </row>
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>현재 이 백엔드의 전체 상태. 가능한 값들은 아래와 같다.
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</literal>: 백엔드가 쿼리를 수행하고 있다는 뜻
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</literal>: 백엔드가 새로운 클라이언트 명령어를 기다리고 있음을 나타냄
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</literal>: 백엔드가 트랜잭션을 수행하고 있지만 쿼리를 수행하고 있지는 않은 상태
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</literal>: <literal>idle in transaction</literal>과 비슷하지만 트랜잭션의 구문들 중 하나가 에러를 발생시켰을 때
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</literal>: 백엔드가 fast-path함수를 수행할 때
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</literal>: <xref
           linkend="guc-track-activities"/>가 이 백엔드에서 비활성화됐을 때 
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xid</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>있다면, 해당 백엔드의 최상위 트랜잭션 식별자</entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>백엔드 현재 <literal>xmin</literal>.</entry>
    </row>
    <row>
     <entry><structfield>query</structfield></entry>
     <entry><type>text</type></entry>
     <entry>이 백엔드의 가장 최근 쿼리 내 텍스트. <structfield>state</structfield>가
      <literal>active</literal>이면 이 필드는 현재 수행 중인 쿼리를 보여 줌.  다른
      state들에서는 마지막으로 수행된 쿼리를 보여 줌.  기본적으로 이 내용은
      1024 바이트만 보여 줌.  이 값은
      <xref linkend="guc-track-activity-query-size"/> 설정에서 변경할 수 있음.
     </entry>
    </row>
    <row>
     <entry><structfield>backend_type</structfield></entry>
     <entry><type>text</type></entry>
     <entry>백엔드 종류, 다음 중 하나:
      <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
      <literal>logical replication launcher</literal>,
      <literal>logical replication worker</literal>,
      <literal>parallel worker</literal>, <literal>background writer</literal>,
      <literal>client backend</literal>, <literal>checkpointer</literal>,
      <literal>startup</literal>, <literal>walreceiver</literal>,
      <literal>walsender</literal>, <literal>walwriter</literal>.
      In addition, background workers registered by extensions may have
      additional types.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_activity</structname> 뷰는 서버 프로세스당 한 개의 로우를 가지며 이는 해당 프로세스의 현재 활동 관련 정보를 보여준다.
  </para>

  <note>
   <para>
    <structfield>wait_event</structfield>와 <structfield>state</structfield>칼럼은 독립적이다. 
    백엔드가 <literal>active</literal> 상태일 때,
    그 이벤트가 <literal>waiting</literal> 일 수도 있고 아닐 수도 있다.  상태가
    <literal>active</literal>이고, <structfield>wait_event</structfield> 값이 비어 있지
    않으면, 쿼리가 현재 실행 중이지만, 시스템 어딘가에서 지연이 
    발생했음을 의미한다.
   </para>
  </note>

  <table id="wait-event-table">
   <title><structname>wait_event</structname> Description</title>

    <tgroup cols="3">
      <thead>
       <row>
        <entry>Wait Event Type</entry>
        <entry>Wait Event Name</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry morerows="66"><literal>LWLock</literal></entry>
        <entry><literal>ShmemIndexLock</literal></entry>
        <entry>Waiting to find or allocate space in shared memory.</entry>
       </row>
       <row>
        <entry><literal>OidGenLock</literal></entry>
        <entry>Waiting to allocate or assign an OID.</entry>
       </row>
        <row>
         <entry><literal>XidGenLock</literal></entry>
         <entry>Waiting to allocate or assign a transaction id.</entry>
        </row>
        <row>
         <entry><literal>ProcArrayLock</literal></entry>
         <entry>Waiting to get a snapshot or clearing a transaction id at
         transaction end.</entry>
        </row>
        <row>
         <entry><literal>Promote</literal></entry>
         <entry>Waiting for standby promotion.</entry>
        </row>
        <row>
         <entry><literal>SInvalReadLock</literal></entry>
         <entry>Waiting to retrieve or remove messages from shared invalidation
         queue.</entry>
        </row>
        <row>
         <entry><literal>SInvalWriteLock</literal></entry>
         <entry>Waiting to add a message in shared invalidation queue.</entry>
        </row>
        <row>
         <entry><literal>WALBufMappingLock</literal></entry>
         <entry>Waiting to replace a page in WAL buffers.</entry>
        </row>
        <row>
         <entry><literal>WALWriteLock</literal></entry>
         <entry>Waiting for WAL buffers to be written to disk.</entry>
        </row>
        <row>
         <entry><literal>ControlFileLock</literal></entry>
         <entry>Waiting to read or update the control file or creation of a
         new WAL file.</entry>
        </row>
        <row>
         <entry><literal>CheckpointLock</literal></entry>
         <entry>Waiting to perform checkpoint.</entry>
        </row>
        <row>
         <entry><literal>CLogControlLock</literal></entry>
         <entry>Waiting to read or update transaction status.</entry>
        </row>
        <row>
         <entry><literal>SubtransControlLock</literal></entry>
         <entry>Waiting to read or update sub-transaction information.</entry>
        </row>
        <row>
         <entry><literal>MultiXactGenLock</literal></entry>
         <entry>Waiting to read or update shared multixact state.</entry>
        </row>
        <row>
         <entry><literal>MultiXactOffsetControlLock</literal></entry>
         <entry>Waiting to read or update multixact offset mappings.</entry>
        </row>
        <row>
         <entry><literal>MultiXactMemberControlLock</literal></entry>
         <entry>Waiting to read or update multixact member mappings.</entry>
        </row>
        <row>
         <entry><literal>RelCacheInitLock</literal></entry>
         <entry>Waiting to read or write relation cache initialization
         file.</entry>
        </row>
        <row>
         <entry><literal>CheckpointerCommLock</literal></entry>
         <entry>Waiting to manage fsync requests.</entry>
        </row>
        <row>
         <entry><literal>TwoPhaseStateLock</literal></entry>
         <entry>Waiting to read or update the state of prepared transactions.</entry>
        </row>
        <row>
         <entry><literal>TablespaceCreateLock</literal></entry>
         <entry>Waiting to create or drop the tablespace.</entry>
        </row>
        <row>
         <entry><literal>BtreeVacuumLock</literal></entry>
          <entry>Waiting to read or update vacuum-related information for a
          B-tree index.</entry>
        </row>
        <row>
         <entry><literal>AddinShmemInitLock</literal></entry>
         <entry>Waiting to manage space allocation in shared memory.</entry>
        </row>
        <row>
         <entry><literal>AutovacuumLock</literal></entry>
         <entry>Autovacuum worker or launcher waiting to update or
         read the current state of autovacuum workers.</entry>
        </row>
        <row>
         <entry><literal>AutovacuumScheduleLock</literal></entry>
         <entry>Waiting to ensure that the table it has selected for a vacuum
         still needs vacuuming.
         </entry>
        </row>
        <row>
         <entry><literal>SyncScanLock</literal></entry>
         <entry>Waiting to get the start location of a scan on a table for
         synchronized scans.</entry>
        </row>
        <row>
         <entry><literal>RelationMappingLock</literal></entry>
         <entry>Waiting to update the relation map file used to store catalog
         to filenode mapping.
         </entry>
        </row>
        <row>
         <entry><literal>AsyncCtlLock</literal></entry>
         <entry>Waiting to read or update shared notification state.</entry>
        </row>
        <row>
         <entry><literal>AsyncQueueLock</literal></entry>
          <entry>Waiting to read or update notification messages.</entry>
        </row>
        <row>
         <entry><literal>SerializableXactHashLock</literal></entry>
         <entry>Waiting to retrieve or store information about serializable
         transactions.</entry>
        </row>
        <row>
         <entry><literal>SerializableFinishedListLock</literal></entry>
         <entry>Waiting to access the list of finished serializable
         transactions.</entry>
        </row>
        <row>
         <entry><literal>SerializablePredicateLockListLock</literal></entry>
         <entry>Waiting to perform an operation on a list of locks held by
         serializable transactions.</entry>
        </row>
        <row>
         <entry><literal>OldSerXidLock</literal></entry>
         <entry>Waiting to read or record conflicting serializable
         transactions.</entry>
        </row>
        <row>
         <entry><literal>SyncRepLock</literal></entry>
         <entry>Waiting to read or update information about synchronous
         replicas.</entry>
        </row>
        <row>
         <entry><literal>BackgroundWorkerLock</literal></entry>
         <entry>Waiting to read or update background worker state.</entry>
        </row>
        <row>
         <entry><literal>DynamicSharedMemoryControlLock</literal></entry>
         <entry>Waiting to read or update dynamic shared memory state.</entry>
        </row>
        <row>
         <entry><literal>AutoFileLock</literal></entry>
         <entry>Waiting to update the <filename>postgresql.auto.conf</filename> file.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotAllocationLock</literal></entry>
         <entry>Waiting to allocate or free a replication slot.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotControlLock</literal></entry>
         <entry>Waiting to read or update replication slot state.</entry>
        </row>
        <row>
         <entry><literal>CommitTsControlLock</literal></entry>
         <entry>Waiting to read or update transaction commit timestamps.</entry>
        </row>
        <row>
         <entry><literal>CommitTsLock</literal></entry>
         <entry>Waiting to read or update the last value set for the
         transaction timestamp.</entry>
        </row>
        <row>
         <entry><literal>ReplicationOriginLock</literal></entry>
         <entry>Waiting to setup, drop or use replication origin.</entry>
        </row>
        <row>
         <entry><literal>MultiXactTruncationLock</literal></entry>
         <entry>Waiting to read or truncate multixact information.</entry>
        </row>
        <row>
         <entry><literal>OldSnapshotTimeMapLock</literal></entry>
         <entry>Waiting to read or update old snapshot control information.</entry>
        </row>
        <row>
         <entry><literal>LogicalRepWorkerLock</literal></entry>
         <entry>Waiting for action on logical replication worker to finish.</entry>
        </row>
        <row>
         <entry><literal>CLogTruncationLock</literal></entry>
         <entry>Waiting to execute <function>txid_status</function> or update
         the oldest transaction id available to it.</entry>
        </row>
        <row>
         <entry><literal>WrapLimitsVacuumLock</literal></entry>
         <entry>Waiting to update limits on transaction id and multixact
         consumption.</entry>
        </row>
        <row>
         <entry><literal>NotifyQueueTailLock</literal></entry>
         <entry>Waiting to update limit on notification message
         storage.</entry>
        </row>
        <row>
         <entry><literal>clog</literal></entry>
         <entry>Waiting for I/O on a clog (transaction status) buffer.</entry>
        </row>
        <row>
         <entry><literal>commit_timestamp</literal></entry>
         <entry>Waiting for I/O on commit timestamp buffer.</entry>
        </row>
        <row>
         <entry><literal>subtrans</literal></entry>
         <entry>Waiting for I/O a subtransaction buffer.</entry>
        </row>
        <row>
         <entry><literal>multixact_offset</literal></entry>
         <entry>Waiting for I/O on a multixact offset buffer.</entry>
        </row>
        <row>
         <entry><literal>multixact_member</literal></entry>
         <entry>Waiting for I/O on a multixact_member buffer.</entry>
        </row>
        <row>
         <entry><literal>async</literal></entry>
         <entry>Waiting for I/O on an async (notify) buffer.</entry>
        </row>
        <row>
         <entry><literal>oldserxid</literal></entry>
         <entry>Waiting for I/O on an oldserxid buffer.</entry>
        </row>
        <row>
         <entry><literal>wal_insert</literal></entry>
         <entry>Waiting to insert WAL into a memory buffer.</entry>
        </row>
        <row>
         <entry><literal>buffer_content</literal></entry>
         <entry>Waiting to read or write a data page in memory.</entry>
        </row>
        <row>
         <entry><literal>buffer_io</literal></entry>
         <entry>Waiting for I/O on a data page.</entry>
        </row>
        <row>
         <entry><literal>replication_origin</literal></entry>
         <entry>Waiting to read or update the replication progress.</entry>
        </row>
        <row>
         <entry><literal>replication_slot_io</literal></entry>
         <entry>Waiting for I/O on a replication slot.</entry>
        </row>
        <row>
         <entry><literal>proc</literal></entry>
         <entry>Waiting to read or update the fast-path lock information.</entry>
        </row>
        <row>
         <entry><literal>buffer_mapping</literal></entry>
         <entry>Waiting to associate a data block with a buffer in the buffer
         pool.</entry>
        </row>
        <row>
         <entry><literal>lock_manager</literal></entry>
         <entry>Waiting to add or examine locks for backends, or waiting to
         join or exit a locking group (used by parallel query).</entry>
        </row>
        <row>
         <entry><literal>predicate_lock_manager</literal></entry>
         <entry>Waiting to add or examine predicate lock information.</entry>
        </row>
        <row>
         <entry><literal>serializable_xact</literal></entry>
         <entry>Waiting to perform an operation on a serializable transaction
         in a parallel query.</entry>
        </row>
        <row>
         <entry><literal>parallel_query_dsa</literal></entry>
         <entry>Waiting for parallel query dynamic shared memory allocation lock.</entry>
        </row>
        <row>
         <entry><literal>tbm</literal></entry>
         <entry>Waiting for TBM shared iterator lock.</entry>
        </row>
        <row>
         <entry><literal>parallel_append</literal></entry>
         <entry>Waiting to choose the next subplan during Parallel Append plan
         execution.</entry>
        </row>
        <row>
         <entry><literal>parallel_hash_join</literal></entry>
         <entry>Waiting to allocate or exchange a chunk of memory or update
         counters during Parallel Hash plan execution.</entry>
        </row>
        <row>
         <entry morerows="10"><literal>Lock</literal></entry>
         <entry><literal>relation</literal></entry>
         <entry>Waiting to acquire a lock on a relation.</entry>
        </row>
        <row>
         <entry><literal>extend</literal></entry>
         <entry>Waiting to extend a relation.</entry>
        </row>
        <row>
         <entry><literal>frozenid</literal></entry>
         <entry>Waiting to
         update <structname>pg_database</structname>.<structfield>datfrozenxid</structfield>
         and <structname>pg_database</structname>.<structfield>datminmxid</structfield>.</entry>
        </row>
        <row>
         <entry><literal>page</literal></entry>
         <entry>Waiting to acquire a lock on page of a relation.</entry>
        </row>
        <row>
         <entry><literal>tuple</literal></entry>
         <entry>Waiting to acquire a lock on a tuple.</entry>
        </row>
        <row>
         <entry><literal>transactionid</literal></entry>
         <entry>Waiting for a transaction to finish.</entry>
        </row>
        <row>
         <entry><literal>virtualxid</literal></entry>
         <entry>Waiting to acquire a virtual xid lock.</entry>
        </row>
        <row>
         <entry><literal>speculative token</literal></entry>
         <entry>Waiting to acquire a speculative insertion lock.</entry>
        </row>
        <row>
         <entry><literal>object</literal></entry>
         <entry>Waiting to acquire a lock on a non-relation database object.</entry>
        </row>
        <row>
         <entry><literal>userlock</literal></entry>
         <entry>Waiting to acquire a user lock.</entry>
        </row>
        <row>
         <entry><literal>advisory</literal></entry>
         <entry>Waiting to acquire an advisory user lock.</entry>
        </row>
        <row>
         <entry><literal>BufferPin</literal></entry>
         <entry><literal>BufferPin</literal></entry>
         <entry>Waiting to acquire a pin on a buffer.</entry>
        </row>
        <row>
         <entry morerows="13"><literal>Activity</literal></entry>
         <entry><literal>ArchiverMain</literal></entry>
         <entry>Waiting in main loop of the archiver process.</entry>
        </row>
        <row>
         <entry><literal>AutoVacuumMain</literal></entry>
         <entry>Waiting in main loop of autovacuum launcher process.</entry>
        </row>
        <row>
         <entry><literal>BgWriterHibernate</literal></entry>
         <entry>Waiting in background writer process, hibernating.</entry>
        </row>
        <row>
         <entry><literal>BgWriterMain</literal></entry>
         <entry>Waiting in main loop of background writer process background worker.</entry>
        </row>
        <row>
         <entry><literal>CheckpointerMain</literal></entry>
         <entry>Waiting in main loop of checkpointer process.</entry>
        </row>
        <row>
         <entry><literal>LogicalApplyMain</literal></entry>
         <entry>Waiting in main loop of logical apply process.</entry>
        </row>
        <row>
         <entry><literal>LogicalLauncherMain</literal></entry>
         <entry>Waiting in main loop of logical launcher process.</entry>
        </row>
        <row>
         <entry><literal>PgStatMain</literal></entry>
         <entry>Waiting in main loop of the statistics collector process.</entry>
        </row>
        <row>
         <entry><literal>RecoveryWalAll</literal></entry>
         <entry>Waiting for WAL from a stream at recovery.</entry>
        </row>
        <row>
         <entry><literal>RecoveryWalStream</literal></entry>
         <entry>
          Waiting when WAL data is not available from any kind of sources
          (local, archive or stream) before trying again to retrieve WAL data,
          at recovery.
         </entry>
        </row>
        <row>
         <entry><literal>SysLoggerMain</literal></entry>
         <entry>Waiting in main loop of syslogger process.</entry>
        </row>
        <row>
         <entry><literal>WalReceiverMain</literal></entry>
         <entry>Waiting in main loop of WAL receiver process.</entry>
        </row>
        <row>
         <entry><literal>WalSenderMain</literal></entry>
         <entry>Waiting in main loop of WAL sender process.</entry>
        </row>
        <row>
         <entry><literal>WalWriterMain</literal></entry>
         <entry>Waiting in main loop of WAL writer process.</entry>
        </row>
        <row>
         <entry morerows="8"><literal>Client</literal></entry>
         <entry><literal>ClientRead</literal></entry>
         <entry>Waiting to read data from the client.</entry>
        </row>
        <row>
         <entry><literal>ClientWrite</literal></entry>
         <entry>Waiting to write data to the client.</entry>
        </row>
        <row>
         <entry><literal>GSSOpenServer</literal></entry>
         <entry>Waiting to read data from the client while establishing the GSSAPI session.</entry>
        </row>
        <row>
         <entry><literal>LibPQWalReceiverConnect</literal></entry>
         <entry>Waiting in WAL receiver to establish connection to remote server.</entry>
        </row>
        <row>
         <entry><literal>LibPQWalReceiverReceive</literal></entry>
         <entry>Waiting in WAL receiver to receive data from remote server.</entry>
        </row>
        <row>
         <entry><literal>SSLOpenServer</literal></entry>
         <entry>Waiting for SSL while attempting connection.</entry>
        </row>
        <row>
         <entry><literal>WalReceiverWaitStart</literal></entry>
         <entry>Waiting for startup process to send initial data for streaming replication.</entry>
        </row>
        <row>
         <entry><literal>WalSenderWaitForWAL</literal></entry>
         <entry>Waiting for WAL to be flushed in WAL sender process.</entry>
        </row>
        <row>
         <entry><literal>WalSenderWriteData</literal></entry>
         <entry>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</entry>
        </row>
        <row>
         <entry><literal>Extension</literal></entry>
         <entry><literal>Extension</literal></entry>
         <entry>Waiting in an extension.</entry>
        </row>
        <row>
         <entry morerows="36"><literal>IPC</literal></entry>
         <entry><literal>BgWorkerShutdown</literal></entry>
         <entry>Waiting for background worker to shut down.</entry>
        </row>
        <row>
         <entry><literal>BgWorkerStartup</literal></entry>
         <entry>Waiting for background worker to start up.</entry>
        </row>
        <row>
         <entry><literal>BtreePage</literal></entry>
         <entry>Waiting for the page number needed to continue a parallel B-tree scan to become available.</entry>
        </row>
        <row>
         <entry><literal>CheckpointDone</literal></entry>
         <entry>Waiting for a checkpoint to complete.</entry>
        </row>
        <row>
         <entry><literal>CheckpointStart</literal></entry>
         <entry>Waiting for a checkpoint to start.</entry>
        </row>
        <row>
         <entry><literal>ClogGroupUpdate</literal></entry>
         <entry>Waiting for group leader to update transaction status at transaction end.</entry>
        </row>
        <row>
         <entry><literal>ExecuteGather</literal></entry>
         <entry>Waiting for activity from child process when executing <literal>Gather</literal> node.</entry>
        </row>
        <row>
          <entry><literal>Hash/Batch/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to allocate a hash table.</entry>
        </row>
        <row>
          <entry><literal>Hash/Batch/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate a hash table.</entry>
        </row>
        <row>
          <entry><literal>Hash/Batch/Loading</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish loading a hash table.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate the initial hash table.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/HashingInner</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish hashing the inner relation.</entry>
        </row>
        <row>
          <entry><literal>Hash/Build/HashingOuter</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to allocate more batches.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Deciding</literal></entry>
          <entry>Electing a Parallel Hash participant to decide on future batch growth.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate more batches.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Finishing</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to decide on future batch growth.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBatches/Repartitioning</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finishing repartitioning.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBuckets/Allocating</literal></entry>
          <entry>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBuckets/Electing</literal></entry>
          <entry>Electing a Parallel Hash participant to allocate more buckets.</entry>
        </row>
        <row>
          <entry><literal>Hash/GrowBuckets/Reinserting</literal></entry>
          <entry>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</entry>
        </row>
        <row>
         <entry><literal>LogicalSyncData</literal></entry>
         <entry>Waiting for logical replication remote server to send data for initial table synchronization.</entry>
        </row>
        <row>
         <entry><literal>LogicalSyncStateChange</literal></entry>
         <entry>Waiting for logical replication remote server to change state.</entry>
        </row>
        <row>
         <entry><literal>MessageQueueInternal</literal></entry>
         <entry>Waiting for other process to be attached in shared message queue.</entry>
        </row>
        <row>
         <entry><literal>MessageQueuePutMessage</literal></entry>
         <entry>Waiting to write a protocol message to a shared message queue.</entry>
        </row>
        <row>
         <entry><literal>MessageQueueReceive</literal></entry>
         <entry>Waiting to receive bytes from a shared message queue.</entry>
        </row>
        <row>
         <entry><literal>MessageQueueSend</literal></entry>
         <entry>Waiting to send bytes to a shared message queue.</entry>
        </row>
        <row>
         <entry><literal>ParallelBitmapScan</literal></entry>
         <entry>Waiting for parallel bitmap scan to become initialized.</entry>
        </row>
        <row>
         <entry><literal>ParallelCreateIndexScan</literal></entry>
         <entry>Waiting for parallel <command>CREATE INDEX</command> workers to finish heap scan.</entry>
        </row>
        <row>
         <entry><literal>ParallelFinish</literal></entry>
         <entry>Waiting for parallel workers to finish computing.</entry>
        </row>
        <row>
         <entry><literal>ProcArrayGroupUpdate</literal></entry>
         <entry>Waiting for group leader to clear transaction id at transaction end.</entry>
        </row>
        <row>
         <entry><literal>ReplicationOriginDrop</literal></entry>
         <entry>Waiting for a replication origin to become inactive to be dropped.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotDrop</literal></entry>
         <entry>Waiting for a replication slot to become inactive to be dropped.</entry>
        </row>
        <row>
         <entry><literal>SafeSnapshot</literal></entry>
         <entry>Waiting for a snapshot for a <literal>READ ONLY DEFERRABLE</literal> transaction.</entry>
        </row>
        <row>
         <entry><literal>SyncRep</literal></entry>
         <entry>Waiting for confirmation from remote server during synchronous replication.</entry>
        </row>
        <row>
         <entry morerows="2"><literal>Timeout</literal></entry>
         <entry><literal>BaseBackupThrottle</literal></entry>
         <entry>Waiting during base backup when throttling activity.</entry>
        </row>
        <row>
         <entry><literal>PgSleep</literal></entry>
         <entry>Waiting in process that called <function>pg_sleep</function>.</entry>
        </row>
        <row>
         <entry><literal>RecoveryApplyDelay</literal></entry>
         <entry>Waiting to apply WAL at recovery because it is delayed.</entry>
        </row>
        <row>
         <entry morerows="67"><literal>IO</literal></entry>
         <entry><literal>BufFileRead</literal></entry>
         <entry>Waiting for a read from a buffered file.</entry>
        </row>
        <row>
         <entry><literal>BufFileWrite</literal></entry>
         <entry>Waiting for a write to a buffered file.</entry>
        </row>
        <row>
         <entry><literal>ControlFileRead</literal></entry>
         <entry>Waiting for a read from the control file.</entry>
        </row>
        <row>
         <entry><literal>ControlFileSync</literal></entry>
         <entry>Waiting for the control file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>ControlFileSyncUpdate</literal></entry>
         <entry>Waiting for an update to the control file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>ControlFileWrite</literal></entry>
         <entry>Waiting for a write to the control file.</entry>
        </row>
        <row>
         <entry><literal>ControlFileWriteUpdate</literal></entry>
         <entry>Waiting for a write to update the control file.</entry>
        </row>
        <row>
         <entry><literal>CopyFileRead</literal></entry>
         <entry>Waiting for a read during a file copy operation.</entry>
        </row>
        <row>
         <entry><literal>CopyFileWrite</literal></entry>
         <entry>Waiting for a write during a file copy operation.</entry>
        </row>
        <row>
         <entry><literal>DataFileExtend</literal></entry>
         <entry>Waiting for a relation data file to be extended.</entry>
        </row>
        <row>
         <entry><literal>DataFileFlush</literal></entry>
         <entry>Waiting for a relation data file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>DataFileImmediateSync</literal></entry>
         <entry>Waiting for an immediate synchronization of a relation data file to durable storage.</entry>
        </row>
        <row>
         <entry><literal>DataFilePrefetch</literal></entry>
         <entry>Waiting for an asynchronous prefetch from a relation data file.</entry>
        </row>
        <row>
         <entry><literal>DataFileRead</literal></entry>
         <entry>Waiting for a read from a relation data file.</entry>
        </row>
        <row>
         <entry><literal>DataFileSync</literal></entry>
         <entry>Waiting for changes to a relation data file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>DataFileTruncate</literal></entry>
         <entry>Waiting for a relation data file to be truncated.</entry>
        </row>
        <row>
         <entry><literal>DataFileWrite</literal></entry>
         <entry>Waiting for a write to a relation data file.</entry>
        </row>
        <row>
         <entry><literal>DSMFillZeroWrite</literal></entry>
         <entry>Waiting to write zero bytes to a dynamic shared memory backing file.</entry>
        </row>
        <row>
         <entry><literal>LockFileAddToDataDirRead</literal></entry>
         <entry>Waiting for a read while adding a line to the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LockFileAddToDataDirSync</literal></entry>
         <entry>Waiting for data to reach durable storage while adding a line to the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LockFileAddToDataDirWrite</literal></entry>
         <entry>Waiting for a write while adding a line to the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LockFileCreateRead</literal></entry>
         <entry>Waiting to read while creating the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LockFileCreateSync</literal></entry>
         <entry>Waiting for data to reach durable storage while creating the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LockFileCreateWrite</literal></entry>
         <entry>Waiting for a write while creating the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LockFileReCheckDataDirRead</literal></entry>
         <entry>Waiting for a read during recheck of the data directory lock file.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
         <entry>Waiting for logical rewrite mappings to reach durable storage during a checkpoint.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteMappingSync</literal></entry>
         <entry>Waiting for mapping data to reach durable storage during a logical rewrite.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteMappingWrite</literal></entry>
         <entry>Waiting for a write of mapping data during a logical rewrite.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteSync</literal></entry>
         <entry>Waiting for logical rewrite mappings to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteTruncate</literal></entry>
         <entry>Waiting for truncate of mapping data during a logical rewrite.</entry>
        </row>
        <row>
         <entry><literal>LogicalRewriteWrite</literal></entry>
         <entry>Waiting for a write of logical rewrite mappings.</entry>
        </row>
        <row>
         <entry><literal>RelationMapRead</literal></entry>
         <entry>Waiting for a read of the relation map file.</entry>
        </row>
        <row>
         <entry><literal>RelationMapSync</literal></entry>
         <entry>Waiting for the relation map file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>RelationMapWrite</literal></entry>
         <entry>Waiting for a write to the relation map file.</entry>
        </row>
        <row>
         <entry><literal>ReorderBufferRead</literal></entry>
         <entry>Waiting for a read during reorder buffer management.</entry>
        </row>
        <row>
         <entry><literal>ReorderBufferWrite</literal></entry>
         <entry>Waiting for a write during reorder buffer management.</entry>
        </row>
        <row>
         <entry><literal>ReorderLogicalMappingRead</literal></entry>
         <entry>Waiting for a read of a logical mapping during reorder buffer management.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotRead</literal></entry>
         <entry>Waiting for a read from a replication slot control file.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotRestoreSync</literal></entry>
         <entry>Waiting for a replication slot control file to reach durable storage while restoring it to memory.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotSync</literal></entry>
         <entry>Waiting for a replication slot control file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>ReplicationSlotWrite</literal></entry>
         <entry>Waiting for a write to a replication slot control file.</entry>
        </row>
        <row>
         <entry><literal>SLRUFlushSync</literal></entry>
         <entry>Waiting for SLRU data to reach durable storage during a checkpoint or database shutdown.</entry>
        </row>
        <row>
         <entry><literal>SLRURead</literal></entry>
         <entry>Waiting for a read of an SLRU page.</entry>
        </row>
        <row>
         <entry><literal>SLRUSync</literal></entry>
         <entry>Waiting for SLRU data to reach durable storage following a page write.</entry>
        </row>
        <row>
         <entry><literal>SLRUWrite</literal></entry>
         <entry>Waiting for a write of an SLRU page.</entry>
        </row>
        <row>
         <entry><literal>SnapbuildRead</literal></entry>
         <entry>Waiting for a read of a serialized historical catalog snapshot.</entry>
        </row>
        <row>
         <entry><literal>SnapbuildSync</literal></entry>
         <entry>Waiting for a serialized historical catalog snapshot to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>SnapbuildWrite</literal></entry>
         <entry>Waiting for a write of a serialized historical catalog snapshot.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryFileSync</literal></entry>
         <entry>Waiting for a timeline history file received via streaming replication to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryFileWrite</literal></entry>
         <entry>Waiting for a write of a timeline history file received via streaming replication.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryRead</literal></entry>
         <entry>Waiting for a read of a timeline history file.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistorySync</literal></entry>
         <entry>Waiting for a newly created timeline history file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>TimelineHistoryWrite</literal></entry>
         <entry>Waiting for a write of a newly created timeline history file.</entry>
        </row>
        <row>
         <entry><literal>TwophaseFileRead</literal></entry>
         <entry>Waiting for a read of a two phase state file.</entry>
        </row>
        <row>
         <entry><literal>TwophaseFileSync</literal></entry>
         <entry>Waiting for a two phase state file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>TwophaseFileWrite</literal></entry>
         <entry>Waiting for a write of a two phase state file.</entry>
        </row>
        <row>
         <entry><literal>WALBootstrapSync</literal></entry>
         <entry>Waiting for WAL to reach durable storage during bootstrapping.</entry>
        </row>
        <row>
         <entry><literal>WALBootstrapWrite</literal></entry>
         <entry>Waiting for a write of a WAL page during bootstrapping.</entry>
        </row>
        <row>
         <entry><literal>WALCopyRead</literal></entry>
         <entry>Waiting for a read when creating a new WAL segment by copying an existing one.</entry>
        </row>
        <row>
         <entry><literal>WALCopySync</literal></entry>
         <entry>Waiting a new WAL segment created by copying an existing one to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>WALCopyWrite</literal></entry>
         <entry>Waiting for a write when creating a new WAL segment by copying an existing one.</entry>
        </row>
        <row>
         <entry><literal>WALInitSync</literal></entry>
         <entry>Waiting for a newly initialized WAL file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>WALInitWrite</literal></entry>
         <entry>Waiting for a write while initializing a new WAL file.</entry>
        </row>
        <row>
         <entry><literal>WALRead</literal></entry>
         <entry>Waiting for a read from a WAL file.</entry>
        </row>
        <row>
         <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
         <entry>Waiting for a read from a timeline history file during walsender timeline command.</entry>
        </row>
        <row>
         <entry><literal>WALSync</literal></entry>
         <entry>Waiting for a WAL file to reach durable storage.</entry>
        </row>
        <row>
         <entry><literal>WALSyncMethodAssign</literal></entry>
         <entry>Waiting for data to reach durable storage while assigning WAL sync method.</entry>
        </row>
        <row>
         <entry><literal>WALWrite</literal></entry>
         <entry>Waiting for a write to a WAL file.</entry>
        </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     For tranches registered by extensions, the name is specified by extension
     and this will be displayed as <structfield>wait_event</structfield>.  It is quite
     possible that user has registered the tranche in one of the backends (by
     having allocation in dynamic shared memory) in which case other backends
     won't have that information, so we display <literal>extension</literal> for such
     cases.
    </para>
   </note>

   <para>
     Here is an example of how wait events can be viewed

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
------+-----------------+---------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArrayLock
(2 rows)
</programlisting>
   </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title><structname>pg_stat_replication</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>WAL 송신 프로세스의 프로세스 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>WAL 송신 프로세스에 로그인 된 사용자의 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>WAL 송신 프로세스에 로그인 된 사용자의 이름</entry>
    </row>
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>WAL 송신 프로세스에 연결된 애플리케이션명</entry>
    </row>
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>WAL 송신자에 연결된 클라이언트의 IP 주소. 이 필드가 null이면 클라이언트가 
     서버 머신의 UNIX 소켓으로 연결되었음을 의미함
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry><structfield>client_addr</structfield>의 DNS를 역조회해서 찾은 클라이언트의 호스트명. 
     이 필드는 IP로 연결했을 때와 <xref
      linkend="guc-log-hostname"/>이 활성화됐을 때만 null이 아닌 값으로 저장됨
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>클라이언트가 WAL 송신자와 커뮤니케이션 하기 위해 쓰는 TCP 포트 넘버. <literal>-1</literal> 이면 유닉스 소켓이 사용됐을 때
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>이 프로세스가 시작된 시간. 예를 들어 WAL 송신자와 클라이언트가 연결된 시간
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>This standby's <literal>xmin</literal> horizon reported
     by <xref linkend="guc-hot-standby-feedback"/>.</entry>
    </row>
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Current WAL sender state.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>startup</literal>: This WAL sender is starting up.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>catchup</literal>: This WAL sender's connected standby is
           catching up with the primary.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>streaming</literal>: This WAL sender is streaming changes
           after its connected standby server has caught up with the primary.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>backup</literal>: This WAL sender is sending a backup.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>stopping</literal>: This WAL sender is stopping.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>sent_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>이 연결에 전송된 마지막 미리-쓰기 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>write_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>대기 서버가 디스크에 쓴 마지막 미리-쓰기 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>flush_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>대기 서버가 디스크로 내린 마지막 미리-쓰기 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>replay_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>대기 서버에 있는 데이터베이스로 리플레이 된 마지막 미리-쓰기 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>write_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Time elapsed between flushing recent WAL locally and receiving
      notification that this standby server has written it (but not yet
      flushed it or applied it).  This can be used to gauge the delay that
      <literal>synchronous_commit</literal> level
      <literal>remote_write</literal> incurred while committing if this
      server was configured as a synchronous standby.</entry>
    </row>
    <row>
     <entry><structfield>flush_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Time elapsed between flushing recent WAL locally and receiving
      notification that this standby server has written and flushed it
      (but not yet applied it).  This can be used to gauge the delay that
      <literal>synchronous_commit</literal> level
      <literal>on</literal> incurred while committing if this
      server was configured as a synchronous standby.</entry>
    </row>
    <row>
     <entry><structfield>replay_lag</structfield></entry>
     <entry><type>interval</type></entry>
     <entry>Time elapsed between flushing recent WAL locally and receiving
      notification that this standby server has written, flushed and
      applied it.  This can be used to gauge the delay that
      <literal>synchronous_commit</literal> level
      <literal>remote_apply</literal> incurred while committing if this
      server was configured as a synchronous standby.</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>우선순위 기반 동기식 복제 대기 서버로 선택된 대기 서버의 우선순위
       투표 기반 동기식 복제에서는 영향 없음.
     </entry>
    </row>
    <row>
     <entry><structfield>sync_state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Synchronous state of this standby server.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>async</literal>: This standby server is asynchronous.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>potential</literal>: This standby server is now asynchronous,
           but can potentially become synchronous if one of current
           synchronous ones fails.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>sync</literal>: This standby server is synchronous.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>quorum</literal>: This standby server is considered as a candidate
           for quorum standbys.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>reply_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Send time of last reply message received from standby server</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_replication</structname>뷰는 WAL 송신자 프로세스당 하나의 로우를 가지며, 
   송신자가 연결된 대기 서버의 리플리케이션에 관한 통계치를 보여준다. 직접 연결된 대기 서버만 보여진다. 
   다운스트림 대기 서버에 관한 정보는 없다.
  </para>

  <para>
   The lag times reported in the <structname>pg_stat_replication</structname>
   view are measurements of the time taken for recent WAL to be written,
   flushed and replayed and for the sender to know about it.  These times
   represent the commit delay that was (or would have been) introduced by each
   synchronous commit level, if the remote server was configured as a
   synchronous standby.  For an asynchronous standby, the
   <structfield>replay_lag</structfield> column approximates the delay
   before recent transactions became visible to queries.  If the standby
   server has entirely caught up with the sending server and there is no more
   WAL activity, the most recently measured lag times will continue to be
   displayed for a short time and then show NULL.
  </para>

  <para>
   Lag times work automatically for physical replication. Logical decoding
   plugins may optionally emit tracking messages; if they do not, the tracking
   mechanism will simply display NULL lag.
  </para>

  <note>
   <para>
    The reported lag times are not predictions of how long it will take for
    the standby to catch up with the sending server assuming the current
    rate of replay.  Such a system would show similar times while new WAL is
    being generated, but would differ when the sender becomes idle.  In
    particular, when the standby has caught up completely,
    <structname>pg_stat_replication</structname> shows the time taken to
    write, flush and replay the most recent reported WAL location rather than
    zero as some users might expect.  This is consistent with the goal of
    measuring synchronous commit and transaction visibility delays for
    recent write transactions.
    To reduce confusion for users expecting a different model of lag, the
    lag columns revert to NULL after a short time on a fully replayed idle
    system. Monitoring systems should choose whether to represent this
    as missing data, zero or continue to display the last known value.
   </para>
  </note>

  <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
   <title><structname>pg_stat_wal_receiver</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of the WAL receiver process</entry>
    </row>
    <row>
     <entry><structfield>status</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Activity status of the WAL receiver process</entry>
    </row>
    <row>
     <entry><structfield>receive_start_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>First write-ahead log position used when WAL receiver is
      started</entry>
    </row>
    <row>
     <entry><structfield>receive_start_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>First timeline number used when WAL receiver is started</entry>
    </row>
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log position already received and flushed to
      disk, the initial value of this field being the first log location used
      when WAL receiver is started</entry>
    </row>
    <row>
     <entry><structfield>received_tli</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Timeline number of last write-ahead log position received and
      flushed to disk, the initial value of this field being the timeline
      number of the first log location used when WAL receiver is started
     </entry>
    </row>
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Send time of last message received from origin WAL sender</entry>
    </row>
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Receipt time of last message received from origin WAL sender</entry>
    </row>
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location reported to origin WAL sender</entry>
    </row>
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time of last write-ahead log location reported to origin WAL sender</entry>
    </row>
    <row>
     <entry><structfield>slot_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Replication slot name used by this WAL receiver</entry>
    </row>
    <row>
     <entry><structfield>sender_host</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      Host of the <productname>PostgreSQL</productname> instance
      this WAL receiver is connected to. This can be a host name,
      an IP address, or a directory path if the connection is via
      Unix socket.  (The path case can be distinguished because it
      will always be an absolute path, beginning with <literal>/</literal>.)
     </entry>
    </row>
    <row>
     <entry><structfield>sender_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>
      Port number of the <productname>PostgreSQL</productname> instance
      this WAL receiver is connected to.
     </entry>
    </row>
    <row>
     <entry><structfield>conninfo</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      Connection string used by this WAL receiver,
      with security-sensitive fields obfuscated.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_wal_receiver</structname> view will contain only
   one row, showing statistics about the WAL receiver from that receiver's
   connected server.
  </para>

  <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
   <title><structname>pg_stat_subscription</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>subid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the subscription</entry>
    </row>
    <row>
     <entry><structfield>subname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of the subscription</entry>
    </row>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of the subscription worker process</entry>
    </row>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>Oid</type></entry>
     <entry>OID of the relation that the worker is synchronizing; null for the
     main apply worker</entry>
    </row>
    <row>
     <entry><structfield>received_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location received, the initial value of
      this field being 0</entry>
    </row>
    <row>
     <entry><structfield>last_msg_send_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Send time of last message received from origin WAL sender</entry>
    </row>
    <row>
     <entry><structfield>last_msg_receipt_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Receipt time of last message received from origin WAL sender
     </entry>
    </row>
    <row>
     <entry><structfield>latest_end_lsn</structfield></entry>
     <entry><type>pg_lsn</type></entry>
     <entry>Last write-ahead log location reported to origin WAL sender
     </entry>
    </row>
    <row>
     <entry><structfield>latest_end_time</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time of last write-ahead log location reported to origin WAL
      sender</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_subscription</structname> view will contain one
   row per subscription for main worker (with null PID if the worker is
   not running), and additional rows for workers handling the initial data
   copy of the subscribed tables.
  </para>

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
   <title><structname>pg_stat_ssl</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of a backend or WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>ssl</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if SSL is used on this connection</entry>
    </row>
    <row>
     <entry><structfield>version</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Version of SSL in use, or NULL if SSL is not in use
      on this connection</entry>
    </row>
    <row>
     <entry><structfield>cipher</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of SSL cipher in use, or NULL if SSL is not in use
      on this connection</entry>
    </row>
    <row>
     <entry><structfield>bits</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Number of bits in the encryption algorithm used, or NULL
     if SSL is not used on this connection</entry>
    </row>
    <row>
     <entry><structfield>compression</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if SSL compression is in use, false if not,
      or NULL if SSL is not in use on this connection</entry>
    </row>
    <row>
     <entry><structfield>client_dn</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Distinguished Name (DN) field from the client certificate
      used, or NULL if no client certificate was supplied or if SSL
      is not in use on this connection. This field is truncated if the
      DN field is longer than <symbol>NAMEDATALEN</symbol> (64 characters
      in a standard build).
     </entry>
    </row>
    <row>
     <entry><structfield>client_serial</structfield></entry>
     <entry><type>numeric</type></entry>
     <entry>Serial number of the client certificate, or NULL if no client
     certificate was supplied or if SSL is not in use on this connection.  The
     combination of certificate serial number and certificate issuer uniquely
     identifies a certificate (unless the issuer erroneously reuses serial
     numbers).</entry>
    </row>
    <row>
     <entry><structfield>issuer_dn</structfield></entry>
     <entry><type>text</type></entry>
     <entry>DN of the issuer of the client certificate, or NULL if no client
     certificate was supplied or if SSL is not in use on this connection.
     This field is truncated like <structfield>client_dn</structfield>.</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_ssl</structname> view will contain one row per
   backend or WAL sender process, showing statistics about SSL usage on
   this connection. It can be joined to <structname>pg_stat_activity</structname>
   or <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>

  <table id="pg-stat-gssapi-view" xreflabel="pg_stat_gssapi">
   <title><structname>pg_stat_gssapi</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of a backend</entry>
    </row>
    <row>
     <entry><structfield>gss_authenticated</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if GSSAPI authentication was used for this connection</entry>
    </row>
    <row>
     <entry><structfield>principal</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Principal used to authenticate this connection, or NULL
      if GSSAPI was not used to authenticate this connection.  This
      field is truncated if the principal is longer than
      <symbol>NAMEDATALEN</symbol> (64 characters in a standard build).
     </entry>
    </row>
    <row>
     <entry><structfield>encrypted</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if GSSAPI encryption is in use on this connection</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_gssapi</structname> view will contain one row per
   backend, showing information about GSSAPI usage on this connection. It can
   be joined to <structname>pg_stat_activity</structname> or
   <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <title><structname>pg_stat_archiver</structname> View</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>archived_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>성공적으로 아카이브 된 WAL 파일의 개수</entry>
     </row>
     <row>
      <entry><structfield>last_archived_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>최근 성공적으로 아카이브 된 WAL 파일의 이름</entry>
     </row>
     <row>
      <entry><structfield>last_archived_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>최근 성공적으로 아카이브 작업을 한 시간</entry>
     </row>
     <row>
      <entry><structfield>failed_count</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>WAL 파일 아카이빙 시도에 실패한 횟수</entry>
     </row>
     <row>
      <entry><structfield>last_failed_wal</structfield></entry>
      <entry><type>text</type></entry>
      <entry>마지막으로 아카이빙 작업에 실패한 WAL 파일의 이름</entry>
     </row>
     <row>
      <entry><structfield>last_failed_time</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>마지막으로 아카이빙 작업에 실패한 시간</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>이 통계치가 마지막으로 리셋된 시간</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_archiver</structname> 뷰는 클러스터의 아카이버 프로세스에 관한 데이터가 있는 하나의 로우만 갖고 있다.
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title><structname>pg_stat_bgwriter</structname> 뷰</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>checkpoint_timeout 환경 설정값에 따른 체크 포인트 작업 회수</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>체크포인트 명령이 수행되어 진행한 작업 회수</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        체크포인트 작업으로 발생한 디스크 쓰기 작업의 밀리세컨드 총 시간. 
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        체크포인트 작업으로 발생할 디스크 쓰기에
        대한 디스크 동기화 작업(fsync)에 소요된 밀리세컨드 총 시간. 
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>checkpointer 프로세스가 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>writer 프로세스가 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>writer 프로세스가 기록해야 할 버퍼수가
       bgwriter_lru_maxpages 환경 설정값보다 많아서 작업이 중지된 회수
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>백엔드(세션) 프로세스가 직접 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>백엔드(세션) 프로세스가 직접 <function>fsync</function> 작업을
       한 회수 (일반적으로 백엔드(세션) 프로세스가 공유 버퍼를 디스크로
       내려 쓰더라도, 이 동기화 작업은 writer 프로세스가 담당한다.
       즉 writer 프로세스의 fsync 작업 부하량을 파악하는데 도움이 됨 - 옮긴이)
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers allocated</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>이 통계값들이 초기화 된 시각</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   <structname>pg_stat_bgwriter</structname> 뷰는 항상 한 개의 로우만
   보여준다. 이 자료는 데이터클러스터 전역 정보다.
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title><structname>pg_stat_database</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>데이터베이스의 OID, 0은 전역 릴레이션용 데이터베이스 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>해당 데이터베이스의 이름, <literal>NULL</literal>은 전역 릴레이션용 데이터베이스 이름</entry>
    </row>
    <row>
     <entry><structfield>numbackends</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>현재 연결된 백엔드의 수. <literal>NULL</literal>은 전역 릴레이션용. 
     현재 상태를 가리키는 값을 리턴 하는 유일한 칼럼. 
     다른 칼럼들은 마지막 리셋 시점 이후로 축적된 값들을 리턴함.
     </entry>
    </row>
    <row>
     <entry><structfield>xact_commit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>커밋된 트랜잭션의 수</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>롤백한 트랜잭션의 수</entry>
    </row>
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>버퍼 캐쉬에 이미 존재하는 디스크 블록을 감지하여 읽기가 불필요함을 알려줌. (PostgreSQL 버퍼 캐쉬 내 히트 수만 계산하고, 운영체제 파일 시스템 캐쉬는 확인하지 않음)
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리가 리턴한 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리가 fetch한 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리로 삽입된 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리로 업데이트된 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리로 삭제된 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>conflicts</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>복구 충돌로 인해 취소된 쿼리의 개수 (대기 서버에서만 발생하는 충돌을 말함. 
      <xref linkend="pg-stat-database-conflicts-view"/> 참조)
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리로 생성된 임시 파일의 개수. 모든 임시 파일은 임시 파일이 생성된 이유와 
      <xref linkend="guc-log-temp-files"/> 설정을 불문하고 카운트 됨
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>쿼리로 임시 파일에 쓰여진 데이터의 총합. 
     모든 임시 파일은 임시 파일이 생성된 이유와 <xref linkend="guc-log-temp-files"/> 설정을 불문하고 카운트 됨
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>감지된 교착상태의 개수</entry>
    </row>
    <row>
     <entry><structfield>checksum_failures</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of data page checksum failures detected in this
      database (or on a shared object), or NULL if data checksums are not
      enabled.</entry>
    </row>
    <row>
     <entry><structfield>checksum_last_failure</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time at which the last data page checksum failure was detected in
      this database (or on a shared object), or NULL if data checksums are not
      enabled.</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>백엔드가 데이터 파일 블록을 읽는 데 소요된 시간으로 밀리세컨드 단위를 사용</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>백엔드가 데이터 파일 블록을 쓰는데 소요된 시간으로 밀리세컨드 단위를 사용</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>통계치가 마지막으로 리셋된 시간</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_database</structname> 뷰는 클러스터 내 데이터베이스 당 한 개의 로우를 가지며 
   전체 데이터베이스 통계치를 보여준다. 더불어 전역 객체 전체 사용 정보도 한 개의 로우로 보여준다.
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
   <title><structname>pg_stat_database_conflicts</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>데이터베이스의 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>데이터베이스명</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>드롭된 테이블스페이스로 인해 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>잠금 시간초과로 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>이전 스냅샷으로 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>고정된 버퍼로 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>교착상태로 취소된 쿼리의 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_database_conflicts</structname> 뷰는 데이터베이스당 하나의 로우를 가지며, 
   대기 서버의 복구 충돌로 인해 발생한 쿼리 취소에 대해 전체 데이터베이스 통계치를 보여준다. 
   마스터 서버에서 충돌이 발생하지 않으므로 이 뷰는 대기 서버의 정보만 갖고 있다. 
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title><structname>pg_stat_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>테이블을 포함하는 스키마 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>테이블명</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>풀스캔을 시도한 횟수</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>풀스캔으로 가져온 live row 개수</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>인덱스 스캔을 시도한 횟수</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>인덱스 스캔으로 가져온 live row 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>삽입된 로우 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>업데이트된 로우 개수 (HOT 업데이터 로우도 포함)</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>삭제된 로우 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>HOT 업데이트 된 로우 개수 (예를 들어 따로 인덱스 업데이트 필요가 없는)</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>추정되는 live row 개수</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>추정되는 dead row 개수</entry>
    </row>
    <row>
     <entry><structfield>n_mod_since_analyze</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>마지막 analyze 이후 변경된 로우 수 (추정치)</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>테이블이 수동적으로 vacuum된 마지막 시간 
      (<command>VACUUM FULL</command>은 해당되지 않음)</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>autovacuum 데몬으로 테이블이 vacuum된 마지막 시간</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>테이블이 수동적으로 분석된 마지막 시간</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>autovacuum 데몬으로 테이블이 분석된 마지막 시간</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>수동적으로 vacuum된 횟수 
      (<command>VACUUM FULL</command>은 제외)</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>autovacuum 데몬으로 vacuum된 횟수</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>수동적으로 분석된 횟수</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>autovacuum 데몬으로 분석된 횟수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_all_tables</structname> 뷰는 현재 데이터베이스의 테이블(TOAST 테이블 포함)당 한 개의 로우를 가지며, 
   이는 해당 테이블 접근에 대한 통계치를 보여준다. <structname>pg_stat_user_tables</structname>와
   <structname>pg_stat_sys_tables</structname>뷰는 같은 정보를 가지나 사용자와 시스템 테이블 각각을 보여주는 데만 쓰인다.
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title><structname>pg_stat_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>이 인덱스를 갖는 테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>이 인덱스의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>이 인덱스가 있는 스키마의 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>이 인덱스를 갖는 테이블명</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>인덱스명</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>이 인덱스로 스캔한 횟수</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>이 인덱스로 스캔해서 리턴된 인덱스 엔트리의 개수</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>이 인덱스로 인덱스 스캔해서 가져온 live 테이블 로우의 개수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_all_indexes</structname> 뷰는 현재 데이터베이스에서 인덱스 당 한 개의 로우를 가지며 
   해당 인덱스 접근에 대한 통계치를 보여준다. 
   <structname>pg_stat_user_indexes</structname>와 
   <structname>pg_stat_sys_indexes</structname> 뷰는 같은 정보를 갖지만 각각 사용자와 시스템 인덱스만 보여준다. 
  </para>

  <para>
   인덱스는 단순한 인덱스 스캔, <quote>bitmap</quote> 인덱스 스캔, 쿼리 최적화기에서 사용된다.
   비트맵 스캔에서 일부 인덱스 결과는 AND나 OR 규칙으로 통합될 수 있어서, 
   비트맵 스캔이 사용되면 각각의 heap 로우들을 특정 인덱스에 매칭하기 어렵다. 비트맵 스캔은 사용된 인덱스의 
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
  를 증가시키고, 테이블의 
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   를 증가시키지만 
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>에는 영향을 미치지 않는다.
   The optimizer also accesses indexes to check for supplied constants
   whose values are outside the recorded range of the optimizer statistics
   because the optimizer statistics might be stale.
  </para>

  <note>
   <para>
    <structfield>idx_tup_read</structfield>와 <structfield>idx_tup_fetch</structfield>의 값은 비트맵 스캔을 하지 않아도 다를 수 있다. <structfield>idx_tup_read</structfield>는 인덱스에서 회수된 인덱스 엔트리 개수를 세지만, <structfield>idx_tup_fetch</structfield>
    는 테이블에서 가져온 live row를 세기 때문이다. 후자는 죽었거나 아직 커밋되지 않은 로우가 fetch되어 인덱스를 사용할 경우나 index-only 스캔으로 heap fetch들을 감지하지 못한 경우 감소한다.
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title><structname>pg_statio_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>이 테이블이 속한 스키마 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>이 테이블의 이름</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>이 테이블에서 읽힌 디스크 블록의 수 </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>이 테이블 내 버퍼 히트 수</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>테이블의 전체 인덱스에서 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>테이블 내 모든 인덱스에 대한 버퍼 히트의 수</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>TOAST 테이블(있으면)에서 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>TOAST 테이블(있으면) 내 버퍼 히트 수 </entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>TOAST 테이블 인덱스(있으면)에서 읽힌 디스크 블록 수</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>TOAST 테이블 인덱스(있으면) 내 버퍼 히트 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_tables</structname> 뷰는 현재 데이터베이스에서 각 테이블당(TOAST 테이블을 포함해서) 
   한 개의 로우를 갖는데, 해당 테이블의 I/O에 대한 통계치를 보여준다. 
   <structname>pg_statio_user_tables</structname>와 
   <structname>pg_statio_sys_tables</structname> 뷰도 같은 정보를 갖지만 각기 사용자와 시스템 테이블만 보여준다.
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title><structname>pg_statio_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>인덱스가 포함된 테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>인덱스의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>인덱스가 포함된 스키마의 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>인덱스가 포함된 테이블의 이름</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>인덱스명</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>인덱스로 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>인덱스 내 버퍼 히트 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_indexes</structname>뷰는 현재 데이터베이스의 각 인덱스당 하나의 로우를 갖는데, 
   해당 인덱스의 I/O에 대한 통계치를 보여준다. 
   <structname>pg_statio_user_indexes</structname>와 
   <structname>pg_statio_sys_indexes</structname> 뷰도 같은 정보를 갖지만 사용자와 시스템 인덱스만 각각 보여준다.
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title><structname>pg_statio_all_sequences</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>시퀀스의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>시퀀스가 포함된 스키마명</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>시퀀스명</entry>
    </row>
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>시퀀스에서 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>시퀀스 내 버퍼 히트 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_sequences</structname> 뷰는 현재 데이터베이스의 각 시퀀스당 한 개의 로우를 갖고, 
   해당 시퀀스의 I/O에 대한 통계치를 보여준다.
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title><structname>pg_stat_user_functions</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>함수의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>함수가 포함된 스키마명</entry>
    </row>
    <row>
     <entry><structfield>funcname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>함수명</entry>
    </row>
    <row>
     <entry><structfield>calls</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>함수가 호출된 횟수</entry>
    </row>
    <row>
     <entry><structfield>total_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>함수와 호출된 함수들에 소요된 밀리세컨드 총 시간</entry>
    </row>
    <row>
     <entry><structfield>self_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>호출된 함수들을 제외하고 이 함수에 소요된 밀리세컨드 총 시간</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_user_functions</structname> 뷰는 추적된 각 함수당 한 개의 로우를 가지며, 
   함수 수행에 대한 통계치를 보여 준다. <xref linkend="guc-track-functions"/>는 정확히 어떤 함수가 추적되어야 하는지 정한다.
  </para>


 </sect2>

 <sect2 id="monitoring-stats-functions">
  <title>통계 함수들</title>

  <para>
   위에서 소개한 뷰를 통해서 서버 통계 정보를 살펴보는 방법과
   함께 또 다른 한 방법은 각각의 정보를 제공하는 
   함수를 사용하는 방법이다.  위에서 
   소개한 뷰들의 뷰 정의를 살펴보면, 
   각각의 뷰가 어떤 함수들을 사용하는지 알 수 있다.
   (예를 들면, <application>psql</application> 에서
    <literal>\d+ pg_stat_activity</literal> 명령을 사용하면 된다.)
   데이터베이스 단위로 통계 정보를 보여주는 
   함수들에 대해서는 함수의 입력 인자로 데이터베이스 OID를 
   입력해야 한다.  이처럼, 테이블별, 인덱스별,
   함수별 통계 정보를 살펴보려면,
   그 각 객체의 OID를 입력 인자로 사용하면 된다.
   기억해야 할 점은, 테이블, 인덱스, 함수 같은 각 데이터베이스
   소속 객체들을 입력 인자로 쓰는 함수라면, 
   그 데이터베이스는 현재 접속한 데이터베이스가 된다.
  </para>

  <para>
   부가적으로 제공하는 통계 관련 함수들은 <xref
   linkend="monitoring-stats-funcs-table"/>에서 소개한다.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>부가 통계 함수들</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>함수이름</entry>
      <entry>리턴 자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       현재 세션을 처리하는 서버 프로세스의 프로세스 ID
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <entry>
       특정 PID를 갖는 백엔드 정보를 담은 레코드를 리턴하거나 인자가 <symbol>NULL</symbol>일 경우에는 시스템에서 활성화된 
       각 백엔드의 레코드를 리턴함. 리턴된 필드는 <structname>pg_stat_activity</structname> 뷰의 부분집합
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_snapshot_timestamp()</function></literal><indexterm><primary>pg_stat_get_snapshot_timestamp</primary></indexterm></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       현재 통계 스냅샷 시간
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 통계치 스냅샷을 버림
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 데이터베이스의 통계치 카운터 전체를 0으로 만듦(슈퍼 유저 권한이 필요함, EXECUTE 권한 부여 가능)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       인자에 따라서 전체 클러스터 통계치 카운터를 0으로 만듦(슈퍼 유저 권한이 필요함, EXECUTE 권한 부여 가능) 
       <literal>pg_stat_reset_shared('bgwriter')</literal>를 호출하면 
       <structname>pg_stat_bgwriter</structname>뷰에 보여진 전체 카운터들을 0으로 만듦
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 데이터베이스의 한 테이블 혹은 인덱스에 대한 통계치를 0으로 만듦(슈퍼 유저 권한이 필요함, EXECUTE 권한 부여 가능)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 데이터베이스의 한 함수에 대한 통계치를 0으로 만듦(슈퍼 유저 권한이 필요함, EXECUTE 권한 부여 가능)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_activity</structname> 뷰에서 사용되는
   <function>pg_stat_get_activity</function> 함수는
   지정한 한 세션의 현재 상태에 대한 모든 정보를 
   레코드 자료형으로 리턴한다. 
   이렇게, 가끔은 뷰보다, 함수를 직접 사용하는 것이 
   보다 유용할 때가 있다.  위에서 소개한 뷰들(<xref
   linkend="monitoring-stats-backend-funcs-table"/>)은 
   함수를 호출하고 그것을 뷰로 보여주기 때문에, 
   뷰를 내용으로 출력 되는 결과는 이미 지난 자료 집합이다
   보다 정확한 현재 상태를 파악 하고자 할 때, 
   이런 함수를 직접 사용하는 방법이 좋다. 
   한 예제를 소개하면,
   다음은, 현재 접속해 있는 세션들의 <acronym>PID</acronym>와
   현재 실행 중인 쿼리 내용을 보는 쿼리다:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
   <title>백엔드 단위 통계 함수들</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>함수이름</entry>
      <entry>리턴 자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>현재 활성화된 백엔드 ID 넘버 집합(1부터 활성화된 백엔드 개수까지)</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>백엔드의 최근 쿼리의 텍스트</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>최근 쿼리가 시작된 시간</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>백엔드에 연결된 클라이언트의 IP 주소</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>클라이언트가 커뮤니케이션에 쓰고 있는 TCP 포트 넘버</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>백엔드가 연결된 데이터베이스의 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>백엔드의 프로세스 ID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>프로세스가 시작된 시간</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>백엔드에 로그인한 사용자의 OID</entry>
     </row>

      <row>
       <entry><literal><function>pg_stat_get_backend_wait_event_type(integer)</function></literal></entry>
       <entry><type>text</type></entry>
        <entry>Wait event type name if backend is currently waiting, otherwise NULL.
        See <xref linkend="wait-event-table"/> for details.
        </entry>
      </row>
      <row>

      <entry><literal><function>pg_stat_get_backend_wait_event(integer)</function></literal></entry>
      <entry><type>text</type></entry>
       <entry>Wait event name if backend is currently waiting, otherwise NULL.
       See <xref linkend="wait-event-table"/> for details.
       </entry>
      </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>현재 트랜잭션이 시작된 시간</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>잠금 보기</title>

  <indexterm zone="monitoring-locks">
   <primary>잠금</primary>
   <secondary>모니터링</secondary>
  </indexterm>

  <para>
   데이터베이스 운영 상태를 모니터링 하는 또 다른 도구는
   <structname>pg_locks</structname> 시스템 뷰다.
   이 테이블은 잠금 관리자가 현재 처리하고 있는 
   여러 잠금들에 대한 정보를 제공한다.
   이 테이블로 다음과 같은 정보들을 살펴 볼 수 있다:

   <itemizedlist>
    <listitem>
     <para>
      모든 잠금 상황을 보거나, 
      특정 데이터베이스에 속한 객체들의 잠금을 보거나,
      특정 객체와 관계된 잠금들, 또는 
      <productname>PostgreSQL</productname> 특정
      세션에 관계된 잠금들을 볼 수 있다.
     </para>
    </listitem>

    <listitem>
     <para>
      현재 데이터베이스에서 어떤 세션이 잠금이 필요한데, 
      다른 세션이 먼저 잠그고 있어 다른 세션들이 대기 상태로 있는지를 
      조사할 수 있다.
     </para>
    </listitem>

    <listitem>
     <para>
      잠금 경합 빈도를 살펴 전반적인 서버 성능을 조사할 수 있다.
      또한 이런 경합이 데이터베이스 사용량 변화에 어떤 
      영향을 주는지도 살펴 볼 수 있다.
     </para>
    </listitem>
   </itemizedlist>
   
   <structname>pg_locks</structname> 뷰에 대한 자세한 설명은
   <xref linkend="view-pg-locks"/>에서 다룬다.
   또한, 잠금에 대한 설명은 <productname>PostgreSQL</productname>
   동시성 제어에 대한 이해가 선행되어야 쉽게 읽을 수 있다.
   이 부분은 <xref linkend="mvcc"/>에서 다룬다.
  </para>
 </sect1>

 <sect1 id="progress-reporting">
  <title>진행 상태 보고</title>

  <para>
   <productname>PostgreSQL</productname>에서는 특정 명령이 실행 되고 있는 동안
   그 작업의 진행 상태를 살펴 볼 수 있다.  이 기능은 현재
   <command>CREATE INDEX</command>,
   <command>VACUUM</command>,
   <command>CLUSTER</command> 명령에 대해서만 사용할 수 있다.  앞으로
   계속 추가 될 것이다.
  </para>

 <sect2 id="create-index-progress-reporting">
  <title>CREATE INDEX Progress Reporting</title>

  <para>
   Whenever <command>CREATE INDEX</command> or <command>REINDEX</command> is running, the
   <structname>pg_stat_progress_create_index</structname> view will contain
   one row for each backend that is currently creating indexes.  The tables
   below describe the information that will be reported and provide information
   about how to interpret it.
  </para>

  <table id="pg-stat-progress-create-index-view" xreflabel="pg_stat_progress_create_index">
   <title><structname>pg_stat_progress_create_index</structname> View</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry>Process ID of backend.</entry>
     </row>
     <row>
      <entry><structfield>datid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the database to which this backend is connected.</entry>
     </row>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Name of the database to which this backend is connected.</entry>
     </row>
     <row>
      <entry><structfield>relid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the table on which the index is being created.</entry>
     </row>
     <row>
      <entry><structfield>index_relid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the index being created or reindexed.  During a
      non-concurrent <command>CREATE INDEX</command>, this is 0.</entry>
     </row>
     <row>
      <entry><structfield>command</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       The command that is running: <literal>CREATE INDEX</literal>,
       <literal>CREATE INDEX CONCURRENTLY</literal>,
       <literal>REINDEX</literal>, or <literal>REINDEX CONCURRENTLY</literal>.
      </entry>
     </row>
     <row>
      <entry><structfield>phase</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
        Current processing phase of index creation.  See <xref linkend='create-index-phases'/>.
      </entry>
     </row>
     <row>
      <entry><structfield>lockers_total</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Total number of lockers to wait for, when applicable.
      </entry>
     </row>
     <row>
      <entry><structfield>lockers_done</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Number of lockers already waited for.
      </entry>
     </row>
     <row>
      <entry><structfield>current_locker_pid</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Process ID of the locker currently being waited for.
      </entry>
     </row>
     <row>
      <entry><structfield>blocks_total</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Total number of blocks to be processed in the current phase.
      </entry>
     </row>
     <row>
      <entry><structfield>blocks_done</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Number of blocks already processed in the current phase.
      </entry>
     </row>
     <row>
      <entry><structfield>tuples_total</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Total number of tuples to be processed in the current phase.
      </entry>
     </row>
     <row>
      <entry><structfield>tuples_done</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
        Number of tuples already processed in the current phase.
      </entry>
     </row>
     <row>
      <entry><structfield>partitions_total</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
       When creating an index on a partitioned table, this column is set to
       the total number of partitions on which the index is to be created.
      </entry>
     </row>
     <row>
      <entry><structfield>partitions_done</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>
       When creating an index on a partitioned table, this column is set to
       the number of partitions on which the index has been completed.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="create-index-phases">
   <title>CREATE INDEX Phases</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       <command>CREATE INDEX</command> or <command>REINDEX</command> is preparing to create the index.  This
       phase is expected to be very brief.
      </entry>
     </row>
     <row>
      <entry><literal>waiting for writers before build</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with write locks that can potentially see the table to finish.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
     <row>
      <entry><literal>building index</literal></entry>
      <entry>
       The index is being built by the access method-specific code.  In this phase,
       access methods that support progress reporting fill in their own progress data,
       and the subphase is indicated in this column.  Typically,
       <structname>blocks_total</structname> and <structname>blocks_done</structname>
       will contain progress data, as well as potentially
       <structname>tuples_total</structname> and <structname>tuples_done</structname>.
      </entry>
     </row>
     <row>
      <entry><literal>waiting for writers before validation</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with write locks that can potentially write into the table to finish.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
     <row>
      <entry><literal>index validation: scanning index</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is scanning the index searching
       for tuples that need to be validated.
       This phase is skipped when not in concurrent mode.
       Columns <structname>blocks_total</structname> (set to the total size of the index)
       and <structname>blocks_done</structname> contain the progress information for this phase.
      </entry>
     </row>
     <row>
      <entry><literal>index validation: sorting tuples</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is sorting the output of the
       index scanning phase.
      </entry>
     </row>
     <row>
      <entry><literal>index validation: scanning table</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is scanning the table
       to validate the index tuples collected in the previous two phases.
       This phase is skipped when not in concurrent mode.
       Columns <structname>blocks_total</structname> (set to the total size of the table)
       and <structname>blocks_done</structname> contain the progress information for this phase.
      </entry>
     </row>
     <row>
      <entry><literal>waiting for old snapshots</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       that can potentially see the table to release their snapshots.  This
       phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
     <row>
      <entry><literal>waiting for readers before marking dead</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with read locks on the table to finish, before marking the old index dead.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
     <row>
      <entry><literal>waiting for readers before dropping</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with read locks on the table to finish, before dropping the old index.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="vacuum-progress-reporting">
  <title>VACUUM 진행 상태 보고</title>

  <para>
   <command>VACUUM</command> 명령이 실행 될 때마다, 
   <structname>pg_stat_progress_vacuum</structname> 뷰에
   하나의 로우 단위로 각 개별 작업에 대한 진행 상태를 
   보관한다. (autovacuum 작업자 프로세스도 포함한다.)
   이 뷰의 각 칼럼에 대한 설명과 그 값을 어떻게 해석할 것인가는
   아래에서 다룬다.
   <command>VACUUM FULL</command> 작업에 대해서는 
   <structname>pg_stat_progress_cluster</structname> 뷰를
   통해 살펴볼 수 있다. 
   <command>VACUUM FULL</command> 작업과 <command>CLUSTER</command> 
   작업은 둘 다 테이블을 새로 만드는 작업이기 때문이다. 
   일반 <command>VACUUM</command> 작업은 테이블 내용을 바꾸는 작업으로
   이것들과 구분된다. <xref linkend='cluster-progress-reporting'/> 참조.
  </para>

  <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
   <title><structname>pg_stat_progress_vacuum</structname> 뷰</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>해당 PID</entry>
    </row>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>해당 프로세스가 접속한 데이터베이스 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>해당 프로세스가 접속한 데이터베이스 이름</entry>
    </row>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>현재 vacuum 작업 중인 테이블 OID</entry>
    </row>
    <row>
     <entry><structfield>phase</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
       현재 진행 상태.  <xref linkend='vacuum-phases'/> 참조.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_total</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       테이블의 힙 블럭 전체 수량.  이 숫자는 테이블 탐색 작업
       시작 때 결정된다.  <command>VACUUM</command> 작업 진행 과정 
       속에서 추가 되거나 삭제되는 블럭에 대해서는 고려하지 않는다.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_scanned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       탐색한 힙 블럭 수.  탐색 최적화를 위해서 
       <link linkend="storage-vm">visibility map</link>을 이용하기 때문에, 
       vacuum 대상 블럭인지 조사하는 작업을 몇몇 블럭에서 하지 않을
       수도 있다.  이렇게 건너뛴 블럭도 이 수에 모두 포함한다.  이렇게
       해서 이 수가 <structfield>heap_blks_total</structfield> 수와 같으면, 
       vacuum 작업이 완료된 것이다.  이 수는 <literal>scanning heap</literal>
       상태에서만 증가한다.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_vacuumed</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       vacuum 작업을 한 힙 블럭 수.  테이블에 인덱스가 없다면, 
       이 수는 <literal>vacuuming heap</literal> 상태에서만 증가한다.  더 이상
       사용하지 않는 자료(dead tuple)가 없는 블럭에 대해서는 건너
       뛰기 때문에 이 수는 한꺼번에 많은 수가 증가 할 수도 있다.
     </entry>
    </row>
    <row>
     <entry><structfield>index_vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       vacuum 작업이 완료된 인덱스 수
     </entry>
    </row>
    <row>
     <entry><structfield>max_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
      인덱스 vacuum 작업을 수행해야 할 경우 고려해야할 dead tuple 수
      이 수는 <xref linkend="guc-maintenance-work-mem"/> 환경 설정값에 기초한다.
     </entry>
    </row>
    <row>
     <entry><structfield>num_dead_tuples</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       인덱스 vacuum 작업으로 처리한 dead tuple 수
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <table id="vacuum-phases">
   <title>VACUUM 상태</title>
   <tgroup cols="2">
    <thead>
    <row>
      <entry>상태</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       <command>VACUUM</command> 탐색 작업 초기화 중.
       이 상태는 순십간에 지나갈 것이다.
     </entry>
    </row>
    <row>
     <entry><literal>scanning heap</literal></entry>
     <entry>
       <command>VACUUM</command> 작업이 테이블 탐색 중.  각 블럭을 청소하고, 
       필요하다면, 블럭을 버리는 작업, 또는 자료 영구 보관 작업까지
       진행한다.  한 블럭 작업이 마무리 할 때마다
       <structfield>heap_blks_scanned</structfield> 칼럼 값이 증가된다.
     </entry>
    </row>
    <row>
     <entry><literal>vacuuming indexes</literal></entry>
     <entry>
       <command>VACUUM</command> 작업이 인덱스 청소 중.
       테이블에 인덱스가 있다면, 이 상태는 테이블 탐색이 끝난 뒤
       한 번 나타난다.
       <xref linkend="guc-maintenance-work-mem"/> 설정값이 충분히 크지 않아
       모든 dead tuple을 한 번에 처리할 수 없다면, 
       한 번의 vacuum 작업에서 여러번 나타날 수도 있다.
     </entry>
    </row>
    <row>
     <entry><literal>vacuuming heap</literal></entry>
     <entry>
       <command>VACUUM</command> 작업이 테이블 힙을 청소 중.  청소 작업은
       힙 탐색 작업과 다르며, 인덱스 청소 작업 뒤에 한 번 나타난다.
       만일 <structfield>heap_blks_scanned</structfield> 수가 
       <structfield>heap_blks_total</structfield> 수보다 적다면, 
       이 상태 다음에 힙 탐색 상태가 되며, 
       그렇지 않다면, 인덱스 정리 상태로 넘어간다.
     </entry>
    </row>
    <row>
     <entry><literal>cleaning up indexes</literal></entry>
     <entry>
       <command>VACUUM</command> 작업에서 인덱스들을 정리 하는 중.  이 상태는
       힙 탐색이 끝났고, 모든 인덱스와 힙의 정리 작업도 끝난 다음에 나타난다.
     </entry>
    </row>
    <row>
     <entry><literal>truncating heap</literal></entry>
     <entry>
       <command>VACUUM</command> 작업에서 해당 테이블 끝 부분에 있는 비어있는 블럭을
       OS로 반환하는 작업 상태.  이 상태는 인덱스 정리 작업 다음에 나타난다.
     </entry>
    </row>
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       <command>VACUUM</command> 최종 마무리 단계.  이 상태에서는
       <command>VACUUM</command> 작업은 여유 공간 지도 파일을 정리하고, 
       <literal>pg_class</literal>의 통계 정보를 갱신하고, 통계 수집기로
       통계 정보를 보낸다.   이 상태가 끝나면, <command>VACUUM</command> 
       작업은 끝난다.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="cluster-progress-reporting">
  <title>CLUSTER Progress Reporting</title>

  <para>
   Whenever <command>CLUSTER</command> or <command>VACUUM FULL</command> is
   running, the <structname>pg_stat_progress_cluster</structname> view will
   contain a row for each backend that is currently running either command.
   The tables below describe the information that will be reported and
   provide information about how to interpret it.
  </para>

  <table id="pg-stat-progress-cluster-view" xreflabel="pg_stat_progress_cluster">
   <title><structname>pg_stat_progress_cluster</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of backend.</entry>
    </row>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the database to which this backend is connected.</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the database to which this backend is connected.</entry>
    </row>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the table being clustered.</entry>
    </row>
    <row>
     <entry><structfield>command</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
      The command that is running. Either <literal>CLUSTER</literal> or <literal>VACUUM FULL</literal>.
     </entry>
    </row>
    <row>
     <entry><structfield>phase</structfield></entry>
     <entry><type>text</type></entry>
     <entry>
       Current processing phase. See <xref linkend='cluster-phases' />.
     </entry>
    </row>
    <row>
     <entry><structfield>cluster_index_relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>
       If the table is being scanned using an index, this is the OID of the
       index being used; otherwise, it is zero.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_tuples_scanned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of heap tuples scanned.
       This counter only advances when the phase is
       <literal>seq scanning heap</literal>,
       <literal>index scanning heap</literal>
       or <literal>writing new heap</literal>.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_tuples_written</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of heap tuples written.
       This counter only advances when the phase is
       <literal>seq scanning heap</literal>,
       <literal>index scanning heap</literal>
       or <literal>writing new heap</literal>.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_total</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Total number of heap blocks in the table.  This number is reported
       as of the beginning of <literal>seq scanning heap</literal>.
     </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_scanned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of heap blocks scanned.  This counter only advances when the
       phase is <literal>seq scanning heap</literal>.
     </entry>
    </row>
    <row>
     <entry><structfield>index_rebuild_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>
       Number of indexes rebuilt.  This counter only advances when the phase
       is <literal>rebuilding index</literal>.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <table id="cluster-phases">
   <title>CLUSTER and VACUUM FULL Phases</title>
   <tgroup cols="2">
    <thead>
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       The command is preparing to begin scanning the heap.  This phase is
       expected to be very brief.
     </entry>
    </row>
    <row>
     <entry><literal>seq scanning heap</literal></entry>
     <entry>
       The command is currently scanning the table using a sequential scan.
     </entry>
    </row>
    <row>
     <entry><literal>index scanning heap</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently scanning the table using an index scan.
     </entry>
    </row>
    <row>
     <entry><literal>sorting tuples</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently sorting tuples.
     </entry>
    </row>
    <row>
     <entry><literal>writing new heap</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently writing the new heap.
     </entry>
    </row>
    <row>
     <entry><literal>swapping relation files</literal></entry>
     <entry>
       The command is currently swapping newly-built files into place.
     </entry>
    </row>
    <row>
     <entry><literal>rebuilding index</literal></entry>
     <entry>
       The command is currently rebuilding an index.
     </entry>
    </row>
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       The command is performing final cleanup.  When this phase is
       completed, <command>CLUSTER</command>
       or <command>VACUUM FULL</command> will end.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>


 <sect1 id="dynamic-trace">
  <title>Dynamic Tracing</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>은 데이터 서버의 dynamic tracing을 지원하는 기능을 제공한다. 코드 특정 지점에서 호출된 외부 유틸리티로 dynamic tracing을 한다.
  </para>

  <para>
   프로브probe 혹은 trace point는 소스 코드에 이미 삽입돼 있는 경우가 많다. 프로브는 데이터베이스 개발자와 관리자들이 사용하도록 되어 있다. 기본적으로 프로브는 
   <productname>PostgreSQL</productname>로 컴파일 되지 않는다. 사용자는 설정 스크립트에 프로브를 컴파일 하도록 명시해야 한다. 
  </para>

  <para>
   현재 
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   유틸리티가 지원되고 있는데, 이 다큐멘테이션이 작성되는 시점에는 Solaris, macOS, FreeBSD, NetBSD, Oracle Linux에서 사용 가능하다. 리눅스의 
   <ulink url="https://sourceware.org/systemtap/">SystemTap</ulink> 프로젝트로 DTrace와 비슷한 유틸리티를 사용할 수 있다. 이 외의 dynamic tracing 유틸리티는 <filename>src/include/utils/probes.h</filename>에 있는 매크로 정의를 변경하여 사용할 수 있다.
  </para>

  <sect2 id="compiling-for-trace">
   <title>Dynamic Tracing을 위한 컴파일링</title>

  <para>
   기본적으로 프로브는 사용하지 않으므로, 설정 스크립트에 <productname>PostgreSQL</productname>이 프로브를 사용하도록 명시해 주어야 한다. DTrace를 활성화 하기 위해서 <option>--enable-dtrace</option>를 명시해 주어야 한다(자세한 정보는 <xref
   linkend="install-procedure"/>을 참조). 
  </para>
  </sect2>

  <sect2 id="trace-points">
   <title>Built-in Probes</title>

  <para>
   대부분의 표준 프로브는 <xref linkend="dtrace-probe-point-table"/>처럼 소스 코드에서 제공된다.
   <xref linkend="typedefs-table"/>에서 프로브에 사용된 타입을 볼 수 있다. 프로브가 많을수록 <productname>PostgreSQL</productname>의 가관측성observability을 높일 수 있다.
  </para>

 <table id="dtrace-probe-point-table">
  <title>Built-in DTrace Probes</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>Description</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction ID.</entry>
    </row>
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction ID.</entry>
    </row>
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction ID.</entry>
    </row>
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is started.</entry>
    </row>
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is complete.</entry>
    </row>
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is started.</entry>
    </row>
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is complete.</entry>
    </row>
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
      arg0 is the new status string.</entry>
    </row>
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of WAL files added,
      removed and recycled respectively.</entry>
    </row>
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for <literal>clog-checkpoint-start</literal>.</entry>
    </row>
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>subtrans-checkpoint-start</literal>.</entry>
    </row>
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>multixact-checkpoint-start</literal>.</entry>
    </row>
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
    </row>
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
    </row>
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      <literal>buffer-sync-start</literal>); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
    </row>
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
    </row>
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
    </row>
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
    </row>
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
    </row>
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
    </row>
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
    </row>
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for <literal>buffer-flush-start</literal>.</entry>
    </row>
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"/> is too
      small or the background writer control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for <literal>buffer-write-dirty-start</literal>.</entry>
    </row>
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"/> is too small.)</entry>
    </row>
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
    </row>
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
    </row>
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
    </row>
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually read, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually written, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.
      arg5 indicates serial when <literal>0</literal>, parallel worker when
      <literal>1</literal>, or parallel leader when <literal>2</literal>.</entry>
    </row>
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
    </row>
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's tranche.</entry>
    </row>
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
    </row>
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for <literal>lock-wait-start</literal>.</entry>
    </row>
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <title>Defined Types Used in Probe Parameters</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Type</entry>
     <entry>Definition</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry><type>LocalTransactionId</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
    <row>
     <entry><type>LWLockMode</type></entry>
     <entry><type>int</type></entry>
    </row>
    <row>
     <entry><type>LOCKMODE</type></entry>
     <entry><type>int</type></entry>
    </row>
    <row>
     <entry><type>BlockNumber</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
    <row>
     <entry><type>Oid</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
    <row>
     <entry><type>ForkNumber</type></entry>
     <entry><type>int</type></entry>
    </row>
    <row>
     <entry><type>bool</type></entry>
     <entry><type>unsigned char</type></entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
   <title>Using Probes</title>

  <para>
   The example below shows a DTrace script for analyzing transaction
   counts in the system, as an alternative to snapshotting
   <structname>pg_stat_database</structname> before and after a performance test:
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   When executed, the example D script gives output such as:
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
   <para>
    SystemTap uses a different notation for trace scripts than DTrace does,
    even though the underlying trace points are compatible.  One point worth
    noting is that at this writing, SystemTap scripts must reference probe
    names using double underscores in place of hyphens.  This is expected to
    be fixed in future SystemTap releases.
   </para>
  </note>

  <para>
   You should remember that DTrace scripts need to be carefully written and
   debugged, otherwise the trace information collected might
   be meaningless. In most cases where problems are found it is the
   instrumentation that is at fault, not the underlying system. When
   discussing information found using dynamic tracing, be sure to enclose
   the script used to allow that too to be checked and discussed.
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>Defining New Probes</title>

  <para>
   New probes can be defined within the code wherever the developer
   desires, though this will require a recompilation. Below are the steps
   for inserting new probes:
  </para>

  <procedure>
   <step>
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
   </step>

   <step>
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</filename>
    </para>
   </step>

   <step>
    <para>
     Include <filename>pg_trace.h</filename> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</literal> probe macros at the desired locations
     in the source code
    </para>
   </step>

   <step>
    <para>
     Recompile and verify that the new probes are available
    </para>
   </step>
  </procedure>

  <formalpara>
   <title>Example:</title>
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
  </formalpara>

  <procedure>
   <step>
    <para>
     Decide that the probe will be named <literal>transaction-start</literal> and
     requires a parameter of type <type>LocalTransactionId</type>
    </para>
   </step>

   <step>
    <para>
     Add the probe definition to <filename>src/backend/utils/probes.d</filename>:
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</literal> is the name to document for
     users.
    </para>
   </step>

   <step>
    <para>
     At compile time, <literal>transaction__start</literal> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</filename>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   There are a few things to be careful about when adding trace macros
   to the C code:

   <itemizedlist>
    <listitem>
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
    </listitem>


    <listitem>
     <para>
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>--enable-dtrace</option>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</emphasis>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Each trace macro has a corresponding <literal>ENABLED</literal> macro.
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
