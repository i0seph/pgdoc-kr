<!--
doc/src/sgml/ref/create_statistics.sgml
PostgreSQL documentation
-->

<refentry id="sql-createstatistics">
 <indexterm zone="sql-createstatistics">
  <primary>CREATE STATISTICS</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE STATISTICS</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE STATISTICS</refname>
  <refpurpose>새 확장된 통계 정보 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE STATISTICS [ IF NOT EXISTS ] <replaceable class="parameter">통계이름</replaceable>
    [ ( <replaceable class="parameter">통계종류</replaceable> [, ... ] ) ]
    ON <replaceable class="parameter">칼럼이름</replaceable>, <replaceable class="parameter">칼럼이름</replaceable> [, ...]
    FROM <replaceable class="parameter">테이블이름</replaceable>
</synopsis>

 </refsynopsisdiv>

 <refsect1 id="sql-createstatistics-description">
  <title>설명</title>

  <para>
   <command>CREATE STATISTICS</command> 명령은
   지정한 테이블, 외부 테이블, 구체화한 뷰를 대상으로
   새로운 통계 정보를 만든다.  해당 통계 정보의 소유주는
   이 명령을 실행하는 사용자가 된다. 
  </para>

  <para>
   통계 정보 이름에 스키마 이름을 포함하면(예,
   <literal>CREATE STATISTICS
   myschema.mystat ...</literal>) 해당 스키마 안에 만든다.
   스키마 이름이 없으면, 현재 스키마 안에 만든다.
   통계 정보 이름은 같은 스키마 내에서는 유일해야 한다.
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

  <variablelist>

   <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
     <para>
      이미 같은 이름의 통계 정보가 있으면 알림 메시지만 보이고, 
      무시한다.  같은 이름이 있는지만 확인하기 때문에, 
      정확히 같은 통계인지는 확인하지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">통계이름</replaceable></term>
    <listitem>
     <para>
      만들 사용자 정의 통계 정보 이름(스키마 이름 포함).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">통계종류</replaceable></term>
    <listitem>
     <para>
      이 통계 정보 개체의 통계 종류.
      현재, n-distinct 통계용 <literal>ndistinct</literal>,
      기능적 의존성 통계용 <literal>dependencies</literal>,
      최빈값 목록인 <literal>mcv</literal>
      세 종류를 지원한다.
      이 옵션을 생략하면, 만들어지는 통계 정보에, 
      세 종류 모든 통계를 보관한다.
      <xref linkend="planner-stats-extended"/>,
      <xref linkend="multivariate-statistics-examples"/>에서 이 부분에 
      대한 자세한 내용을 다룬다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">칼럼이름</replaceable></term>
    <listitem>
     <para>
      통계 정보를 수집할 칼럼 이름.  최소 두 개 이상 지정해야 한다. 
      순서는 상관 없다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">테이블이름</replaceable></term>
    <listitem>
     <para>
      통계 정보를 수집할 해당 테이블 이름(스키마 이름 포함).
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>참고</title>

  <para>
   사용자 정의 통계를 만드려면, 해당 테이블의 소유주여야 한다.
   한 번 만들어진 통계는 해당 테이블에 종속되어 
   소유주는 테이블의 소유주에 따라 자동으로 바뀐다.
  </para>
 </refsect1>

 <refsect1 id="sql-createstatistics-examples">
  <title>예제</title>

  <para>
   <structname>t1</structname> 테이블에는 두 개의 칼럼이 있는데, 
   이 칼럼은 기능적으로 서로 의존적이다.  아래의 경우는 
   첫번째 칼럼이 100단위, 두번째 칼럼이 500단위다.

<programlisting>
CREATE TABLE t1 (
    a   int,
    b   int
);

INSERT INTO t1 SELECT i/100, i/500
                 FROM generate_series(1,1000000) s(i);

ANALYZE t1;

-- 실행 계획은 실 자료보다 적게 해당 자료를 예측한다.
EXPLAIN ANALYZE SELECT * FROM t1 WHERE (a = 1) AND (b = 0);

CREATE STATISTICS s1 (dependencies) ON a, b FROM t1;

ANALYZE t1;

-- 보다 정확하게 예측한다.
EXPLAIN ANALYZE SELECT * FROM t1 WHERE (a = 1) AND (b = 0);
</programlisting>

   기능적 의존 관계가 있는 통계 정보를 사용하지 않으면, 
   실행 계획기는,
   <literal>WHERE</literal> 조건이 두 개인 경우, 각 예측 값의 AND 연산를 
   해서 실 자료보다 훨씬 적은 예측값을 사용하게 된다.
   이런 사용자 정의 통계 정보를 만들면,
   <literal>WHERE</literal> 조건절에 다중 칼럼을 사용하는 경우, 
   보다 정확한 예측을 할 수 있도록 한다.
  </para>

  <para>
   Create table <structname>t2</structname> with two perfectly correlated columns
   (containing identical data), and a MCV list on those columns:

<programlisting>
CREATE TABLE t2 (
    a   int,
    b   int
);

INSERT INTO t2 SELECT mod(i,100), mod(i,100)
                 FROM generate_series(1,1000000) s(i);

CREATE STATISTICS s2 (mcv) ON a, b FROM t2;

ANALYZE t2;

-- valid combination (found in MCV)
EXPLAIN ANALYZE SELECT * FROM t2 WHERE (a = 1) AND (b = 1);

-- invalid combination (not found in MCV)
EXPLAIN ANALYZE SELECT * FROM t2 WHERE (a = 1) AND (b = 2);
</programlisting>

   The MCV list gives the planner more detailed information about the
   specific values that commonly appear in the table, as well as an upper
   bound on the selectivities of combinations of values that do not appear
   in the table, allowing it to generate better estimates in both cases.
  </para>

 </refsect1>

 <refsect1>
  <title>호환성</title>

  <para>
   <command>CREATE STATISTICS</command> 명령은 SQL 표준이 아니다.
  </para>
 </refsect1>

 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterstatistics"/></member>
   <member><xref linkend="sql-dropstatistics"/></member>
  </simplelist>
 </refsect1>
</refentry>
