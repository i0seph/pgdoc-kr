<!--
doc/src/sgml/ref/create_foreign_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-createforeigntable">
 <indexterm zone="sql-createforeigntable">
  <primary>CREATE FOREIGN TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE FOREIGN TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FOREIGN TABLE</refname>
  <refpurpose>새 외부 테이블 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE FOREIGN TABLE [ IF NOT EXISTS ] <replaceable class="parameter">테이블이름</replaceable> ( [
  { <replaceable class="parameter">칼럼이름</replaceable> <replaceable class="parameter">자료형</replaceable> [ OPTIONS ( <replaceable class="parameter">옵션</replaceable> '<replaceable class="parameter">값</replaceable>' [, ... ] ) ] [ COLLATE <replaceable>문자정렬규칙</replaceable> ] [ <replaceable class="parameter">칼럼제약조건</replaceable> [ ... ] ]
    | <replaceable>테이블제약조건</replaceable> }
    [, ... ]
] )
[ INHERITS ( <replaceable>상위테이블</replaceable> [, ... ] ) ]
  SERVER <replaceable class="parameter">서버이름</replaceable>
[ OPTIONS ( <replaceable class="parameter">옵션</replaceable> '<replaceable class="parameter">값</replaceable>' [, ... ] ) ]

CREATE FOREIGN TABLE [ IF NOT EXISTS ] <replaceable class="parameter">테이블이름</replaceable>
  PARTITION OF <replaceable class="parameter">상위테이블</replaceable> [ (
  { <replaceable class="parameter">칼럼이름</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">칼럼제약조건</replaceable> [ ... ] ]
    | <replaceable>테이블제약조건</replaceable> }
    [, ... ]
) ] <replaceable class="parameter">파티션_범위_정의</replaceable>
  SERVER <replaceable class="parameter">서버이름</replaceable>
[ OPTIONS ( <replaceable class="parameter">옵션</replaceable> '<replaceable class="parameter">값</replaceable>' [, ... ] ) ]

<phrase><replaceable class="parameter">칼럼제약조건</replaceable> 자리에는:</phrase>

[ CONSTRAINT <replaceable class="parameter">제약조건이름</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">표현식</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>기본값표현식</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED }

<phrase><replaceable class="parameter">테이블제약조건</replaceable> 자리에는:</phrase>

[ CONSTRAINT <replaceable class="parameter">제약조건이름</replaceable> ]
CHECK ( <replaceable class="parameter">표현식</replaceable> ) [ NO INHERIT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createforeigntable-description">
  <title>설명</title>

  <para>
   <command>CREATE FOREIGN TABLE</command> 명령은 현재 데이터베이스에
   새 외부 테이블을 만든다.  이 명령을 실행하는 사용자가 해당 테이블의
   소유주가 된다.
  </para>

  <para>
   스키마 이름을 포함하면 (예, <literal>CREATE FOREIGN TABLE
   myschema.mytable ...</literal>) 해당 스키마 안에 만든다.
   지정하지 않으면 현재 스키마 안에 만든다.
   이 외부 테이블 이름은 해당 스키마 안에서 
   외부 테이블, 테이블, 시퀀스, 인덱스, 뷰, 구체화한 뷰 이름들 가운데 
   유일해야 한다.
  </para>

  <para>
   <command>CREATE FOREIGN TABLE</command> 명령은 일반 테이블을 만드는
   명령과 마찬가지로, 해당 테이블 이름과 동일한 복합 자료형을 
   내부적으로 함께 만든다.  이 때문에, 
   만들고자 하는 테이블의 이름과 동일한 자료형이 해당 스키마안에
   이미 있어도 안된다.
  </para>

  <para>
   <literal>PARTITION OF</literal> 옵션을 사용하면, 
   지정한 <literal>상위테이블</literal>에 속한, 지정한 
   파티션 범위의 하위 파티션 테이블을 만든다.
   (현재, 외부 테이블을 상위 파티션 테이블로는 만들 수 없다. - 옮긴이)
  </para>

  <para>
   외부 테이블을 만들 때는, 해당 외부 서버에 대해
   <literal>USAGE</literal> 권한이 있어야 하며,
   칼럼 자료형으로 지정한 자료형에 대해서도
   <literal>USAGE</literal> 권한이 있어야 한다.
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

  <variablelist>

   <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
     <para>
      지정한 이름의 개체가 이미 있어도 오류로 처리하지 않고, 알림
      메시지만 보여준다.  이미 있는 그 개체가 만들고자 하는 개체와
      완벽하게 같은 것인지를 확인하지는 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">테이블이름</replaceable></term>
    <listitem>
     <para>
      만들 테이블 이름(스키마 이름 포함).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">칼럼이름</replaceable></term>
    <listitem>
     <para>
      테이블을 구성하는 칼럼 이름.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">자료형</replaceable></term>
    <listitem>
     <para>
      해당 칼럼 자료형 이름.  배열형도 가능.
      <productname>PostgreSQL</productname>에서 사용 가능한 자료형에
      대해서는 <xref linkend="datatype"/>에서 다룬다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLLATE <replaceable>문자정렬규칙</replaceable></literal></term>
    <listitem>
     <para>
      문자 자료형인 경우 <literal>COLLATE</literal>  옵션을 사용하면
      해당 정렬 규칙을 사용한다.
      지정하지 않으면, 해당 자료형의 기본 정렬 규칙을 사용한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>상위테이블</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      <literal>INHERITS</literal> 옵션은 지정한 상위 테이블의 하위 테이블로 이 외부
      테이블을 만든다. 이 경우 상위 테이블의 칼럼 정의는 모두 상속 받는다.
      상위 테이블은 일반 테이블 수도 있고, 또 다른 외부 테이블일 수 있다.
      이 구문 사용법에 대한 자세한 설명은
      <xref linkend="sql-createtable"/> 명령 설명서에 있다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PARTITION OF <replaceable>parent_table</replaceable> FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable></literal></term>
    <listitem>
     <para>
      This form can be used to create the foreign table as partition of
      the given parent table with specified partition bound values.
      See the similar form of
      <xref linkend="sql-createtable"/> for more details.
      Note that it is currently not allowed to create the foreign table as a
      partition of the parent table if there are <literal>UNIQUE</literal>
      indexes on the parent table.  (See also
      <link linkend="sql-altertable"><command>ALTER TABLE ATTACH PARTITION</command></link>.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="parameter">제약조건</replaceable></literal></term>
    <listitem>
     <para>
      칼럼 또는 테이블 제약조건 지정.
      자료 입력, 변경 작업 시 이 제약 조건을 위반하면, 
      <literal>칼럼 값은 양수여야 함</literal> 같은 오류 메시지안에, 
      이 제약 조건 이름을 함께 보여준다. 그래서, 응용 프로그램에서 
      보다 친절한 오류 메시지를 볼 수 있게 한다.
      (제약 조건 이름 가운데 공백 문자를 사용한다는 큰 따옴표로 둘러 싸야한다.)
      제약 조건 이름을 사용하지 않고 그냥 제약 조건을 만들면, 
      시스템에서 자동으로 그 이름을 만든다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</literal></term>
    <listitem>
     <para>
      칼럼 값으로 null 값을 허용하지 않음.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      칼럼 값으로 null 값 허용. 이것은 기본값이다.
     </para>

     <para>
      이 옵션은 비표준 SQL 데이터베이스와 호환하기 위해 
      제공할 뿐이다.  일반적으로 사용하지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="parameter">표현식</replaceable> ) [ NO INHERIT ] </literal></term>
    <listitem>
     <para>
      <literal>CHECK</literal> 옵션은 해당 자료가 유효한지 검사하는 검사식을 
      지정한다. 그 검사식 결과는 불리언 값이어야 하며, 
      그 값이 TRUE 또는 UNKNOWN 이면 유효하다고 간주하고, 
      FALSE 면 이 제약 조건 위반으로 간주한다. 여기서 지정하는 
      검사식은 해당 외부 테이블의 모든 자료에 적용 된다.
      칼럼 제약 조건으로 사용하면, 해당 칼럼 값에 대해서만 검사하며,
      테이블 제약 조건이면, 여러 칼럼을 함께 검사할 수 있다.
     </para>

     <para>
      현재, <literal>CHECK</literal> 표현식으로
      서브 쿼리를 쓸 수 없으며, 해당 로우의 칼럼 외 다른 변수들도
      사용할 수 없다.  테이블 숨은 칼럼 가운데서는 
      <literal>tableoid</literal> 만 사용할 수 있다.
     </para>

     <para>
      <literal>NO INHERIT</literal> 옵션을 사용하면, 해당 테이블의
      하위 테이블에 대해서는 이 제약 조건 검사를 하지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>기본값표현식</replaceable></literal></term>
    <listitem>
     <para>
      <literal>DEFAULT</literal> 옵션은 
      해당 칼럼에 임의 값을 지정하지 않을 경우 그 값으로 사용할 
      계산식이나, 값을 지정한다. 계산식은 어떤 형태로도 괜찮다.
      (단 서브 쿼리나, 다른 칼럼을 참조하는 것은 허용 하지 않음)
      이 기본값은 해당 칼럼의 자료형에서 수용할 수 값이여야 한다.
     </para>

     <para>
      이 표현식은 해당 칼럼에 대한 값을 지정하지 않았을 때 사용된다.
      이 기본값이 없으면, 기본값으로 null 값을 사용한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED</literal><indexterm><primary>generated column</primary></indexterm></term>
    <listitem>
     <para>
      This clause creates the column as a <firstterm>generated
      column</firstterm>.  The column cannot be written to, and when read the
      result of the specified expression will be returned.
     </para>

     <para>
      The keyword <literal>STORED</literal> is required to signify that the
      column will be computed on write.  (The computed value will be presented
      to the foreign-data wrapper for storage and must be returned on
      reading.)
     </para>

     <para>
      The generation expression can refer to other columns in the table, but
      not other generated columns.  Any functions and operators used must be
      immutable.  References to other tables are not allowed.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">서버이름</replaceable></term>
    <listitem>
     <para>
      외부 테이블에서 사용할 외부 서버 이름. 이 외부 서버는 해당 데이터베이스에
      미리 지정되어 있어야 한다.
      외부 서버에 대한 자세한 설명은 <xref
      linkend="sql-createserver"/> 명령 설명서에 있다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OPTIONS ( <replaceable class="parameter">옵션</replaceable> '<replaceable class="parameter">값</replaceable>' [, ...] )</literal></term>
    <listitem>
     <para>
      해당 테이블이나, 그것의 소속 칼럼들과 관계된 옵션을 지정한다.
      사용할 수 있는 옵션 이름과 그 값은 
      해당 외부 자료 싸개의 유효성 검사 함수가 요효성을 검사한다.
      같은 이름의 옵션은 한 번만 사용해야 한다. (
      테이블 옵션과 칼럼 옵션의 이름이 같은 경우에는 허용한다.)
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

 </refsect1>

 <refsect1>
  <title>참고</title>

   <para>
    외부 테이블에 지정한 제약 조건(<literal>CHECK</literal>, 
    <literal>NOT NULL</literal> 같은 것)은 그 테이블에 이미 있는 자료에 
    대해서는 관여하지 않는다. 또한 이 외부 테이블을 이용해서
    자료를 조작하지 않고, 해당 서버에 있는 실 테이블을 직접 
    조작해도(insert, update)도 이것 제약 조건 검사를 할 방법이 없다.
    그래서 대부분의 외부 자료 싸개는 이 부분에 대해서 무시한다.
    즉, 해당 자료의 엄격한 유효성을 보장하려면, 해당 자료가 
    실제로 저장되는 그 테이블을 대상으로 제약 조건을 지정해야 한다.
   </para>

   <para>
    어떤 외부 자료 싸개가 있는데,
    그 핸들러 함수로만 해당 자료를 조작 가능하다면, 
    외부 테이블에서 지정하는 제약 조건들은 제 역할을 할 수 있다.
    하지만, 해당 외부 자료 싸개 설명서에 이렇게 설명되어 있지 않다면, 
    지정한 제약 조건들이 잘 작동할 것이라고 가정해서는 안된다.
   </para>

   <para>
    <productname>PostgreSQL</productname>에서는 외부 테이블에 있는 
    제약 조건이 엄격하게 작동하지 않음에도 불구하고, 
    이 정책은 쿼리 최적화 시각에서는 바르게 작동하는 것으로 간주한다.
    제약 조건에 만족하지 않는 자료가 외부 테이블을 통해 
    볼 수 있다면, 그 테이블을 사용하는 쿼리 결과가 엉뚱해 질 수 있다.
    이렇게 제약 조건 정의가 잘못 되어 결과가 바뀌는 문제는
    사용자 책임이다.
   </para>

   <para>
    Similar considerations apply to generated columns.  Stored generated
    columns are computed on insert or update on the local
    <productname>PostgreSQL</productname> server and handed to the
    foreign-data wrapper for writing out to the foreign data store, but it is
    not enforced that a query of the foreign table returns values for stored
    generated columns that are consistent with the generation expression.
    Again, this might result in incorrect query results.
   </para>

   <para>
    While rows can be moved from local partitions to a foreign-table partition
    (provided the foreign data wrapper supports tuple routing), they cannot be
    moved from a foreign-table partition to another partition.
   </para>
 </refsect1>

 <refsect1 id="sql-createforeigntable-examples">
  <title>예제</title>

  <para>
   <structname>film_server</structname> 서버를 통해 접근하는
   <structname>films</structname> 테이블을 만들 때:

<programlisting>
CREATE FOREIGN TABLE films (
    code        char(5) NOT NULL,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
)
SERVER film_server;
</programlisting></para>

  <para>
   범위 파티션인 <structname>measurement</structname> 테이블의 하위 테이블로
   외부 테이블을 지정하는 경우:

<programlisting>
CREATE FOREIGN TABLE measurement_y2016m07
    PARTITION OF measurement FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')
    SERVER server_07;
</programlisting></para>

 </refsect1>

 <refsect1 id="sql-createforeigntable-compatibility">
  <title>호환성</title>

  <para>
   <command>CREATE FOREIGN TABLE</command> 구문은
   <acronym>SQL</acronym> 표준을 준수한다; 한편,
   <link linkend="sql-createtable"><command>CREATE TABLE</command></link> 명령과
   같이 <literal>NULL</literal> 제약조건 허용, 아무 칼럼도 없는
   빈 외부 테이블 정의가 가능하다.
   칼럼의 기본값을 정의하는 방법도 <productname>PostgreSQL</productname> 확장 기능이다.
   테이블 상속 기능도 <productname>PostgreSQL</productname> 확장 기능이다.
  </para>

 </refsect1>

 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterforeigntable"/></member>
   <member><xref linkend="sql-dropforeigntable"/></member>
   <member><xref linkend="sql-createtable"/></member>
   <member><xref linkend="sql-createserver"/></member>
   <member><xref linkend="sql-importforeignschema"/></member>
  </simplelist>
 </refsect1>
</refentry>
