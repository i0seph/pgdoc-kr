<!--
doc/src/sgml/ref/create_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-createtable">
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>새 테이블 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable> ( [
  { <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable>
    OF <replaceable class="parameter">type_name</replaceable> [ (
  { <replaceable class="parameter">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable>
    PARTITION OF <replaceable class="parameter">parent_table</replaceable> [ (
  { <replaceable class="parameter">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ] { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">column_constraint</replaceable> 자리에는:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">table_constraint</replaceable> 자리에는:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">like_option</replaceable> 자리에는:</phrase>

{ INCLUDING | EXCLUDING } { COMMENTS | CONSTRAINTS | DEFAULTS | GENERATED | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<phrase><replaceable class="parameter">partition_bound_spec</replaceable> 자리에는:</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase><literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, <literal>EXCLUDE</literal> 제약조건에서 사용하는 <replaceable class="parameter">index_parameters</replaceable> 자리에는:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><literal>EXCLUDE</literal> 제약조건에서 사용하는 <replaceable class="parameter">exclude_element</replaceable> 자리에는:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>

 </refsynopsisdiv>

 <refsect1 id="sql-createtable-description">
  <title>설명</title>

  <para>
   <command>CREATE TABLE</command>은 현재 데이터베이스에 신규 빈 테이블을 생성합니다.
   해당 테이블은 명령을 수행한 사용자의 소유가 됩니다.
  </para>

  <para>
   Schema명을 지정하면(예를 들면, <literal>CREATE TABLE
   myschema.mytable ...</literal>), 지정한 schema에 해당 테이블이 생성됩니다.
   그렇지 않으면 현재 schema에 생성됩니다. 임시 테이블은 특별한 schema에 위치하기 때문에,
   임시 테이블을 생성할 때엔 schema명을 지정할 수 없습니다.
   해당 테이블 명은 동일 schema 내의 다른 테이블, 시퀀스, 인덱스, 뷰 및 외래 테이블의 이름과 구분되어야 합니다.
  </para>

  <para>
   <command>CREATE TABLE</command>은 또한 테이블의 한 행에 대응되는 복합 자료형을 표현하는
   데이터 자료형을 자동으로 생성합니다.
   때문에, 테이블은 같은 schema 내에 존재하는 데이터 자료형 명과 같은 이름을 가질 수 없습니다.
  </para>

  <para>
   선택적 constraint 절은, 신규 또는 업데이트되는 행이 삽입 또는 업데이트 동작을 성공적으로 수행하기 위해 
   충족해야 하는, 제약(조건)을 지정합니다.
   제약조건은 다양한 방식으로 테이블의 유효값 집합을 정의하는 데 도움을 주는 SQL 객체입니다.
  </para>

  <para>
   제약조건을 정의하는 두 가지 방법이 있습니다: 바로 테이블 제약과 열 제약입니다.
   열 제약은 열 정의의 일부분으로 정의됩니다. 테이블 제약은 특정 열에 종속되지 않으며, 둘 이상의 열을 포함할 수 있습니다.
   모든 열 제약은 테이블 제약으로도 작성할 수 있습니다.
   열 제약은 단지, 해당 제약조건이 단일 열에만 영향을 주기 때문에, 간편하게 표기하도록 만든 것입니다.
  </para>

  <para>
   테이블을 생성하려면, 여러분은 모든 열 자료형 또는 <literal>OF</literal> 절의 자료형에,
   각각 <literal>USAGE</literal> 권한을 갖고 있어야 합니다.
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

  <variablelist>

   <varlistentry id="sql-createtable-temporary">
    <term><literal>TEMPORARY</literal> 또는 <literal>TEMP</literal></term>
    <listitem>
     <para>
      지정되면, 해당 테이블은 임시 테이블로 생성됩니다.
          임시 테이블은 세션이 종료될 때, 또는 옵션에 따라 현재 트랜젝션이 끝날 때
          (아래 <literal>ON COMMIT</literal> 참조) 자동으로 drop 됩니다.
          같은 이름의 영구적 테이블이 있다면, 스키마-수식명으로 참조하지 않는 한, 
          임시 테이블이 존재하는 동안은 현재 세션에서 보이지 않습니다.
          임시 테이블에 생성된 모든 인덱스 또한 자동으로 임시 객체가 됩니다.
     </para>

     <para>
      <link linkend="autovacuum">autovacuum daemon</link>은
          임시 테이블에 접근할 수 없기 때문에, 임시 테이블에 대한 vacuum이나 analyze를 수행할 수 없습니다.
          이러한 이유로, 세션에서 SQL 명령을 통해, 적절한 vacuum과 analyze 작업이 수행되어야 합니다.
          예를 들면, 복잡한 쿼리에서 임시 테이블을 사용하려면, 
          임시 테이블이 증식된 후에 <command>ANALYZE</command>를 수행하는 것이 좋습니다.
     </para>

     <para>
      선택적으로, <literal>TEMPORARY</literal>나 <literal>TEMP</literal> 앞에 
          <literal>GLOBAL</literal> 또는 <literal>LOCAL</literal>을 붙일 수 있습니다.
          이는 현재 <productname>PostgreSQL</productname>에서는 아무런 효과도 없으며, 만료된 기능입니다. 
          <xref linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title"/>를 참고하십시오.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-unlogged">
    <term><literal>UNLOGGED</literal></term>
    <listitem>
     <para>
      지정되면, 해당 테이블이 unlogged 테이블로 생성됩니다.
          Unlogged 테이블에 기록되는 데이터는 write-ahead 로그 (<xref
          linkend="wal"/>참고)에 기록되지 않으며, 때문에 일반 테이블보다 확연히 빠르게 기록됩니다.
          하지만, 이는 사고에 안전하지 않습니다. Unlogged table은 crash 또는 비정상 shutdown
          이후에 자동으로 truncate 됩니다. Unlogged table의 내용 또한 standby 서버로 복제되지 않습니다.
          Unlogged table에 생성된 모든 인덱스도 또한 자동으로 unlogged 상태가 됩니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
     <para>
      같은 이름의 관계가 이미 있는 경우에 error가 발생하지 않습니다. 대신에 notice가 발생합니다.
          기존의 관계가 새로 생성되는 것과 같다는 보장이 없음을 주의하십시오.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
     <para>
      생성될 테이블의 (옵션으로 스키마 수식된) 이름.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="parameter">type_name</replaceable></literal></term>
    <listitem>
     <para>
      지정된 복합 (옵션으로 스키마 수식된 이름의) 자료형 구조를 이용한
          <firstterm>typed table</firstterm>을 생성합니다.
          typed table은 자신의 자료형에 묶여 있습니다. 예를 들면, 자료형이 
          (<literal>DROP TYPE ... CASCADE</literal>으로)
          drop되면 테이블도 같이 drop될 것입니다.
     </para>

     <para>
      Typed 테이블이 생성되면, 해당 열의 데이터 자료형은 
          <literal>CREATE TABLE</literal> 명령으로 지정되는 것이 아니라
          내재된 복합 자료형에 따라 결정됩니다.
          하지만 <literal>CREATE TABLE</literal> 명령으로
          테이블에 기본값과 제약조건을 추가할 수 있고, storage parameter를 지정할 수 있습니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
     <para>
      신규 테이블에 생성될 열의 이름.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">data_type</replaceable></term>
    <listitem>
     <para>
      열의 데이터 자료형. 배열 지정자를 포함할 수 있습니다.
          <productname>PostgreSQL</productname>에서 지원하는 
          데이터 자료형에 대한 더 많은 정보는 <xref 
          linkend="datatype"/>을 참고하십시오.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
    <listitem>
     <para>
      <literal>COLLATE</literal>절은 해당 열에 (collate 가능한 데이터 자료형의 열이어야 한다)
          collation을 할당합니다. 지정하지 않으면, 열 데이터 자료형의 기본 collation이 사용됩니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>parent_table</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      선택적 <literal>INHERITS</literal> 절은,
          신규 테이블이 자동으로 모든 열을 상속받게 될 테이블의 목록을 지정합니다. 상위 테이블은
      일반 테이블 또는 참조 테이블을 지정할 수 있습니다.
     </para>

     <para>
      <literal>INHERITS</literal>를 사용하면 신규 자식 테이블과 그 부모 테이블 간에 영구적 관계를 생성합니다.
          부모의 schema를 변경하면 일반적으로 자식에도 전파되며,
          기본적으로 부모(들)를 검색할 때 자식의 데이터가 같이 포함됩니다.
     </para>

     <para>
      둘 이상의 부모 테이블에 동일한 열 이름이 있다면, 
          열들의 데이터 자료형이 각 부모 테이블 간에 일치하지 않는 경우 에러가 발생합니다.
          출동이 없다면, 중복 열은 새로운 테이블에서 하나의 열로 병합됩니다.
          신규 테이블의 열 이름 목록에, 상속받은 열과 동일한 이름이 포함된다면, 
          해당 데이터 자료형은 상속받은 열의 것과 일치해야 하며, 해당 열의 정의는 하나로 합쳐집니다.
          신규 테이블이 명시적으로 열에 대한 기본값을 지정한다면, 이 기본값은 상속받은 열에 선언되어 있던 기본값을 재정의합니다.
          명시적으로 지정하지 않은 경우, 해당 열에 기본값을 정의한 부모가 있다면, 모두 동일한 기본값을 지정해야 하며,
          그렇지 않으면 에러가 발생합니다.
     </para>

     <para>
          <literal>CHECK</literal> 제약은 근본적으로 열과 동일한 방식으로 병합됩니다:
          여러 부모 테이블 과/또는 새로운 테이블 정의가, 동일한 이름의 
          <literal>CHECK</literal> 제약을 포함하는 경우,
          이들 제약은 동일한 check 수식으로 되어 있어야 하며, 그렇지 않으면 에러가 발생합니다.
          같은 이름과 수식으로 된 제약조건은 하나로 병합될 것입니다.
          부모쪽에서 <literal>NO INHERIT</literal>으로 표기된 제약조건은 대상이 아닙니다.
          신규 테이블의 <literal>CHECK</literal> 제약에 이름을 지정하지 않은 경우,
          항상 고유한 이름이 선택되기 때문에 절대로 병합되지 않습니다.
     </para>

     <para>
      열의 <literal>STORAGE</literal> 설정 또한, 부모 테이블에서 복사됩니다.
     </para>

     <para>
      If a column in the parent table is an identity column, that property is
      not inherited.  A column in the child table can be declared identity
      column if desired.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) </literal></term>
    <listitem>
     <para>
      The optional <literal>PARTITION BY</literal> clause specifies a strategy
      of partitioning the table.  The table thus created is called a
      <firstterm>partitioned</firstterm> table.  The parenthesized list of
      columns or expressions forms the <firstterm>partition key</firstterm>
      for the table.  When using range or hash partitioning, the partition key
      can include multiple columns or expressions (up to 32, but this limit can
      be altered when building <productname>PostgreSQL</productname>), but for
      list partitioning, the partition key must consist of a single column or
      expression.
     </para>

     <para>
      Range and list partitioning require a btree operator class, while hash
      partitioning requires a hash operator class.  If no operator class is
      specified explicitly, the default operator class of the appropriate
      type will be used; if no default operator class exists, an error will
      be raised.  When hash partitioning is used, the operator class used
      must implement support function 2 (see <xref linkend="xindex-support"/>
      for details).
     </para>

     <para>
      A partitioned table is divided into sub-tables (called partitions),
      which are created using separate <literal>CREATE TABLE</literal> commands.
      The partitioned table is itself empty.  A data row inserted into the
      table is routed to a partition based on the value of columns or
      expressions in the partition key.  If no existing partition matches
      the values in the new row, an error will be reported.
     </para>

     <para>
      Partitioned tables do not support <literal>EXCLUDE</literal> constraints;
      however, you can define these constraints on individual partitions.
     </para>

     <para>
      See <xref linkend="ddl-partitioning"/> for more discussion on table
      partitioning.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-partition">
    <term><literal>PARTITION OF <replaceable class="parameter">parent_table</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
      Creates the table as a <firstterm>partition</firstterm> of the specified
      parent table. The table can be created either as a partition for specific
      values using <literal>FOR VALUES</literal> or as a default partition
      using <literal>DEFAULT</literal>.  Any indexes, constraints and
      user-defined row-level triggers that exist in the parent table are cloned
      on the new partition.
     </para>

     <para>
      The <replaceable class="parameter">partition_bound_spec</replaceable>
      must correspond to the partitioning method and partition key of the
      parent table, and must not overlap with any existing partition of that
      parent.  The form with <literal>IN</literal> is used for list partitioning,
      the form with <literal>FROM</literal> and <literal>TO</literal> is used
      for range partitioning, and the form with <literal>WITH</literal> is used
      for hash partitioning.
     </para>

     <para>
      <replaceable class="parameter">partition_bound_expr</replaceable> is
      any variable-free expression (subqueries, window functions, aggregate
      functions, and set-returning functions are not allowed).  Its data type
      must match the data type of the corresponding partition key column.
      The expression is evaluated once at table creation time, so it can
      even contain volatile expressions such as
      <literal><function>CURRENT_TIMESTAMP</function></literal>.
     </para>

     <para>
      When creating a list partition, <literal>NULL</literal> can be
      specified to signify that the partition allows the partition key
      column to be null.  However, there cannot be more than one such
      list partition for a given parent table.  <literal>NULL</literal>
      cannot be specified for range partitions.
     </para>

     <para>
      When creating a range partition, the lower bound specified with
      <literal>FROM</literal> is an inclusive bound, whereas the upper
      bound specified with <literal>TO</literal> is an exclusive bound.
      That is, the values specified in the <literal>FROM</literal> list
      are valid values of the corresponding partition key columns for this
      partition, whereas those in the <literal>TO</literal> list are
      not.  Note that this statement must be understood according to the
      rules of row-wise comparison (<xref linkend="row-wise-comparison"/>).
      For example, given <literal>PARTITION BY RANGE (x,y)</literal>, a partition
      bound <literal>FROM (1, 2) TO (3, 4)</literal>
      allows <literal>x=1</literal> with any <literal>y&gt;=2</literal>,
      <literal>x=2</literal> with any non-null <literal>y</literal>,
      and <literal>x=3</literal> with any <literal>y&lt;4</literal>.
     </para>

     <para>
      The special values <literal>MINVALUE</literal> and <literal>MAXVALUE</literal>
      may be used when creating a range partition to indicate that there
      is no lower or upper bound on the column's value. For example, a
      partition defined using <literal>FROM (MINVALUE) TO (10)</literal> allows
      any values less than 10, and a partition defined using
      <literal>FROM (10) TO (MAXVALUE)</literal> allows any values greater than
      or equal to 10.
     </para>

     <para>
      When creating a range partition involving more than one column, it
      can also make sense to use <literal>MAXVALUE</literal> as part of the lower
      bound, and <literal>MINVALUE</literal> as part of the upper bound. For
      example, a partition defined using
      <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</literal> allows any rows
      where the first partition key column is greater than 0 and less than
      or equal to 10. Similarly, a partition defined using
      <literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</literal> allows any rows
      where the first partition key column starts with "a".
     </para>

     <para>
      Note that if <literal>MINVALUE</literal> or <literal>MAXVALUE</literal> is used for
      one column of a partitioning bound, the same value must be used for all
      subsequent columns.  For example, <literal>(10, MINVALUE, 0)</literal> is not
      a valid bound; you should write <literal>(10, MINVALUE, MINVALUE)</literal>.
     </para>

     <para>
      Also note that some element types, such as <literal>timestamp</literal>,
      have a notion of "infinity", which is just another value that can
      be stored. This is different from <literal>MINVALUE</literal> and
      <literal>MAXVALUE</literal>, which are not real values that can be stored,
      but rather they are ways of saying that the value is unbounded.
      <literal>MAXVALUE</literal> can be thought of as being greater than any
      other value, including "infinity" and <literal>MINVALUE</literal> as being
      less than any other value, including "minus infinity". Thus the range
      <literal>FROM ('infinity') TO (MAXVALUE)</literal> is not an empty range; it
      allows precisely one value to be stored &mdash; "infinity".
     </para>

     <para>
      If <literal>DEFAULT</literal> is specified, the table will be
      created as the default partition of the parent table.  This option
      is not available for hash-partitioned tables.  A partition key value
      not fitting into any other partition of the given parent will be
      routed to the default partition.
     </para>

     <para>
      When a table has an existing <literal>DEFAULT</literal> partition and
      a new partition is added to it, the default partition must
      be scanned to verify that it does not contain any rows which properly
      belong in the new partition.  If the default partition contains a
      large number of rows, this may be slow.  The scan will be skipped if
      the default partition is a foreign table or if it has a constraint which
      proves that it cannot contain rows which should be placed in the new
      partition.
     </para>

     <para>
      When creating a hash partition, a modulus and remainder must be specified.
      The modulus must be a positive integer, and the remainder must be a
      non-negative integer less than the modulus.  Typically, when initially
      setting up a hash-partitioned table, you should choose a modulus equal to
      the number of partitions and assign every table the same modulus and a
      different remainder (see examples, below).   However, it is not required
      that every partition have the same modulus, only that every modulus which
      occurs among the partitions of a hash-partitioned table is a factor of the
      next larger modulus.  This allows the number of partitions to be increased
      incrementally without needing to move all the data at once.  For example,
      suppose you have a hash-partitioned table with 8 partitions, each of which
      has modulus 8, but find it necessary to increase the number of partitions
      to 16.  You can detach one of the modulus-8 partitions, create two new
      modulus-16 partitions covering the same portion of the key space (one with
      a remainder equal to the remainder of the detached partition, and the
      other with a remainder equal to that value plus 8), and repopulate them
      with data.  You can then repeat this -- perhaps at a later time -- for
      each modulus-8 partition until none remain.  While this may still involve
      a large amount of data movement at each step, it is still better than
      having to create a whole new table and move all the data at once.
     </para>

     <para>
      A partition must have the same column names and types as the partitioned
      table to which it belongs. Modifications to the column names or types of
      a partitioned table will automatically propagate to all partitions.
      <literal>CHECK</literal> constraints will be inherited automatically by
      every partition, but an individual partition may specify additional
      <literal>CHECK</literal> constraints; additional constraints with the
      same name and condition as in the parent will be merged with the parent
      constraint.  Defaults may be specified separately for each partition.
      But note that a partition's default value is not applied when inserting
      a tuple through a partitioned table.
     </para>

     <para>
      Rows inserted into a partitioned table will be automatically routed to
      the correct partition.  If no suitable partition exists, an error will
      occur.
     </para>

     <para>
      Operations such as TRUNCATE which normally affect a table and all of its
      inheritance children will cascade to all partitions, but may also be
      performed on an individual partition.  Note that dropping a partition
      with <literal>DROP TABLE</literal> requires taking an <literal>ACCESS
      EXCLUSIVE</literal> lock on the parent table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ]</literal></term>
    <listitem>
     <para>
      <literal>LIKE</literal> 절은, 신규 테이블이 자동으로
          모든 열 이름, 데이터 자료형, not-null 제약을 복사해서 가져올 테이블을 지정합니다.
     </para>
     <para>
      <literal>INHERITS</literal>와 달리,
          생성이 완료된 후에는 신규 테이블과 원본 테이블이 완전히 분리됩니다.
          원본 테이블에 대한 변경이 신규 테이블에 적용되지 않으며,
          신규 테이블에 포함된 데이터를 원본 테이블에서 검색할 수도 없습니다.
     </para>
     <para>
      <literal>INHERITS</literal>와 다르게, <literal>LIKE</literal>로 복사되는
          열과 제약조건은 유사한 이름의 열과 제약끼리 병합되지 않는다는 점도 유의하십시오.
          동일한 이름이 명시적으로 지정되거나, 
          동일한 이름이 다른 <literal>LIKE</literal>절에 있는 경우, 에러가 발생합니다.
     </para>
     <para>
      The optional <replaceable>like_option</replaceable> clauses specify
      which additional properties of the original table to copy.  Specifying
      <literal>INCLUDING</literal> copies the property, specifying
      <literal>EXCLUDING</literal> omits the property.
      <literal>EXCLUDING</literal> is the default.  If multiple specifications
      are made for the same kind of object, the last one is used.  The
      available options are:

      <variablelist>
       <varlistentry>
        <term><literal>INCLUDING COMMENTS</literal></term>
        <listitem>
         <para>
          Comments for the copied columns, constraints, and indexes will be
          copied.  The default behavior is to exclude comments, resulting in
          the copied columns and constraints in the new table having no
          comments.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING CONSTRAINTS</literal></term>
        <listitem>
         <para>
          <literal>CHECK</literal> constraints will be copied.  No distinction
          is made between column constraints and table constraints.  Not-null
          constraints are always copied to the new table.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING DEFAULTS</literal></term>
        <listitem>
         <para>
          Default expressions for the copied column definitions will be
          copied.  Otherwise, default expressions are not copied, resulting in
          the copied columns in the new table having null defaults.  Note that
          copying defaults that call database-modification functions, such as
          <function>nextval</function>, may create a functional linkage
          between the original and new tables.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING GENERATED</literal></term>
        <listitem>
         <para>
          Any generation expressions of copied column definitions will be
          copied.  By default, new columns will be regular base columns.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING IDENTITY</literal></term>
        <listitem>
         <para>
          Any identity specifications of copied column definitions will be
          copied.  A new sequence is created for each identity column of the
          new table, separate from the sequences associated with the old
          table.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING INDEXES</literal></term>
        <listitem>
         <para>
          Indexes, <literal>PRIMARY KEY</literal>, <literal>UNIQUE</literal>,
          and <literal>EXCLUDE</literal> constraints on the original table
          will be created on the new table.  Names for the new indexes and
          constraints are chosen according to the default rules, regardless of
          how the originals were named.  (This behavior avoids possible
          duplicate-name failures for the new indexes.)
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING STATISTICS</literal></term>
        <listitem>
         <para>
          Extended statistics are copied to the new table.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING STORAGE</literal></term>
        <listitem>
         <para>
          <literal>STORAGE</literal> settings for the copied column
          definitions will be copied.  The default behavior is to exclude
          <literal>STORAGE</literal> settings, resulting in the copied columns
          in the new table having type-specific default settings.  For more on
          <literal>STORAGE</literal> settings, see <xref
          linkend="storage-toast"/>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING ALL</literal></term>
        <listitem>
         <para>
          <literal>INCLUDING ALL</literal> is an abbreviated form selecting
          all the available individual options.  (It could be useful to write
          individual <literal>EXCLUDING</literal> clauses after
          <literal>INCLUDING ALL</literal> to select all but some specific
          options.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      <literal>LIKE</literal> 절은 뷰, 외래 테이블 또는 복합 자료형 들로부터
          열을 복사해 오는 데에도 이용할 수 있습니다.
          적용할 수 없는 옵션(예를 들어,뷰로부터의 <literal>INCLUDING INDEXES</literal>)은 무시됩니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="parameter">constraint_name</replaceable></literal></term>
    <listitem>
     <para>
      선택적인, 열이나 테이블 제약의 이름.
          제약조건에 위배되는 경우 해당 제약명이 에러 메시지에 나타나기 때문에,
          <literal>col must be positive</literal>와 같은 제약명은, 
          유용한 제약조건 정보를 클라이언트 응용프로그램에 전달할 수 있습니다.
          (빈칸이 포함된 제약명을 지정하려면 이중 따옴표가 필요합니다.)
          제약명을 지정하지 않으면, 시스템에서 이름을 생성합니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</literal></term>
    <listitem>
     <para>
      해당 열은 null 값을 가질 수 없습니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <para>
      해당 열은 null 값을 가질 수 있습니다. 이게 기본값입니다.
     </para>

     <para>
      이 절은 단지 비표준 SQL 데이터베이스와의 호환을 위해서 제공됩니다.
          신규 응용프로그램에 사용하는 것은 권장하지 않습니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] </literal></term>
    <listitem>
     <para>
      <literal>CHECK</literal>절은, 
          신규 또는 업데이트되는 행이 삽입 또는 업데이트 동작을 성공적으로 수행하기 위해 충족해야 하는,
          Boolean 결과를 생성하는 수식을 지정합니다.
          TRUE 또는 UNKNOWN으로 계산되는 수식은 성공입니다.
          결과로 FALSE 생성하는 열 삽입이나 업데이트 작업은 에러 예외가 발생하며,
          해당 작업은 데이터베이스에 영향을 주지 않습니다.
          열 제약으로 지정된 Check 제약은 해당 열의 값만 참조해야 하며,
          테이블 제약의 수식은 여러 열을 참조할 수 있습니다.
     </para>

     <para>
      Currently, <literal>CHECK</literal> expressions cannot contain
      subqueries nor refer to variables other than columns of the
      current row (see <xref linkend="ddl-constraints-check-constraints"/>).
      The system column <literal>tableoid</literal>
      may be referenced, but not any other system column.
     </para>

     <para>
      <literal>NO INHERIT</literal>로 표기된 제약은 자식 테이블에 전파되지 않습니다.
     </para>

     <para>
      When a table has multiple <literal>CHECK</literal> constraints,
      they will be tested for each row in alphabetical order by name,
      after checking <literal>NOT NULL</literal> constraints.
      (<productname>PostgreSQL</productname> versions before 9.5 did not honor any
      particular firing order for <literal>CHECK</literal> constraints.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
     <para>
      <literal>DEFAULT</literal> 절은 이를 정의에 포함하는 열에 대한 기본값을 할당합니다.
      아무 값이나 지정할 수 있다. 해당 테이블의 다른 칼럼을 지정할 없다.
      서브 쿼리도 사용할 수 없다. 
      지정한 값의 자료형은 해당 칼럼의 자료형과 같아야 한다.
     </para>

     <para>
      기본값 수식은 해당 열의 값을 지정하지 않은 모든 삽입 작업에 사용될 것입니다.
          열에 기본값이 없는 경우, null이 기본값이 됩니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED</literal><indexterm><primary>generated column</primary></indexterm></term>
    <listitem>
     <para>
      This clause creates the column as a <firstterm>generated
      column</firstterm>.  The column cannot be written to, and when read the
      result of the specified expression will be returned.
     </para>

     <para>
      The keyword <literal>STORED</literal> is required to signify that the
      column will be computed on write and will be stored on disk.
     </para>

     <para>
      The generation expression can refer to other columns in the table, but
      not other generated columns.  Any functions and operators used must be
      immutable.  References to other tables are not allowed.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]</literal></term>
    <listitem>
     <para>
      This clause creates the column as an <firstterm>identity
      column</firstterm>.  It will have an implicit sequence attached to it
      and the column in new rows will automatically have values from the
      sequence assigned to it.
      Such a column is implicitly <literal>NOT NULL</literal>.
     </para>

     <para>
      The clauses <literal>ALWAYS</literal> and <literal>BY DEFAULT</literal>
      determine how the sequence value is given precedence over a
      user-specified value in an <command>INSERT</command> statement.
      If <literal>ALWAYS</literal> is specified, a user-specified value is
      only accepted if the <command>INSERT</command> statement
      specifies <literal>OVERRIDING SYSTEM VALUE</literal>.  If <literal>BY
      DEFAULT</literal> is specified, then the user-specified value takes
      precedence.  See <xref linkend="sql-insert"/> for details.  (In
      the <command>COPY</command> command, user-specified values are always
      used regardless of this setting.)
     </para>

     <para>
      The optional <replaceable>sequence_options</replaceable> clause can be
      used to override the options of the sequence.
      See <xref linkend="sql-createsequence"/> for details.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNIQUE</literal> (column constraint)</term>
    <term><literal>UNIQUE ( <replaceable class="parameter">column_name</replaceable> [, ... ] )</literal>
    <optional> <literal>INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...])</literal> </optional> (table constraint)</term>


    <listitem>
     <para>
      <literal>UNIQUE</literal> 제약은 테이블 내에서 고유값만 포함할 수 있는
      하나 이상의 열 그룹을 지정합니다.
      The behavior of a unique table constraint
      is the same as that of a unique column constraint, with the
      additional capability to span multiple columns.  The constraint
      therefore enforces that any two rows must differ in at least one
      of these columns.
     </para>

     <para>
          Unique 제약의 목적에 맞게, null 값은 서로 다른 것으로 간주됩니다.
     </para>

     <para>
          각 unique 제약에서 지정한 열 집합은,
          다른 unique나 primary key 제약에서 지정한 열 집합과 달라야 합니다.
          (중복되면, 유니크 제약조건은 무시 된다.)
     </para>

     <para>
      When establishing a unique constraint for a multi-level partition
      hierarchy, all the columns in the partition key of the target
      partitioned table, as well as those of all its descendant partitioned
      tables, must be included in the constraint definition.
     </para>

     <para>
      Adding a unique constraint will automatically create a unique btree
      index on the column or group of columns used in the constraint.
     </para>

     <para>
      The optional <literal>INCLUDE</literal> clause adds to that index
      one or more columns that are simply <quote>payload</quote>: uniqueness
      is not enforced on them, and the index cannot be searched on the basis
      of those columns.  However they can be retrieved by an index-only scan.
      Note that although the constraint is not enforced on included columns,
      it still depends on them.  Consequently, some operations on such columns
      (e.g., <literal>DROP COLUMN</literal>) can cause cascaded constraint and
      index deletion.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</literal> (column constraint)</term>
    <term><literal>PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )</literal>
    <optional> <literal>INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...])</literal> </optional> (table constraint)</term>

    <listitem>
     <para>
      The <literal>PRIMARY KEY</literal> constraint specifies that a column or
      columns of a table can contain only unique (non-duplicate), nonnull
      values. Only one primary key can be specified for a table, whether as a
      column constraint or a table constraint.
     </para>

     <para>
      The primary key constraint should name a set of columns that is
      different from the set of columns named by any unique
      constraint defined for the same table.  (Otherwise, the unique
      constraint is redundant and will be discarded.)
     </para>

     <para>
      <literal>PRIMARY KEY</literal> enforces the same data constraints as
      a combination of <literal>UNIQUE</literal> and <literal>NOT
      NULL</literal>.  However,
      identifying a set of columns as the primary key also provides metadata
      about the design of the schema, since a primary key implies that other
      tables can rely on this set of columns as a unique identifier for rows.
     </para>

     <para>
      When placed on a partitioned table, <literal>PRIMARY KEY</literal>
      constraints share the restrictions previously described
      for <literal>UNIQUE</literal> constraints.
     </para>

     <para>
      Adding a <literal>PRIMARY KEY</literal> constraint will automatically
      create a unique btree index on the column or group of columns used in the
      constraint.
     </para>

     <para>
      The optional <literal>INCLUDE</literal> clause adds to that index
      one or more columns that are simply <quote>payload</quote>: uniqueness
      is not enforced on them, and the index cannot be searched on the basis
      of those columns.  However they can be retrieved by an index-only scan.
      Note that although the constraint is not enforced on included columns,
      it still depends on them.  Consequently, some operations on such columns
      (e.g., <literal>DROP COLUMN</literal>) can cause cascaded constraint and
      index deletion.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-exclude">
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
    <listitem>
     <para>
      <literal>EXCLUDE</literal> 절은,
          임의의 두 행이 지정된 열 또는 지정된 연산자를 이용하는 수식으로 서로 비교되는 경우,
          비교 결과가 모두 <literal>TRUE</literal>가 되지 않도록 보장하는, exclusion 제약을 정의합니다.
          지정된 연산자가 모두 동등 비교를 한다면, 이는 <literal>UNIQUE</literal> 제약과 동일합니다,
          물론 보통의 unqiue 제약이 더 빠를 것입니다.
          하지만, exclusion 제약은 단순한 동등 비교보다 더 포괄적으로 제약을 지정할 수 있습니다.
          예를 들어, <literal>&amp;&amp;</literal> 연산자를 이용하면, 
          테이블의 어떠한 두 행도 서로 겹쳐지는 원<xref linkend="datatype-geometric"/> 참고)을 포함하지 못하도록
          제약을 지정할 수 있습니다.
     </para>

     <para>
      Exclusion 제약은 인덱스를 이용하여 구현되며, 
          때문에 각 지정 연산자는 인덱스 접근 메서드 <replaceable>index_method</replaceable>와 맞는
          적절한 연산자 클래스(<xref linkend="indexes-opclass"/> 참고)와 연결되어야 합니다.
          해당 연산자는 각 항의 나열순서에 관계없이 결과가 동일해야 합니다.
          각 <replaceable class="parameter">exclude_element</replaceable>는 
          선택적으로 연산자 클래스 와/또는 정렬 옵션을 지정할 수 있습니다.
          이에 대해서는 <xref linkend="sql-createindex"/>에서 모두 설명됩니다.
     </para>

     <para>
      해당 접근 메서드는 <literal>amgettuple</literal>(<xref
      linkend="indexam"/> 참고)를 지원해야 합니다.
          현재 이는 <acronym>GIN</acronym>이 사용될 수 없다는 것을 의미합니다.
          설령 허용된다 해도, exclusion 제약에 B-tree나 hash 인덱스를 사용하는 것은 별로 의미가 없습니다.
          일반 unique 제약보다 나을게 아무것도 없기 때문입니다.
          때문에, 실질적으로 접근 메서드는 항상 <acronym>GiST</acronym>거나 <acronym>SP-GiST</acronym>가 됩니다.
     </para>

     <para>
      <replaceable class="parameter">predicate</replaceable>는
          테이블의 서브셋에 exclusion 제약을 지정하는 것을 허용합니다.
          이것은 내부적으로 부분 인덱스를 생성합니다.
          해당 predicate를 괄호로 감싸야 한다는 점에 주의하십시오.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ]</literal> (column constraint)</term>

   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ]</literal>
    (table constraint)</term>

    <listitem>
     <para>
      이 절은, 신규 테이블의 하나 이상의 열 그룹이, 참조되는 테이블의 행에 있는 열(들)의 값과 일치하도록 요구하는,
          외래키 제약을 지정합니다.
          <replaceable class="parameter">refcolumn</replaceable>이 생략되면,
          <replaceable class="parameter">reftable</replaceable>의 primary key가 사용됩니다.
      The referenced columns must be the columns of a non-deferrable
      unique or primary key constraint in the referenced table.  The user
      must have <literal>REFERENCES</literal> permission on the referenced table
      (either the whole table, or the specific referenced columns).  The
      addition of a foreign key constraint requires a
      <literal>SHARE ROW EXCLUSIVE</literal> lock on the referenced table.
      Note that foreign key constraints cannot be defined between temporary
      tables and permanent tables.
     </para>

     <para>
      지정된 일치 조건을 이용하여, 참조하는 열(들)에 삽입되는 값이 참조되는 테이블과 참조되는 열의 값에 대응됩니다.
          다음의 세가지 일치 조건: <literal>MATCH FULL</literal>, <literal>MATCH PARTIAL</literal>,
          그리고 기본값인 <literal>MATCH SIMPLE</literal>이 있습니다.
          <literal>MATCH FULL</literal>은 외래키의 모든 열이 null인 경우를 제외하고, 다중열 외래키의 한개 열이 null이 되는 것을 허용하지 않을 것입니다.
          모두 null인 경우, 해당 행은 참조되는 테이블의 것과 일치되지 않아도 됩니다.
          <literal>MATCH SIMPLE</literal>은 외래키의 일부 열이 null이 되는 것을 허용합니다.
          어떤 열이든 null이 있으면, 해당 행은 참조되는 테이블의 것과 일치되지 않아도 됩니다.
          <literal>MATCH PARTIAL</literal>은 아직 구현되지 않았습니다.
          (물론, 이런 일이 일어나는 것을 방지하기 위해,
          <literal>NOT NULL</literal> 제약을 참조하는 열(들)에 적용할 수 있습니다.)
     </para>

     <para>
      추가로, 참조되는 열의 데이터가 변경될 때, 이 테이블의 열 데이터에 특정 작업이 수행됩니다.
          <literal>ON DELETE</literal> 절은 참조되는 테이블의 참조되는 행이 삭제될 때에 수행될 작업을 지정합니다.
          마찬가지로, <literal>ON UPDATE</literal> 절은 참조되는 테이블의 참조되는 열이 새로운 값으로 업데이트 될 때에 수행될 작업을 지정합니다.
          해당 행이 업데이트 되었지만, 실제론 참조되는 열에 변경점이 없다면, 아무런 작업도 수행되지 않습니다.
          제약이 deferred로 선언되었더라도, <literal>NO ACTION</literal>을 제외한 참조 작업은 deferred가 될 수 없습니다.
          다음은 각 절에 가능한 작업입니다:
      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          삭제나 업데이트를 실행하면 외래키 제약에 위배되는 경우 에러를 발생합니다.
                  제약조건이 deferred면, 이 에러는 참조하는 행이 존재하는 경우 제약조건 검사 시점에 발생합니다.
                  이것이 기본 동작입니다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          삭제나 업데이트를 실행하면 외래키 제약에 위배되는 경우 에러를 발생합니다.
                  검사가 deferrable이 아닌 점을 빼면, <literal>NO ACTION</literal>과 동일합니다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          삭제인 경우 삭제되는 행을 참조하는 모든 행을 삭제하고,
                  업데이트인 경우 참조되는 열의 바뀐 값으로, 참조중인 열의 값을 업데이트 합니다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          참조하는 열(들)을 null로 설정합니다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
          참조하는 열(들)을 기본값으로 설정합니다.
                  (참조되는 테이블에 해당 기본값과 일치하는 행이 있어야 하며, 그렇지 않은 경우 null이 아니라면 해당 동작은 실패하게 됩니다.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      참조되는 열(들)이 자주 변경되는 경우, 외래키 제약과 관련된 참조동작이 좀더 효율적으로 수행될 수 있도록,
          외래키 열에 인덱스를 추가하는 것이 좋습니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <para>
      이는 제약조건이 연기될 수 있는지 여부를 제어합니다.
          Deferrable이 아닌 제약조건은 매 명령 직후에 검사될 것입니다.
          (<xref linkend="sql-set-constraints"/> 명령을 사용헤서) Deferrable인 제약조건은
          트랜잭션이 끝날 때까지 검사를 연기합니다.
          <literal>NOT DEFERRABLE</literal>이 기본값입니다.
          현재, <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, <literal>EXCLUDE</literal> 및
          <literal>REFERENCES</literal>(외래키) 제약에만 이 절을 입력할 수 있습니다.
          <literal>NOT NULL</literal> 및 <literal>CHECK</literal> 제약은 deferrable이 될 수 없습니다.
      Note that deferrable constraints cannot be used as
      conflict arbitrators in an <command>INSERT</command> statement that
      includes an <literal>ON CONFLICT DO UPDATE</literal> clause.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      제약조건이 deferrable이면, 이 절은 제약을 검사하는 기본 시점을지정합니다.
          제약조건이 <literal>INITIALLY IMMEDIATE</literal>이면, 매 문장 뒤에 검사됩니다. 이것이 기본값입니다.
          제약조건이 <literal>INITIALLY DEFERRED</literal>이면, 트랜잭션의 마지막에만 검사됩니다.
          제약 검사시점은 <xref linkend="sql-set-constraints"/> 명령으로 변경할 수 있습니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-method">
    <term><literal>USING <replaceable class="parameter">method</replaceable></literal></term>
    <listitem>
     <para>
      This optional clause specifies the table access method to use to store
      the contents for the new table; the method needs be an access method of
      type <literal>TABLE</literal>. See <xref linkend="tableam"/> for more
      information.  If this option is not specified, the default table access
      method is chosen for the new table. See <xref
      linkend="guc-default-table-access-method"/> for more information.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      이절은 테이블이나 인덱스에 대한 선택적 storage parameter를 지정합니다.
          더 많은 정보는 <xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title"/>를 참고하십시오.
      For backward-compatibility the <literal>WITH</literal>
      clause for a table can also include <literal>OIDS=FALSE</literal> to
      specify that rows of the new table should not contain OIDs (object
      identifiers), <literal>OIDS=TRUE</literal> is not supported anymore.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      This is backward-compatible syntax for declaring a table
      <literal>WITHOUT OIDS</literal>, creating a table <literal>WITH
      OIDS</literal> is not supported anymore.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     <para>
          <literal>ON COMMIT</literal>을 이용하여,
          트랜잭션 블록의 마지막에 임시 테이블의 동작 방식을 제어할 수 있습니다.
          다음에 3가지 옵션이 있습니다:
      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          트랜잭션의 마지막에 아무런 특별한 동작도 이루어지지 않습니다.
                  이것이 기본 동작입니다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          각 트랜잭션 블록의 끝에서 임시 테이블의 모든 행이 삭제됩니다.
                  본질적으로 각 commit마다 자동으로 <xref
          linkend="sql-truncate"/>이 행해집니다.  When used on a partitioned table, this
          is not cascaded to its partitions.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          현재 트랜잭션 블록의 끝에서 임시 테이블이 drop
          됩니다.  When used on a partitioned table, this action
          drops its partitions and when used on tables with inheritance
          children, it drops the dependent children.
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-tablespace">
    <term><literal>TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
    <listitem>
     <para>
      <replaceable class="parameter">tablespace_name</replaceable>은
          신규 테이블이 생성될 tablespace의 이름입니다.
          지정하지 않으면 <xref linkend="guc-default-tablespace"/>이 제시되며,
          임시 테이블인 경우엔 <replaceable class="parameter">temp_tablespaces</replaceable>이 됩니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
    <listitem>
     <para>
      이 절은 <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, 
          또는 <literal>EXCLUDE</literal> 제약과 연관된 인덱스가 생성될 테이블스페이스를 선택할 수 있게 합니다.
          지정하지 않으면 <xref linkend="guc-default-tablespace"/>가 제시되며,
          임시 테이블인 경우엔 <xref linkend="guc-temp-tablespaces"/>가 됩니다.
      For partitioned tables, since no storage is required for the table itself,
      the tablespace specified overrides <literal>default_tablespace</literal>
      as the default tablespace to use for any newly created partitions when no
      other tablespace is explicitly specified.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <refsect2 id="sql-createtable-storage-parameters">
   <title id="sql-createtable-storage-parameters-title">Storage Parameters</title>

 <indexterm zone="sql-createtable-storage-parameters">
  <primary>storage parameters</primary>
 </indexterm>

   <para>
    <literal>WITH</literal>절은 테이블 및 <literal>UNIQUE</literal>, 
        <literal>PRIMARY KEY</literal>, 또는 <literal>EXCLUDE</literal> 제약과 연결된 인덱스에,
        <firstterm>storage parameters</firstterm>를 지정할 수 있습니다.
        인덱스에 대한 storage parameter는 <xref linkend="sql-createindex"/>에 문서화되어 있습니다.
        테이블에 현재 설정할 수 있는 storage parameter는 아래에 나열되어 있습니다.
        특별히 명시되어있지 않다면, 각 매개 변수에는, 해당 테이블의 부가적인
        <acronym>TOAST</acronym> 테이블(있다면)의 동작 방식을 제어하는데 사용할 수 있는,
        같은 이름에 <literal>toast.</literal>접두어가 붙여진 이름의 추가 매개 변수가 존재합니다.
        (TOAST에 대한 더 많은 정보는 (see <xref linkend="storage-toast"/>을 참고하십시오).
        TOAST 테이블은, <literal>toast.autovacuum_*</literal> 설정을 하지 않았다면,
        부모 테이블의 <literal>autovacuum_*</literal> 값을 상속받는다는 점에 주의하십시오
    Specifying these parameters for partitioned tables is not supported,
    but you may specify them for individual leaf partitions.
   </para>

   <variablelist>

    <varlistentry id="reloption-fillfactor" xreflabel="fillfactor">
    <term><varname>fillfactor</varname> (<type>integer</type>)
    <indexterm>
     <primary><varname>fillfactor</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      테이블에 대한 fillfactor는 10부터 100까지의 백분율입니다.
          100(완전패킹)이 기본값입니다. 
          더 작은 값이 지정되면, <command>INSERT</command> 연산이 테이블 페이지를 표시된 백분율만큼만 패킹합니다. 
          각 페이지의 남은 공간은 해당 페이지에 있는 행이 업데이트 될 공간으로 예약됩니다. 
          이는 <command>UPDATE</command>를 실행했을 때 업데이트된 행 복사본이 원본과 동일한 페이지에 들어갈 수 있는 기회가 되며,
          이는 다른 페이지로 들어가는 것보다 효율적입니다. 
          절대로 항목이 업데이트 되지 않는 테이블이라면 완전 패킹이 가장 좋은 선택이지만, 
          빈번하게 업데이트되는 테이블이라면 작은 fillfactor 값이 적합할 것입니다.
          이 매개 변수는 TOAST 테이블에 설정할 수 없습니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-toast-tuple-target" xreflabel="toast_tuple_target">
    <term><literal>toast_tuple_target</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>toast_tuple_target</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      The toast_tuple_target specifies the minimum tuple length required before
      we try to compress and/or move long column values into TOAST tables, and
      is also the target length we try to reduce the length below once toasting
      begins. This affects columns marked as External (for move),
      Main (for compression), or Extended (for both) and applies only to new
      tuples. There is no effect on existing rows.
      By default this parameter is set to allow at least 4 tuples per block,
      which with the default blocksize will be 2040 bytes. Valid values are
      between 128 bytes and the (blocksize - header), by default 8160 bytes.
      Changing this value may not be useful for very short or very long rows.
      Note that the default setting is often close to optimal, and
      it is possible that setting this parameter could have negative
      effects in some cases.
      This parameter cannot be set for TOAST tables.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-parallel-workers" xreflabel="parallel_workers">
    <term><literal>parallel_workers</literal> (<type>integer</type>)
     <indexterm>
     <primary><varname>parallel_workers</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블을 조회 할 때 사용할 병렬 처리 작업자 수를 지정한다.  이 값이
      지정되어 있지 않으면, 서버는 해당 테이블의 크기와 관리용 내부 명령 수를
      감안해서 그 작업자 수를
      계산한다.  실재 작업자 수는 <xref linkend="guc-max-worker-processes"/> 설정값을
      참조해서 결정 됨으로 그 수보다는 적다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-enabled" xreflabel="autovacuum_enabled">
    <term><literal>autovacuum_enabled</literal>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>autovacuum_enabled</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
     지정 테이블에 대한 autovacuum daemon을 활성화 또는 비활성화 합니다.
     이 값이 true이면, <command>VACUUM</command>, <command>ANALYZE</command> 작업을
     <xref linkend="autovacuum"/>에서 언급한 대로 autovacuum 데몬이 담당합니다.
     이 값이 false이면, 트랜잭션 ID 겹침 방지 작업(<xref linkend="vacuum-for-wraparound"/> 참조)을
     제외하고, autovacuum 작업 대상에서 제외됩니다. 
     만약 <xref linkend="guc-autovacuum"/> 환경 설정값을 false로 해 두었다면, 
     모든 테이블에 대해서 autovacuum 작업은 일어나지 않습니다. 
     단 트랜잭션 ID 겹침 방지를 위한 autovacuum 작업은 모든 테이블에 대해서 
     이 환경 설정과 상관 없이 일어 납니다.
     Therefore there is seldom much point in explicitly
     setting this storage parameter to <literal>true</literal>, only
     to <literal>false</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-vacuum-index-cleanup" xreflabel="vacuum_index_cleanup">
    <term><literal>vacuum_index_cleanup</literal>, <literal>toast.vacuum_index_cleanup</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>vacuum_index_cleanup</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      Enables or disables index cleanup when <command>VACUUM</command> is
      run on this table.  The default value is <literal>true</literal>.
      Disabling index cleanup can speed up <command>VACUUM</command> very
      significantly, but may also lead to severely bloated indexes if table
      modifications are frequent.  The <literal>INDEX_CLEANUP</literal>
      parameter of <xref linkend="sql-vacuum"/>, if specified, overrides
      the value of this option.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-vacuum-truncate" xreflabel="vacuum_truncate">
    <term><literal>vacuum_truncate</literal>, <literal>toast.vacuum_truncate</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>vacuum_truncate</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      Enables or disables vacuum to try to truncate off any empty pages
      at the end of this table. The default value is <literal>true</literal>.
      If <literal>true</literal>, <command>VACUUM</command> and
      autovacuum do the truncation and the disk space for
      the truncated pages is returned to the operating system.
      Note that the truncation requires <literal>ACCESS EXCLUSIVE</literal>
      lock on the table. The <literal>TRUNCATE</literal> parameter
      of <xref linkend="sql-vacuum"/>, if specified, overrides the value
      of this option.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-threshold" xreflabel="autovacuum_vacuum_threshold">
    <term><literal>autovacuum_vacuum_threshold</literal>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_threshold</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-vacuum-threshold"/>
      설정
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-scale-factor" xreflabel="autovacuum_vacuum_scale_factor">
    <term><literal>autovacuum_vacuum_scale_factor</literal>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_scale_factor</varname> </primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
      설정
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-analyze-threshold" xreflabel="autovacuum_analyze_threshold">
    <term><literal>autovacuum_analyze_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_analyze_threshold</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-analyze-threshold"/>
      설정
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-analyze-scale-factor" xreflabel="autovacuum_analyze_scale_factor">
    <term><literal>autovacuum_analyze_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_analyze_scale_factor</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별  <xref linkend="guc-autovacuum-analyze-scale-factor"/>
      설정
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-cost-delay" xreflabel="autovacuum_vacuum_cost_delay">
    <term><literal>autovacuum_vacuum_cost_delay</literal>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_cost_delay</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-vacuum-cost-delay"/> 설정
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-cost-limit" xreflabel="autovacuum_vacuum_cost_limit">
    <term><literal>autovacuum_vacuum_cost_limit</literal>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_cost_limit</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-vacuum-cost-limit"/> 설정
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-freeze-min-age" xreflabel="autovacuum_freeze_min_age">
    <term><literal>autovacuum_freeze_min_age</literal>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_min_age</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
         해당 테이블 단위 개별 <xref linkend="guc-vacuum-freeze-min-age"/> 설정.
         autovacuum 작업은 테이블 단위 개별 <literal>autovacuum_freeze_min_age</literal> 값이
         시스템 전역 <xref linkend="guc-autovacuum-freeze-max-age"/> 환경 설정값의 절반 보다 큰 값이면
         무시한다는 점에 주의하십시오.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-freeze-max-age" xreflabel="autovacuum_freeze_max_age">
    <term><literal>autovacuum_freeze_max_age</literal>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_max_age</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-freeze-max-age"/> 설정.
      autovacuum 작업은 테이블 단위 개별 <literal>autovacuum_freeze_max_age</literal> 값이
      시스템 전역 설정값보다 큰 값으로 설정하면 무시한다는 점에 주의하십시오 (더 작은 값만 설정가능). 
         <literal>autovacuum_freeze_max_age</literal>를 매우 작은 값으로, 심지어 0으로도, 설정할 수 있지만,
         이는 빈번한 vacuum 수행을 강제하기 때문에, 이는 현명하지 못한 선택입니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-freeze-table-age" xreflabel="autovacuum_freeze_table_age">
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_table_age</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-vacuum-freeze-table-age"/> 설정.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-multixact-freeze-min-age" xreflabel="autovacuum_multixact_freeze_min_age">
    <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_min_age</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
       해당 테이블 단위 개별 <xref linkend="guc-vacuum-multixact-freeze-min-age"/> 설정.
       autovacuum 작업은 테이블 단위 개별 <literal>autovacuum_multixact_freeze_min_age</literal> 값이
       시스템 전역  <xref linkend="guc-autovacuum-multixact-freeze-max-age"/> 환경 설정값의 절반 보다
       큰 값이면 무시한다는 점에 주의하십시오. (더 작은 값만 설정가능)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-multixact-freeze-max-age" xreflabel="autovacuum_multixact_freeze_max_age">
    <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_max_age</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-autovacuum-multixact-freeze-max-age"/> 설정.
          autovacuum이 테이블 별 <literal>autovacuum_multixact_freeze_max_age</literal> 설정을
          범 시스템적 설정보다 크게 설정하려는 시도를 무시한다는 점에 주의하십시오 (더 작은 값만 설정가능).
      <literal>autovacuum_multixact_freeze_max_age</literal>을 매우 작은 값으로, 심지어 0으로도, 설정할 수 있지만,
      빈번한 vacuum 수행을 강제하기 때문에, 이는 현명하지 못한 선택입니다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-multixact-freeze-table-age" xreflabel="autovacuum_multixact_freeze_table_age">
    <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_table_age</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-vacuum-multixact-freeze-table-age"/> 설정.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-log-autovacuum-min-duration" xreflabel="log_autovacuum_min_duration">
    <term><literal>log_autovacuum_min_duration</literal>, <literal>toast.log_autovacuum_min_duration</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>log_autovacuum_min_duration</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
    <listitem>
     <para>
      해당 테이블 단위 개별 <xref linkend="guc-log-autovacuum-min-duration"/> 설정.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-user-catalog-table" xreflabel="user_catalog_table">
    <term><literal>user_catalog_table</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>user_catalog_table</varname> storage parameter</primary>
    </indexterm>
    </term>
    <listitem>
     <para>
      논리 복제를 위한 사용자 정의 카탈로그 테이블로 지정.
      자세한 내용은
      <xref linkend="logicaldecoding-capabilities"/> 참조.
      이 설정은 TOAST 테이블에는 지정할 수 없음.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="sql-createtable-notes">
  <title>참고</title>

    <para>
     <productname>PostgreSQL</productname>은 고유성을 강제하기 위해,
         각 unique 제약과 primary 제약에 대한 인덱스를 자동으로 생성합니다.
         때문에, primary key 열에 명시적으로 인덱스를 생성할 필요는 없습니다.
         (더 많은 정보는 <xref
     linkend="sql-createindex"/>를 참고하십시오.)
    </para>

    <para>
     현재 구현에서 unique 제약과 primary key는 상속되지 않습니다.
         이는 상속과 unique 제약과 결합되는 경우에 다소 문제가 될 수 있습니다.
    </para>

    <para>
     하나의 테이블이 가질 수 있는 열의 개수는 최대 1600개 입니다.
         (실질적인 유효 한계는, 튜플 길이 제약으로 인해 이보다 더 낮습니다.)
    </para>

 </refsect1>


 <refsect1 id="sql-createtable-examples">
  <title>예제</title>

  <para>
   <structname>films</structname> 테이블과 <structname>distributors</structname> 테이블을 생성:

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   2차원 배열을 갖는 테이블을 정의:

<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>

  <para>
   <literal>films</literal> 테이블에 대한 unique 제약을 정의.
   Unique 테이블 제약은 해당 테이블의 하나 이상의 열로 정의될 수 있습니다:

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>

  <para>
   Check 열 제약을 정의:

<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>

  <para>
   Check 테이블 제약을 정의:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   <structname>films</structname> 테이블에 대한 primary key 테이블 제약을 정의:

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>

  <para>
   <structname>distributors</structname> 테이블에 대한 Primary key 제약을 정의.
   다음 두 예제는 동일하며, 첫 번째 것은 테이블 제약 구문을 사용하고, 두 번째 것은 열 제약 구문을 사용:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>

  <para>
   <literal>name</literal> 열에 문자열 상수 기본값을 할당하고,
   <literal>did</literal> 열에 대한 기본 값으로 시퀀스 개체에서 다음번에 생성되는 값을 배치하며,
   <literal>modtime</literal>의 기본값이 행이 삽입된 시각이 되도록:

<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

  <para>
   <classname>distributors</classname> 테이블에 두 <literal>NOT NULL</literal> 열 제약을 정의.
   그 중 하나는 이름을 직접 지정:

<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>

    <para>
         <literal>name</literal> 열에 unique 제약을 지정:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>

     위와 동일하지만, 테이블 제약으로 지정:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>

  <para>
   같은 테이블을, 테이블과 unique index 양쪽에 70% fill factor를 정의하면서 생성:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>

  <para>
   두 원이 겹치지 않도록 하는 exclusion 제약과 함께
   <structname>circles</structname> 테이블을 생성:

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>

  <para>
   <structname>cinemas</structname> 테이블을 <structname>diskvol1</structname> 테이블스페이스에 생성:

<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>

  <para>
   복합 자료형과 Typed 테이블을 생성:
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>

  <para>
   Create a range partitioned table:
<programlisting>
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting></para>

  <para>
   Create a range partitioned table with multiple columns in the partition key:
<programlisting>
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</programlisting></para>

  <para>
   Create a list partitioned table:
<programlisting>
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</programlisting></para>

  <para>
   Create a hash partitioned table:
<programlisting>
CREATE TABLE orders (
    order_id     bigint not null,
    cust_id      bigint not null,
    status       text
) PARTITION BY HASH (order_id);
</programlisting></para>

  <para>
   Create partition of a range partitioned table:
<programlisting>
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

  <para>
   Create a few partitions of a range partitioned table with multiple
   columns in the partition key:
<programlisting>
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</programlisting></para>

  <para>
   Create partition of a list partitioned table:
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</programlisting></para>

  <para>
   Create partition of a list partitioned table that is itself further
   partitioned and then add a partition to it:
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</programlisting></para>

  <para>
   Create partitions of a hash partitioned table:
<programlisting>
CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>

  <para>
   Create a default partition:
<programlisting>
CREATE TABLE cities_partdef
    PARTITION OF cities DEFAULT;
</programlisting></para>

 </refsect1>

 <refsect1 id="sql-createtable-compatibility">
  <title id="sql-createtable-compatibility-title">호환성</title>

  <para>
   <command>CREATE TABLE</command> 명령은 아래에 나열된 예외를 제외하고,
   <acronym>SQL</acronym> 표준을 따릅니다.
  </para>

  <refsect2>
   <title>임시 테이블</title>

   <para>
    <literal>CREATE TEMPORARY TABLE</literal>구문이 SQL 표준과 닮아 있지만, 그 효과는 같지 않습니다.
        표준에서는, 임시 테이블이 한 번만 정의되고 이를 필요로 하는 모든 세션에 자동으로 (내용이 빈 상태부터) 존재하게 됩니다.
        <productname>PostgreSQL</productname>에서는 그 대신,
        각 세션에서 사용될 각 임시테이블에 대해,
        각자 <literal>CREATE TEMPORARY TABLE</literal> 명령을 발행하기를 요구합니다.
        이는 서로 다른 세션이 동일한 임시 테이블 명을 서로 다른 목적으로 사용할 수 있도록 해줍니다.
        반면에 표준 방식에서는 지정된 임시 테이블 명이 모든 인스턴스에서 동일한 테이블 구조를 갖도록 제약합니다.
   </para>

   <para>
    표준에서 정의한 임시 테이블 동작 방식이 상당 부분 무시됩니다.
        <productname>PostgreSQL</productname>에서 이 부분의 동작 방식은, 몇몇 다른 SQL 데이터베이스와 유사합니다.
   </para>

   <para>
    SQL 표준은 또한 전역과 지역 임시 테이블을 구분하고 있습니다.
        지역 임시테이블은, 세션 내부의 각각의 SQL 모듈에 대한 분리된 컨텐츠 집합을 갖고 있으며,
        다만, 그 정의를 세션 전체에 공유합니다.
        <productname>PostgreSQL</productname>이 SQL 모듈을 지원하지 않기 때문에,
        이러한 구별이 <productname>PostgreSQL</productname>에서는 의미가 없습니다.
   </para>

   <para>
        호환성을 위해서, <productname>PostgreSQL</productname>은 임시 테이블 선언부에
        <literal>GLOBAL</literal>과 <literal>LOCAL</literal> 키워드를 받을 수 있지만,
        현재 아무런 효과가 없습니다.
        <productname>PostgreSQL</productname>의 나중 버전에서
        이들의 의미에 대해 좀 더 표준에 부합하는 해석을 적용할 것이기 때문에,
        이 키워드를 사용하는 것을 권장하지 않습니다.
   </para>

   <para>
    임시 테이블에 대한 <literal>ON COMMIT</literal> 절은
        SQL 표준과 비슷하지만, 몇 가지 차이점이 있습니다.
        <literal>ON COMMIT</literal> 절이 생략된 경우, SQL 사양에서는 기본값이 <literal>ON COMMIT DELETE ROWS</literal>입니다. 
        하지만 <productname>PostgreSQL</productname>에서는 기본값이 
        ON <literal>COMMIT PRESERVE ROWS</literal>입니다.
        SQL 표준에 <literal>ON COMMIT DROP</literal> 옵션은 존재하지 않습니다.
   </para>
  </refsect2>

  <refsect2>
   <title>Non-Deferred Uniqueness Constraints</title>

   <para>
    <literal>UNIQUE</literal>나 <literal>PRIMARY KEY</literal> 제약이 not deferrable이면,
        <productname>PostgreSQL</productname>는 
        행이 추가되거나 수정될 때마다 즉시 고유성(uniqueness)을 검사합니다.
        SQL 표준에서는 고유성이 문장의 마지막에만 강제되어야 한다고 합니다.
        이는, 예를 들면, 단일 명령으로 여러 개의 키 값을 변경할 때, 차이가 납니다.
        표준에 부합하도록 하려면, 제약조건을 deferred (즉, <literal>INITIALLY IMMEDIATE</literal>)가 아닌 
        <literal>DEFERRABLE</literal>로 선언하십시오.
        이 경우, 고유성을 즉시 검사하는 것에 비해 상당히 느려진다는 점에 주의하십시오.
   </para>
  </refsect2>

  <refsect2>
   <title>열 Check 제약</title>

   <para>
    SQL 표준은 <literal>CHECK</literal> 열 제약이, 해당 열만 참조할 수 있다고 합니다.
        즉, <literal>CHECK</literal> 테이블 제약만이 여러 열을 참조할 수 있습니다.
        <productname>PostgreSQL</productname>는 이 규칙을 강제하지 않습니다.
        즉, 열과 테이블 check 제약을 동일하게 취급합니다.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>EXCLUDE</literal> 제약</title>

   <para>
    <literal>EXCLUDE</literal> 제약 유형은 <productname>PostgreSQL</productname>의 확장입니다.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>NULL</literal> <quote>제약</quote></title>

   <para>
    <literal>NULL</literal> <quote>제약</quote> (실은 제약이 아니지만)은
        몇몇 다른 데이터베이스와의 호환을 위해        (그리고, <literal>NOT NULL</literal> 제약과의 균형을 위해) 포함된,
        SQL 표준에 대한 <productname>PostgreSQL</productname> 확장입니다.
        이는 모든 열에 대한 기본값이기 때문에, 이것은 단지 귀찮은 정도의 존재 의미를 갖습니다.
   </para>
  </refsect2>

  <refsect2>
   <title>Constraint Naming</title>

   <para>
    The SQL standard says that table and domain constraints must have names
    that are unique across the schema containing the table or domain.
    <productname>PostgreSQL</productname> is laxer: it only requires
    constraint names to be unique across the constraints attached to a
    particular table or domain.  However, this extra freedom does not exist
    for index-based constraints (<literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal>
    constraints), because the associated index is named the same as the
    constraint, and index names must be unique across all relations within
    the same schema.
   </para>

   <para>
    Currently, <productname>PostgreSQL</productname> does not record names
    for <literal>NOT NULL</literal> constraints at all, so they are not
    subject to the uniqueness restriction.  This might change in a future
    release.
   </para>
  </refsect2>

  <refsect2>
   <title>상속</title>

   <para>
    <literal>INHERITS</literal>절을 통해 다중 상속하는 것은,
        <productname>PostgreSQL</productname> 언어 확장입니다.
        SQL:1999 이후 버전에서 이와 다른 구문과 문장(semantics)으로 단일 상속을 정의하고 있습니다.
        SQL:1999 스타일의 상속은 <productname>PostgreSQL</productname>에서 아직 지원되지 않습니다.
   </para>
  </refsect2>

  <refsect2>
   <title>열이 없는 테이블(Zero-Column Table)</title>

   <para>
    <productname>PostgreSQL</productname>는 열이 없는 테이블을 생성할 수 있습니다.
        (예를들면, <literal>CREATE TABLE foo();</literal>). 
        이는 열이 없는 테이블을 허용하지 않는 SQL 표준을 확장한 것입니다.
        열이 없는 테이블은 그 자체로는 별로 쓸모가 없지만, 이를 허용하지 않는 경우
        <command>ALTER TABLE DROP COLUMN</command>에서 특이 상황이 발생합니다.
        때문에 이 제약은 무시 하는게 더 깔끔해 보입니다.
   </para>
  </refsect2>

  <refsect2>
   <title>Multiple Identity Columns</title>

   <para>
    <productname>PostgreSQL</productname> allows a table to have more than one
    identity column.  The standard specifies that a table can have at most one
    identity column.  This is relaxed mainly to give more flexibility for
    doing schema changes or migrations.  Note that
    the <command>INSERT</command> command supports only one override clause
    that applies to the entire statement, so having multiple identity columns
    with different behaviors is not well supported.
   </para>
  </refsect2>

  <refsect2>
   <title>Generated Columns</title>

   <para>
    The option <literal>STORED</literal> is not standard but is also used by
    other SQL implementations.  The SQL standard does not specify the storage
    of generated columns.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>LIKE</literal> 절</title>

   <para>
    <literal>LIKE</literal> 절은 표준 SQL 구문이지만, 
    <productname>PostgreSQL</productname>에서는 표준에서 정의하지 않은
    많은 옵션들을 제공한다. 또한 표준 SQL 구문에서 요구하는 
    다른 옵션들이 아직 구현 되지 않은 것도 있다.
   </para>
  </refsect2>


  <refsect2>
   <title><literal>WITH</literal> 절</title>

   <para>
    <literal>WITH</literal>절은 <productname>PostgreSQL</productname>의 확장입니다.
        Storage parameters 설정은 표준에는 없습니다.
   </para>
  </refsect2>

  <refsect2>
   <title>Tablespaces</title>

   <para>
    <productname>PostgreSQL</productname> 개념의 테이블 스페이스는 표준에 포함되어 있지 않습니다.
        이러한 이유로, <literal>TABLESPACE</literal>와 
        <literal>USING INDEX TABLESPACE</literal>절은 확장입니다.
   </para>
  </refsect2>

  <refsect2>
   <title>Typed Tables</title>

   <para>
    Typed table은 SQL 표준의 subset을 구현합니다.
        표준에 따라, typed 테이블은 내재된 복합 자료형과 관련된 열과 더불어,
        <quote>자기-참조 열</quote>과 관련된 열을 하나 더 갖고 있습니다.
        PostgreSQL은 이 자기-참조열을 명시적으로 지원하지 않습니다.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>PARTITION BY</literal> Clause</title>

   <para>
    The <literal>PARTITION BY</literal> clause is a
    <productname>PostgreSQL</productname> extension.
   </para>
  </refsect2>

  <refsect2>
   <title><literal>PARTITION OF</literal> Clause</title>

   <para>
    The <literal>PARTITION OF</literal> clause is a
    <productname>PostgreSQL</productname> extension.
   </para>
  </refsect2>

 </refsect1>


 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"/></member>
   <member><xref linkend="sql-droptable"/></member>
   <member><xref linkend="sql-createtableas"/></member>
   <member><xref linkend="sql-createtablespace"/></member>
   <member><xref linkend="sql-createtype"/></member>
  </simplelist>
 </refsect1>
</refentry>
