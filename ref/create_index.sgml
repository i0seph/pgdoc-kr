<!--
doc/src/sgml/ref/create_index.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEINDEX">
 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE INDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>새 인덱스 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class="parameter">이름</replaceable> ] ON <replaceable class="parameter">테이블이름</replaceable> [ USING <replaceable class="parameter">색인방법</replaceable> ]
    ( { <replaceable class="parameter">칼럼이름</replaceable> | ( <replaceable class="parameter">표현식</replaceable> ) } [ COLLATE <replaceable class="parameter">문자정렬규칙</replaceable> ] [ <replaceable class="parameter">연산자클래스</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <replaceable class="PARAMETER">저장_매개변수</replaceable> = <replaceable class="PARAMETER">값</replaceable> [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">테이블스페이스이름</replaceable> ]
    [ WHERE <replaceable class="parameter">조건절</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>설명</title>

  <para>
   <command>CREATE INDEX</command> 명령은 
   해당 릴레이션 (테이블이나 구체화한 뷰)의 특정 칼럼을 기준으로
   인덱스를 만든다.  인덱스를 만드는 첫번째 목적은 데이터베이스 성능을
   높이는데 있다. (물론 잘못 사용하면 성능을 떨어뜨리기도 한다.)
  </para>

  <para>
   인덱스 키 필드는 칼럼 이름이나, 어떤 계산식을 사용한다.
   색인 방법이 다중 칼럼 인덱스를 지원하면, 다중 필드를 
   지정해서 인덱스를 만들 수 있다.
   (색인 방법: btree, hash ... 이런 인덱스 종류를 말한다 - 옮긴이)
  </para>

  <para>
   인덱스 필드로 사용할 수 있는 계산식은 그 계산 결과가 인덱스 
   자료로 사용되는 것이다. 그 계산 되는 자료는 테이블의 특정
   칼럼일 수도 있고, 여러 칼럼일 수도 있다.  이 기능은
   조회 쿼리에서 어떤 계산식에 의한 결과를 빠르게 찾는데 
   도움을 준다.  예를 들어, 대소문자를 구분하지 않고, 
   무조건 대문자로 어떤 자료를 찾으려고 할때, 
   인덱스 필드로 <literal>upper(col)</> 계산식을 사용해서 
   인덱스를 만들고, 조회 쿼리에서 <literal>WHERE upper(col) = 'JIM'</>
   구문을 사용하면, 그 인덱스를 사용할 수 있다.
  </para>

  <para>
   <productname>PostgreSQL</productname>에서 기본 제공하는 색인 방법은
   B-tree, hash, GiST, SP-GiST, GIN, BRIN 이다.
   또한 사용자가 직접 이 색인 방법을 만들어 사용할 수 있지만,
   상당히 복잡한 과정을 거친다.
  </para>

  <para>
    인덱스를 만드는 구문에서 <literal>WHERE</literal> 조건절을 
    사용해서 <firstterm>부분 인덱스</firstterm>를 만들 수도 있다.
    부분 인덱스란 테이블 전체 자료를 대상으로 하지 않고, 
    특정 부분 자료를 대상으로 인덱스를 만드는 것이다.
    예를 들어, 주문 테이블에서 청구 상태 기준으로 미청구 주문이
    적고, 청구 주문이 많은데, 업무에서는 이 미청구 주문을 대상으로 하는
    작업이 많은 경우, 인덱스를 미청구 주문을 대상으로만 만들어
    성능을 높일 수 있다. (인덱스 크기가 줄어들 것이며, 그 만큼 
    디스크 사용량이 줄기 때문이다 - 옮긴이)
    또 다른 사용법으로, <literal>UNIQUE</literal> 인덱스를 만들 수 없는
    자료인데, <literal>WHERE</literal> 조건절을 이용해서, 
    유일성을 보장하는 인덱스로 만들어 사용하는 것이다. 이 부분은
    <xref linkend="indexes-partial">에서 자세히 다룬다.
  </para>

  <para>
    단순 인덱스는 단일, 또는 지정한 칼럼들만 대상으로 하지만,
    <literal>WHERE</literal> 조건절을 하면 그 인덱스용 칼럼 뿐만 아니라,
    그 외 칼럼들에 대해서도 조건을 적용할 수 있어 꽤 유용하다. 
    현재, 이 <literal>WHERE</literal> 조건절에서는 서브쿼리와
    집계 작업용 계산식은 사용할 수 없다.
    이 제약은 인덱스 칼럼 대신 사용할 수 있는 계산식에서도 
    같다.
  </para>

  <para>
   인덱스를 만들 때 사용하는 함수나 연산자는 반드시 <quote>immutable</>
   속성이 있어야 하는 것이여야 한다.
   이 속성은 입력에 대한 출력값이 항상 같다는 것을 뜻한다(어떤
   테이블을 참조하거나, 현재 시간을 출력하는 작업은 이런 경우가 
   아니다).  이렇게 <quote>immutable</> 속성이 있어야
   인덱스 역할을 제대로 하기 때문이다.  사용자 정의 함수를 사용해서
   인덱스 필드로 사용하거나,  <literal>WHERE</literal> 조건절에서
   사용하려고 한다면, 반드시 이 점을 기억해야 한다.
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
       <para>
        유니크 인덱스를 만들 때 사용.
        해당 필드 값은 해당 테이블에 유일하게 있어야 함을 뜻한다.
        같은 자료를 입력 하거나, 이미 있는 값으로 바꾸려고 하면 오류로 처리한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONCURRENTLY</literal></term>
      <listitem>
       <para>
        이 옵션을 사용하면, <productname>PostgreSQL</> 서버는
        해당 테이블의 insert, update, delete 작업을 허용하면서
        인덱스를 만든다.  일반적 인덱스 만들기는 해당 테이블을 읽기 전용으로
        잠근다.
        이 옵션을 사용할 때는 여러 제약 조건들이 있다.
        이 옵션을 사용하려면  <xref linkend="SQL-CREATEINDEX-CONCURRENTLY"
        endterm="SQL-CREATEINDEX-CONCURRENTLY-title"> 설명서를
        꼭 읽고 사용해야 한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IF NOT EXISTS</literal></term>
      <listitem>
       <para>
        해당 이름과 같은 인덱스가 이미 있어도 오류로 처리하지 않고, 
        알림 메시지만 보여주고 마친다.  물론 같은 이름의 개체가
        정확히 같은 인덱스인지는 확인하지 않는다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">이름</replaceable></term>
      <listitem>
       <para>
        새로 만들 인덱스 이름.
        이 이름에는 스키마 이름을 지정하지 않는다.  인덱스의 소속 스키마는
        항상 그 테이블의 스키마와 같기 때문이다.
        이 이름을 생략하는 경우, <productname>PostgreSQL</>에서는
        해당 테이블과 해당 칼럼 이름의 조함으로 이 인덱스 이름을 
        자동으로 만들어 사용한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">테이블이름</replaceable></term>
      <listitem>
       <para>
        대상 테이블 이름. (스키마 이름 포함)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">색인방법</replaceable></term>
      <listitem>
       <para>
        해당 인덱스의 색인 방법을 지정한다. 사용할 수 있는 값:
        <literal>btree</literal>, <literal>hash</literal>,
        <literal>gist</literal>, <literal>spgist</>, <literal>gin</>, 
        <literal>brin</>.
        <literal>btree</literal>가 기본값이다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">칼럼이름</replaceable></term>
      <listitem>
       <para>
        해당 테이블의 칼럼 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">표현식</replaceable></term>
      <listitem>
       <para>
        하나의 표현식은 해당 테이블의 하나 또는 그 이상의 칼럼을 
        기반으로 한다.  표현식은 일반적으로 괄호로 둘러싼다.
        한 함수만 호출하는 식이라면, 그럴 필요는 없다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">문자정렬규칙</replaceable></term>
      <listitem>
       <para>
        해당 인덱스가 문자열 자료를 대상으로 한다면, 
        그 자료의 정렬 규칙을 지정한다.  기본적으로
        그 해당 자료의 자료형 기본 문자 정렬 규칙을 사용한다.
        이 옵션을 사용해서 특정 정렬 규칙을 사용했다면,
        조회 쿼리에서도 이 정렬 규칙을 지정해야, 
        만든 인덱스를 사용해서 조회 작업을 진행한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">연산자클래스</replaceable></term>
      <listitem>
       <para>
        연산자 클래스 이름. 아래에서 설명함.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ASC</></term>
      <listitem>
       <para>
        오름 차순 정렬 (기본값).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DESC</></term>
      <listitem>
       <para>
        내림 차순 정렬.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS FIRST</></term>
      <listitem>
       <para>
        null 값 먼저 정렬. <literal>DESC</> 인덱스인 경우는 기본값.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS LAST</></term>
      <listitem>
       <para>
        null 값 나중에 정렬. <literal>DESC</> 옵션을 지정하지 않은
        인덱스인 경우는 기본값.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">저장_매개변수</replaceable></term>
      <listitem>
       <para>
        색인 방법에서 사용하는 저장 매개 변수 이름.
        <xref linkend="sql-createindex-storage-parameters" endterm="sql-createindex-storage-parameters-title"> 참조.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">테이블스페이스이름</replaceable></term>
      <listitem>
       <para>
        이 인덱스가 저장될 테이블스페이스 이름.  지정하지 않으면,
        <xref linkend="guc-default-tablespace"> 설정값의 테이블스페이스가
        사용되며, 임시 테이블의 인덱스라면, 
        <xref linkend="guc-temp-tablespaces"> 설정값의 테이블스페이스가
        사용된다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">조건절</replaceable></term>
      <listitem>
       <para>
        부분 인덱스를 만들 조건절 표현식.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  <refsect2 id="SQL-CREATEINDEX-storage-parameters">
   <title id="SQL-CREATEINDEX-storage-parameters-title">인덱스 저장 매개 변수</title>

   <para>
    <literal>WITH</> 옵션을 이용해서, 
    인덱스용 <firstterm>저장 매개 변수</firstterm> 값을 지정할 수 있다.
    각 색인 방법은 그들만의 고유 매개 변수도 있다.
    다음은 B-tree, hash, GiST, SP-GiST 색인 방법에서 공통으로 사용할 수 있는 
    매개 변수다:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>fillfactor</></term>
    <listitem>
     <para>
      fillfactor 변수는 인덱스 페이지에 얼마만큼의 자료를 보관할 것인지를
      퍼센트 값으로 지정한다.  B-tree 인덱스인 경우
      초기 인덱스를 만들 때, 리프 페이지는 이 값 만큼만 자료를 채운다.
      또한 인덱스 오른쪽(가장 큰 값을 처리하는 경우)에 자료를 채울 때도
      이 값 기준으로 처리된다.
      인덱스 페이지가 꽉 차면, 그 페이지는 나뉜다.  이런 작업으로 
      인덱스 효율성은 점점 떨어지게 된다.  B-tree 인덱스의 fillfactor 기본값은
      90이며, 10부터 100까지 지정할 수 있다.
      테이블의 자료가 더 이상 바뀌지 않는다면, 100으로 설정해서 
      물리적인 인덱스 크기를 최소화 할 수 있지만, 
      잦은 자료 변경이 있다면, 이 값을 줄여 인덱스 페이지 분기 작업을 
      최소화 하는 것이 더 효율적인다.
      다른 색인 방법에서는 fillfactor 기본값이 각각 다르지만, 
      대략 비슷한 방법으로 이 값을 사용한다.  
     </para>
    </listitem>
   </varlistentry>
   </variablelist>

   <para>
    GiST 인덱스에서는 추가적으로 다음 매개 변수를 사용할 수 있다:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>buffering</></term>
    <listitem>
    <para>
     인덱스를 만들 때, 
     <xref linkend="gist-buffering-build">에서 설명하고 있는 
     버퍼링 빌드 방법을 사용할지를 지정한다.
     <literal>OFF</>면 사용 하지 않고, <literal>ON</>이면 사용한다,
     <literal>AUTO</>면 사용하고 있지 않다가, 인덱스 크기가
     <xref linkend="guc-effective-cache-size"> 값보다 커지만
     활성화 된다. 기본값은 <literal>AUTO</>.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

   <para>
    GIN 인덱스에서는 다음 매개 변수들을 사용할 수 있다:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>fastupdate</></term>
    <listitem>
    <para>
     <xref linkend="gin-fast-update">에서 설명하고 있는 
     자동 업데이트 기능을 사용할 것인지를 지정한다.
     값은 불리언형으로 <literal>ON</>이면 활성화, <literal>OFF</>면
     비활성화한다.
     (이 값은 <xref linkend="config-setting">에서 설명하는 것 처럼
      허용 가능한 다른 값으로 지정해도 된다.)
     기본값은 <literal>ON</>.
    </para>

    <note>
     <para>
      <command>ALTER INDEX</> 명령으로 <literal>fastupdate</> 설정값을 
      off로 하면 그 작업 뒤 발생하는 인덱스 작업은 적용되지만, 
      기존 이미 인덱스 작업된 자료에 대해서는 반영하지 않는다.
      해당 인덱스 전체를 대상으로 재반영하려면,
      <command>VACUUM</> 명령이나, <function>gin_clean_pending_list</>
      함수를 호출 해서 반영해야 한다.
     </para>
    </note>
    </listitem>
   </varlistentry>
   </variablelist>
   <variablelist>
   <varlistentry>
    <term><literal>gin_pending_list_limit</></term>
    <listitem>
    <para>
     해당 인덱스 개별 <xref linkend="guc-gin-pending-list-limit"> 매개 변수값
     지정.  단위는 킬로바이트다.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

   <para>
    <acronym>BRIN</> 인덱스에서 다음 매개 변수들을 사용할 수 있다:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>pages_per_range</></term>
    <listitem>
    <para>
     하나의 <acronym>BRIN</> 인덱스 페이지에서 다루는 
     테이블 블럭 수(<xref linkend="brin-intro"> 참조).
     기본값은 <literal>128</>.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autosummarize</></term>
    <listitem>
    <para>
     다음 페이지 대상으로 insert 작업이 있으면,
     이전 페이지 범위에 대한 자동 요약 작업을 할지 지정 한다.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>
  </refsect2>

  <refsect2 id="SQL-CREATEINDEX-CONCURRENTLY">
   <title id="SQL-CREATEINDEX-CONCURRENTLY-title">테이블을 잠그지 않는 인덱스 만들기</title>

   <indexterm zone="SQL-CREATEINDEX-CONCURRENTLY">
   <primary>index</primary>
   <secondary>테이블을 잠그지 않고 만들기</secondary>
   </indexterm>

   <para>
    인덱스를 만드는 작업은 데이터베이스 일반적인 작업을 방해할 수 있다.
    <productname>PostgreSQL</>에서는 인덱스를 만드는 중에는
    그 테이블에 대해서 쓰기가 금지 된다.
    이것이 기본 특성이다.  물론 읽기 작업은 가능하지만, 
    insert, update, delete 작업은 그 인덱스가 다 만들어지기 전까지 
    대기한다.  운영 환경이라면, 이 특성은 여러 문제점을 일으킬 수 있다.
    해당 테이블이 아주 큰 테이블이라면, 인덱스 만드는 작업은 몇 시간이
    걸릴 수도 있다.  이런 경우, 그 시간 동안 서비스를 정상적으로
    제공한다는 것은 무리다.
   </para>

   <para>
    이런 문제를 해결하기 위해, <productname>PostgreSQL</>에서는
    테이블을 잠그지 않고, 인덱스를 만들 수 있는 방법을 제공한다.
    <command>CREATE INDEX</> 명령에서 <literal>CONCURRENTLY</> 옵션을 
    사용하는 것이다.
    이 옵션을 사용하면, <productname>PostgreSQL</> 서버는
    해당 테이블에 대해서 두 번 탐색한다.  또한, 이 인덱스 작업을 시작하기
    전 수행된 자료 조작 트랜잭션들이 모두 종료 될 때까지 기다렸다가
    작업을 진행한다. (명령을 실행하고, 다른 세션에서 이 명령으로
    인덱스 만들기 작업을 시작했는지, 다른 트랜잭션들 때문에 이 명령이
    대기 중인지 확인할 필요가 있다. - 옮긴이)
    이런 이유로, (테이블을 잠그는) 일반적인 인덱스 만들기보다 
    시간이 더 많이 걸린다.
    하지만, 이렇게 인덱스를 만들면, 만드는 동안에도 일반적인 작업들을 
    할 수 있어, 운영 환경에서 새 인덱스를 만들 때 유용하게 쓰인다. 
    물론 인덱스 만드는 작업에 따른 CPU, I/O 추가 비용은 발생하고, 
    이 때문에, 다른 작업들이 느려질 수 있다.
   </para>

   <para>
    이 테이블을 잠그지 않는 인덱스 만들기는 하나의 트랜잭션으로
    해당 인덱스가 시스템 카탈로그에 추가되고, 다음, 
    두번의 테이블 탐색 작업은 두 개 이상의 트랜잭션으로 처리된다.
    첫번째 테이블 탐색 전에, 인덱스 만들기 작업은  이미 있는,
    해당 테이블 대상 변경 작업용 모든 트랜잭션이 종료되기를 기다린다.
    두번째 테이블 탐색 후에,  인덱스 만들기 작업은, 
    이 테이블 탐색이 끝나기 전에 만들어진 모든 스냅샷 트랜잭션
    (<xref linkend="mvcc"> 참고)이 종료 되기를 기다린다.
    모든 작업이 완료되면, 해당 인덱스를 사용 가능한 인덱스로 표시하고,
    <command>CREATE INDEX</> 명령을 종료한다.
    하지만, 그 인덱스가 즉시 쿼리에서 사용되지 않을 수도 있다:
    최악의 경우는 해당 테이블을 사용하는 트랜잭션이 제때에 종료되지 않아, 
    아에 해당 인덱스를 사용하지 못하는 상황이 발생할 수도 있다.
   </para>

   <para>
    인덱스 만들기 작업 중 교착상태 deadlock나 유니크 제약 조건 위반 같은 
    문제가 발생하면, 그 작업은 중지된다. 하지만, 
    이 때 해당 인덱스를 없애는 것이 아니라, 
    <quote>INVALID</> 인덱스로 남겨둔다.  이 인덱스는 불완적한 것이기 
    때문에 쿼리에서 사용되지는 않지만, 인덱스 변경 작업은 계속 되어
    불필요한 비용이 발생한다.  <application>psql</>에서
    이런 잘못된 인덱스를 확인하는 방법은 <command>\d</> 명령 결과에서
    인덱스 설명에 <literal>INVALID</>가 있는지 확인하는 것이다.

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 col    | integer |           |          | 
Indexes:
    "idx" btree (col) INVALID
</programlisting>

    이런 경우 복구 방법은 해당 인덱스를 지우고, 
    다시 <command>CREATE INDEX CONCURRENTLY</> 명령을 실행하는 것이다.
    (다른 방법은 <command>REINDEX</> 명령을 사용하는 것인데, 
    <command>REINDEX</> 명령은 테이블을 잠그기 때문에 잘 판단 해야 한다.)
   </para>

   <para>
    테이블을 잠그지 않고, 유니크 인덱스를 만들 때 주의해야할 또 다른 사항은,
    두번째 테이블 탐색 전에 이미 다른 트랜잭션에서 유니크 제약 조건을 
    위반하는 경우가 발생할 수 있다는 것이다.
    인덱스를 만들고 유효한 인덱스로 표시하기 전이나, 
    아니면, 아에 인덱스를 만들기 작업 실패로 처리하기 전에, 
    다른 쿼리에서 유니크 제약 조건 위반 오류가 발생할 수 있다.
    또한, 이 실패가 두번째 탐색 작업 중에 발생하면, 
    이 <quote>잘못된</> 인덱스 때문에, 향후 계속 해서 
    유니크 제약 조건 위반 문제가 발생할 수도 있다.
   </para>

   <para>
    표현식 기반 인덱스나 부분 인덱스도 해당 테이블을 잠그지 않고 
    만들수 있다.  이 때도 유니크 제약 조건 문제처럼 이 비슷한 문제가 
    생길 수 있기 때문에 주의해야 한다.
   </para>

   <para>
    테이블을 잠그는 일반 인덱스 만들기는 동일 테이블에 대해서
    여러 인덱스를 동시에 만들 수 있지만, 
    테이블을 잠그지 않는 인덱스 만들기는 한 테이블에 대해서
    하나의 인덱스만 만들 수 있다.  모든 인덱스 만들기 작업 중에는
    테이블 정의 변경 작업은 불가능하다.
    테이블을 잠그는 일반 인덱스 만들기는 트랜잭션 내에서 사용할 수 
    있지만, 테이블을 잠그지 않는 인덱스 만들기는 트랜잭션 내에서 
    사용할 수 없다.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>참고</title>

  <para>
   어떤 경우는 인덱스를 사용하고, 어떤 경우는 인덱스를 사용하지 않는지,
   이런 개별 상황에 대한 자세한 설명은 <xref linkend="indexes">에서
   자세히 다룬다.
  </para>

  <para>
   현재, B-tree, GiST, GIN, BRIN 인덱스만 다중 칼럼 인덱스를 
   만들 수 있다.  최대 32 개까지만 허용한다.
   (이 값은 <productname>PostgreSQL</productname> 빌드 때 바꿀 수 있다.)
   현재, B-tree 인덱스만 유니크 인덱스를 만들 수 있다.
  </para>

  <para>
   인덱스를 만들 때, <firstterm>연산자 클래스</firstterm>를 지정할 수
   있다.  연산자 클래스란 해당 칼럼용 인덱스에서 사용되는 연산자 
   식별자다.  예를 들어, 4 바이트 정수 칼럼이라면, 
   <literal>int4_ops</literal> 연산자 클래스가 사용된다.  이 연산자
   클래스에 4 바이트 정수 비교 함수가 포함되어있다.
   일반적으로 해당 자료형에 대한 기본 연산자 클래스를 사용한다.
   이 연산자 클래스를 지정하는 경우는 특정 자료형에 대해서 
   독특한 연산으로 검색하고자 할 때 사용한다.  예를 들어, 
   복소수 자료인 경우, 그 절대값이나, 실수부만 대상으로 자료를 
   정렬하려고 할 때 그에 맞는 연산자를 클래스를 지정해서 인덱스를
   만든다.  또한 하나의 인덱스 대상에 대해서 각각 다른 
   연산자 클래스를 지정해서 여러 개의 인덱스를 만들 수 있으며, 
   이 경우 실행 계획기에는 상황에 맞게 해당 인덱스를 선택해서 
   작업한다.
   연산자 클래스에 대한 자세한 정보는
   <xref linkend="indexes-opclass">과 <xref
   linkend="xindex">에서 다룬다.
  </para>

  <para>
   현재 B-tree 색인 방법을 사용하는 경우에만
   <literal>ASC</>, <literal>DESC</>, <literal>NULLS
   FIRST</>, <literal>NULLS LAST</> 옵션을 사용할 수 있다.
   실행 계획에 따라 인덱스 순방향, 역방향 검색이 모두 가능하기 
   때문에, 단일 칼럼 인덱스에서는 <literal>DESC</> 옵션을 사용할 
   필요는 없다 &mdash; 이 경우는 이미 그 옵션이 없어도 잘 사용할 수 있다.
   이 옵션은 <literal>SELECT ... ORDER BY x ASC, y
   DESC</> 형태의 쿼리와 같이 다중 칼럼을 사용하고, 그 정렬 방법이 
   다른 경우에 쓰인다.  <literal>NULLS</> 옵션은 null 값 자료 출력 위치를
   변경 해야 하는 경우에 사용된다.
  </para>

  <para>
   대부분의 색인 방법은 <xref linkend="guc-maintenance-work-mem">
   설정값에 따라 인덱스 만드는 속도가 달라진다.
   이 설정값이 크면 그 만큼 인덱스 만드는 속도가 빨라 진다.
   물론 너무 크게 지정해서 시스템 스왑 메모리를 사용한다면, 
   속도를 보장하지는 못한다.
  </para>

  <para>
   인덱스를 지울 때는 <xref linkend="sql-dropindex"> 명령을 이용한다.
  </para>

  <para>
   이전 <productname>PostgreSQL</productname>에서는 R-tree 인덱스도
   있었으나, GiST 인덱스가 더 좋아 이제는 사용하지 않는다.
   <literal>USING rtree</> 옵션을 사용하면, <command>CREATE INDEX</>
   명령은 자동으로 <literal>USING gist</> 바꿔 명령이 실행된다.
  </para>
 </refsect1>

 <refsect1>
  <title>예제</title>

  <para>
   <literal>films</literal> 테이블 <literal>title</literal> 칼럼
   대상 B-tree 인덱스를 만드는 경우:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

  <para>
   대소문자 구분 없이 검색하기 위해 <literal>lower(title)</>
   표현식으로 인덱스를 만드는 경우:
<programlisting>
CREATE INDEX ON films ((lower(title)));
</programlisting>
   (이 때 인덱스 이름을 지정하지 않았기 때문에, 서버에서
   자동으로 그 이름을 짓는다.   윗 경우라면 
   <literal>films_lower_idx</> 형식의 이름이 사용된다.)
  </para>

  <para>
   문자 정렬 규칙을 바꿔 인덱스를 만드는 경우:
<programlisting>
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
</programlisting>
  </para>

  <para>
   null 값 순서를 바꿔 인덱스를 만드는 경우:
<programlisting>
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
</programlisting>
  </para>

  <para>
   fillfactor 값을 바꿔 인덱스를 만드는 경우:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>

  <para>
   fastupdate 기능을 끄고, <acronym>GIN</> 색인 방법으로 인덱스를 만드는 경우:
<programlisting>
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
</programlisting>
  </para>

  <para>
   테이블스페이스를 지정한 경우:
<programlisting>
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
</programlisting>
  </para>

  <para>
   지점 정보를 박스 공간으로 바꿔 그것을 GiST 인덱스로 만들고,
   그 인덱스를 이용해서 자료를 찾는 경우:
<programlisting>
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;
</programlisting>
  </para>

  <para>
   해당 테이블 대상 DML 쿼리를 허용하면서 인덱스를 만드는 경우:
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting></para>

 </refsect1>

 <refsect1>
  <title>호환성</title>

  <para>
   <command>CREATE INDEX</command> 구문은 
   <productname>PostgreSQL</productname> 확장 구문이다.  표준
   SQL에는 인덱스 관련 구문이 없다.
  </para>
 </refsect1>

 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"></member>
   <member><xref linkend="sql-dropindex"></member>
  </simplelist>
 </refsect1>
</refentry>
