<!--
doc/src/sgml/ref/alter_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-altertable">
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>테이블 정의 바꾸기</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">이름</replaceable> [ * ]
    <replaceable class="parameter">작업</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">이름</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> TO <replaceable class="parameter">새칼럼이름</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">이름</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">제약조건이름</replaceable> TO <replaceable class="parameter">새제약조건이름</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">이름</replaceable>
    RENAME TO <replaceable class="parameter">새이름</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">이름</replaceable>
    SET SCHEMA <replaceable class="parameter">새스키마</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">이름</replaceable> [ OWNED BY <replaceable class="parameter">롤이름</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">새테이블스페이스</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">이름</replaceable>
    ATTACH PARTITION <replaceable class="parameter">파티션이름</replaceable> { FOR VALUES <replaceable class="parameter">파티션범위명세</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">이름</replaceable>
    DETACH PARTITION <replaceable class="parameter">파티션이름</replaceable>

<phrase><replaceable class="parameter">작업</replaceable> 자리에는:</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">칼럼이름</replaceable> <replaceable class="parameter">자료형</replaceable> [ COLLATE <replaceable class="parameter">문자정렬규칙</replaceable> ] [ <replaceable class="parameter">칼럼제약조건</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">칼럼이름</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">자료형</replaceable> [ COLLATE <replaceable class="parameter">문자정렬규칙</replaceable> ] [ USING <replaceable class="parameter">표현식</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> SET DEFAULT <replaceable class="parameter">표현식</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> DROP EXPRESSION [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>시퀀스옵션</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>시퀀스옵션</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">재시작값</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> SET STATISTICS <replaceable class="parameter">정수</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> SET ( <replaceable class="parameter">속성옵션</replaceable> = <replaceable class="parameter">값</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> RESET ( <replaceable class="parameter">속성옵션</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">칼럼이름</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">테이블제약조건</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">인덱스를_사용하는_제약조건</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">제약조건이름</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="parameter">제약조건이름</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">제약조건이름</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">트리거이름</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">트리거이름</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">트리거이름</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">트리거이름</replaceable>
    DISABLE RULE <replaceable class="parameter">룰이름</replaceable>
    ENABLE RULE <replaceable class="parameter">룰이름</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">룰이름</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">룰이름</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">인덱스이름</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET TABLESPACE <replaceable class="parameter">새테이블스페이스</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">저장_매개변수</replaceable> [= <replaceable class="parameter">값</replaceable>] [, ... ] )
    RESET ( <replaceable class="parameter">저장_매개변수</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">상위테이블</replaceable>
    NO INHERIT <replaceable class="parameter">상위테이블</replaceable>
    OF <replaceable class="parameter">자료형이름</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">새소유주</replaceable> | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">인덱스이름</replaceable> | FULL | NOTHING }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase>and <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">인덱스를_사용하는_제약조건</replaceable> 자리에는:</phrase>

    [ CONSTRAINT <replaceable class="parameter">제약조건이름</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">인덱스이름</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>설명</title>

  <para>
   <command>ALTER TABLE</command> 명령은 테이블 정의를 바꾼다.
   여러 구문이 있으며, 아래에서 설명한다.  이 명령을 실행하면,
   그 작업 성격에 맞는 수준의 잠금이 일어난다는 것을 꼭 기억해야 한다.
   이 잠금에 대해서 특별히 언급하지 않으면, 대부분 작업은 
   <literal>ACCESS EXCLUSIVE</literal> 수준으로 테이블을 잠근다.
   (다른 세션에서는 해당 테이블을 접근 조차 못한다 - 옮긴이)
   여러 작업들을 함께 작업하도록 명령을 구성하면,
   그 하위 작업들 가운데, 가장 엄격한 수준의 잠금을 사용한다.

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN [ IF NOT EXISTS ]</literal></term>
    <listitem>
     <para>
      해당 테이블에 새 칼럼을 추가하는 구문이다.  문법은
      <xref linkend="sql-createtable"/> 명령에서 사용하는 것과 같다.
      <literal>IF NOT EXISTS</literal> 옵션을 사용하면, 
      이미 같은 이름의 칼럼이 있어도 오류로 처리하지 않고, 무시한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      해당 테이블에서 지정한 칼럼을 지우는 구문이다.  그 칼럼과
      관련된 인덱스와 테이블 제약 조건은 자동으로 함께 지워진다.
      해당 칼럼만 대상으로 수집된 각종 통계 정보들도 함께 지워진다.
      <literal>CASCADE</literal> 옵션을 사용하면, 뷰나 그 칼럼을 참조 하는
      참조키 같이 해당 칼럼을 사용하는 모든 개체들을 함께 지운다.
      <literal>IF EXISTS</literal> 옵션을 사용하면, 해당 칼럼이
      없어도 오류로 처리하지 않고 알림 메시지만 보여주고, 무시한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <para>
      지정한 칼럼의 자료형을 바꾸는 구문이다. 이 작업은 해당 칼럼과 관계된
      인덱스나 단순 테이블 제약 조건들을 새 자료형에 맞게
      기존 속성을 다시 분석해서 자동으로 변환한다.
      <literal>COLLATE</literal> 옵션은 새 자료형에서 사용할
      문자 정렬 규칙을 지정한다. 생략하면, 그 해당 자료형의 기본 
      문자 정렬 규칙을 사용한다.
      <literal>USING</literal> 옵션으로 옛 자료형에 맞게 저장된
      자료를 새 자료형에 맞게 어떻게 변환할 것인지를 지정하는
      표현식을 사용할 수 있다.  생락하면, 기본 형 변환 작업을 한다.
      기본 형 변환을 못하는 경우는 반드시 이 옵션을 사용해야 한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      칼럼 기본값을 지정하거나 지운다 (지우는 것은 기본값을 NULL로 지정
      하는 것과 같다). 새 기본값은 지정된 다음부터
      실행되는 <command>INSERT</command>, <command>UPDATE</command> 
      작업에 반영된다; 기존 자료에 대해서는 바꾸지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      해당 칼럼의 null 값 처리 방식을 바꾼다.
      이 작업은 실재 자료 유효성 검사를 한다.
     </para>

     <para>
      <literal>SET NOT NULL</literal> may only be applied to a column
      provided none of the records in the table contain a
      <literal>NULL</literal> value for the column.  Ordinarily this is
      checked during the <literal>ALTER TABLE</literal> by scanning the
      entire table; however, if a valid <literal>CHECK</literal> constraint is
      found which proves no <literal>NULL</literal> can exist, then the
      table scan is skipped.
     </para>

     <para>
      테이블이 파티션 된 경우라면, 특정 하위 테이블 하나에 대해서만
      <literal>DROP NOT NULL</literal>  작업을 할 수 없다.
      null 값을 허용하려면, 상위 테이블 대상으로 이 작업을 해야 한다.
      상위 테이블에는 <literal>NOT NULL</literal> 제약 조건이 없어도,
      하위 테이블에서는 개별적으로 이 제약 조건을 추가 할 수 있다.
      그래서, 상위 테이블에서는 null 값을 허용하지만, 
      실 자료가 저장되는 하위 테이블에서 null 값을 금지할 수 있다.
      그 반대는 안된다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP EXPRESSION [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      This form turns a stored generated column into a normal base column.
      Existing data in the columns is retained, but future changes will no
      longer apply the generation expression.
     </para>

     <para>
      If <literal>DROP EXPRESSION IF EXISTS</literal> is specified and the
      column is not a stored generated column, no error is thrown.  In this
      case a notice is issued instead.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</literal></term>
    <term><literal>SET GENERATED { ALWAYS | BY DEFAULT }</literal></term>
    <term><literal>DROP IDENTITY [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      이 구문들은 해당 칼럼을 식별 칼럼으로 사용하거나, 식별 칼럼 속성을
      지울 때 사용한다.  식별 칼럼에 대한 자세한 설명은
      <xref linkend="sql-createtable"/> 명령 설명서에서 다룬다.
      Like <literal>SET DEFAULT</literal>, these forms only affect the
      behavior of subsequent <command>INSERT</command>
      and <command>UPDATE</command> commands; they do not cause rows
      already in the table to change.
      <literal>SET DEFAULT</literal>와 같이, 이 작업 다음부터
      실행되는 <command>INSERT</command>, <command>UPDATE</command> 
      작업에 반영된다; 기존 자료에 대해서는 바꾸지 않는다.

     </para>

     <para>
      <literal>DROP IDENTITY IF EXISTS</literal> 구문은
      해당 칼럼이 식별 칼럼이 아니더라도 오류로 처리하지 않고, 
      알림 메시지만 보여주고, 무시한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET <replaceable>시퀀스옵션</replaceable></literal></term>
    <term><literal>RESTART</literal></term>
    <listitem>
     <para>
      이 구문은 해당 식별 칼럼과 관계된 시퀀스 설정을 바꾼다.
      <replaceable>시퀀스옵션</replaceable>은
      <literal>INCREMENT BY</literal>와 같은
      <xref linkend="sql-altersequence"/> 명령 설명서에서 소개하고 있는
      옵션들이다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      이 구문은 해당 칼럼에 대해서
      <xref linkend="sql-analyze"/> 작업에서 사용하는 
      통계 수집량을 지정한다. 여기서 지정하는 값은 0부터 10000까지다.
      -1로 지정하면, 시스템 기본 값(<xref
      linkend="guc-default-statistics-target"/>)을 사용한다.
      쿼리 실행 계획기가 사용하는 이 통계 정보에 대한
      자세한 이야기는 <xref linkend="planner-stats"/>에서 다룬다.
     </para>
     <para>
      <literal>SET STATISTICS</literal> 작업은
      <literal>SHARE UPDATE EXCLUSIVE</literal> 수준의 잠금을 사용한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">속성옵션</replaceable> = <replaceable class="parameter">값</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="parameter">속성옵션</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      (이 부분은 저보다 더 잘 아는 분이 도와주시길...)
      This form sets or resets per-attribute options.  Currently, the only
      defined per-attribute options are <literal>n_distinct</literal> and
      <literal>n_distinct_inherited</literal>, which override the
      number-of-distinct-values estimates made by subsequent
      <xref linkend="sql-analyze"/>
      operations.  <literal>n_distinct</literal> affects the statistics for the table
      itself, while <literal>n_distinct_inherited</literal> affects the statistics
      gathered for the table plus its inheritance children.  When set to a
      positive value, <command>ANALYZE</command> will assume that the column contains
      exactly the specified number of distinct nonnull values.  When set to a
      negative value, which must be greater
      than or equal to -1, <command>ANALYZE</command> will assume that the number of
      distinct nonnull values in the column is linear in the size of the
      table; the exact count is to be computed by multiplying the estimated
      table size by the absolute value of the given number.  For example,
      a value of -1 implies that all values in the column are distinct, while
      a value of -0.5 implies that each value appears twice on the average.
      This can be useful when the size of the table changes over time, since
      the multiplication by the number of rows in the table is not performed
      until query planning time.  Specify a value of 0 to revert to estimating
      the number of distinct values normally.  For more information on the use
      of statistics by the <productname>PostgreSQL</productname> query
      planner, refer to <xref linkend="planner-stats"/>.
     </para>
     <para>
      Changing per-attribute options acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>SET STORAGE</literal>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>칼럼별 자료 저장 방식 설정</secondary>
     </indexterm>
    </term>
    <listitem>
     <para>
      이 구문은 해당 칼럼 자료를 어떻게 저장할지를 정한다.
      해당 자료를 테이블에 저장할지, <acronym>TOAST</acronym> 테이블에 저장할지,
      그 자료를 압축할지 말지를 지정한다.
      <literal>PLAIN</literal>: 정수형과 같은 크기 고정, 압축 안하고,
      해당 테이블에 저장한다.  <literal>MAIN</literal>: 테이블에, 압축 함.
      <literal>EXTERNAL</literal>: 토스트에, 압축 안함.
      <literal>EXTENDED</literal>: 토스트에, 압축 함.
      <literal>PLAIN</literal>으로 처리하지 않는 대부분의 자료형 자료는
      <literal>EXTENDED</literal> 방식으로 저장된다.
      <type>text</type> 형이나, <type>bytea</type> 형으로
      아주 큰 자료인 경우, <literal>EXTERNAL</literal> 방식을 사용하면
      문자열 조작 함수를 사용할 때 좀 더 빠르게 처리하며, 그 저장 공간은
      커진다.   <literal>SET STORAGE</literal> 작업은 이미 저장된 자료들에
      대해서는 변경 작업을 하지 않는다.  이 설정 후 발생하는 자료 조작
      작업에 영향을 미친다.  자세한 내용은 <xref linkend="storage-toast"/>에서
      다룬다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">테이블_제약조건</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블에 새로운 제약 조건을 추가한다. 
      문법은 <xref linkend="sql-createtable"/> 명령에서 제약 조건 사용하는 것과
      같다.  추가로  <literal>NOT VALID</literal> 옵션을 사용할 수 있는데,
      이 옵션은 참조 키나, 체크 제약 조건인 경우 사용할 수 있다.
     </para>

     <para>
      일반적으로, 이 작업은 새로운 제약조건에 자료가 모두 맞는지 확인하기 위해,
      테이블 전체 자료를 조사한다. 하지만,
      <literal>NOT VALID</literal> 옵션을 추가하면, 
      기존 자료에 대한 유효성 검사를 하지 않고, 이 제약 조건이 추가된
      다음부터 다루는 자료에 대해서만 유효성 검사를 한다. 이렇게 하면,
      참조키나, 체크 제약 조건에 대한 기존 모든 자료에 대한 유효성 검사
      시간 때문에 테이블이 잠기는 것을 최소화 할 수 있다.  모든 자료에
      대한 유효성 검사는 따로 <literal>VALIDATE CONSTRAINT</literal>
      명령으로 할 수 있다.
      <literal>NOT VALID</literal> 옵션을 사용할 때 참고해야할 
      보다 자세한 내용은 아래 <xref linkend="sql-altertable-notes"/>에서 한다.
     </para>

     <para>
      대부분의 <literal>ADD
      <replaceable class="parameter">테이블_제약조건</replaceable></literal>
      작업은 <literal>ACCESS EXCLUSIVE</literal> 모드로 테이블을 잠근다. 
      <literal>ADD
      FOREIGN KEY</literal> 작업만 <literal>SHARE ROW
      EXCLUSIVE</literal> 모드 잠금을 사용한다. 또한
      <literal>ADD FOREIGN KEY</literal> 작업 시 그 참조 테이블의 자료도
      같이 검사해야하기 때문에, <literal>SHARE ROW EXCLUSIVE</literal> 모드로
      잠긴다.
     </para>

     <para>
      추가로, 파티션 테이블 대상으로 유니크나 기본키 제약조건을 추가할 때는
      제한사항이 있다. 이 부분은 <xref linkend="sql-createtable"/> 참고.
      또한, 파티션 테이블 대상으로 참조키를 추가할 때는 현재 버전에서는
      <literal>NOT VALID</literal> 옵션을 사용할 수 없다.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">인덱스를_사용하는_제약조건</replaceable></literal></term>
    <listitem>
     <para>
      이 구문은 새 <literal>PRIMARY KEY</literal>, <literal>UNIQUE</literal>
      제약 조건을 추가하는데, 이미 그 용도로 쓸 인덱스가 있는 경우에
      사용한다.
      제약 조건 정의에 쓰일 칼럼은 그 인덱스에 쓰인 칼럼과 동일해야 한다.
     </para>

     <para>
      여기서 사용할 인덱스는 표현식 기반도 아니며, 부분 인덱스도 
      아니여야 한다.
      이 인덱스는 정렬이 가능한 b-tree 인덱스여야 한다.  이렇게 제한 하는
      이유는 <literal>ADD PRIMARY KEY</literal>, <literal>ADD UNIQUE</literal>
      작업과 내부적으로 그 처리가 같게 하기 위해서다.
     </para>

     <para>
      <literal>PRIMARY KEY</literal> 작업은 그 해당 칼럼들 속성이 <literal>NOT NULL</literal>
      이어야 하기 때문에, 그 칼럼들이 null 값을 허용하고 있다면,
      각 칼럼들에 대해서 <literal>ALTER COLUMN SET NOT NULL</literal> 작업도 
      함께 한다.  이런 상황이면 해당 모든 자료에 null 값이 있는지
      확인하는 작업을 한다.  그 외 상황에서는 이 제약 조건에 쓸 
      인덱스를 만드는 작업 시간만 필요하다.
     </para>

     <para>
      제약 조건 이름을 지정하는데, 인덱스 이름이 다르면, 인덱스 이름을 제약
      조건 이름으로 자동 바꾸며, 제약 조건 이름이 없으면, 인덱스 이름을
      제약 조건 이름으로 한다.
     </para>

     <para>
      이 작업이 완료되면, 그 인덱스는 해당 제약 조건에 종속된다. 
      즉, 그 제약 조건이 지워지면, 그에 딸린 인덱스도 함께 지워진다.
     </para>

     <para>
      This form is not currently supported on partitioned tables.
     </para>

     <note>
      <para>
       이미 있는 인덱스를 사용해서 제약 조건을 추가하는 방법은 
       테이블 잠금을 최소화 하려고 할 때 유용하게 사용된다.
       해당 인덱스를 <command>CREATE INDEX CONCURRENTLY</command> 명령으로
       테이블 잠금 없이 인덱스를 미리 만들어 두고, 
       그것을 이용해서 작업하기 때문에, 테이블 정의 바꾸기 작업 시간은
       최소화 되어 그 만큼 잠금 시간이 짧아진다.  사용 예제는 아래에 있다.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER CONSTRAINT</literal></term>
    <listitem>
     <para>
      이 구문은 기존 제약 조건의 속성을 바꾼다.
      현재 참조키 제약 조건에 대해서만 사용할 수 있다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <para>
      This form validates a foreign key or check constraint that was
      previously created as <literal>NOT VALID</literal>, by scanning the
      table to ensure there are no rows for which the constraint is not
      satisfied.  Nothing happens if the constraint is already marked valid.
      (See <xref linkend="sql-altertable-notes"/> below for an explanation
      of the usefulness of this command.)
     </para>
     <para>
      This command acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      이 구문은 지정한 제약 조건을 해당 테이블에서 지운다.
      그 제약 조건에 딸린 인덱스도 함께 지운다.
      <literal>IF EXISTS</literal> 옵션을 사용하면, 해당 제약 조건이 없어도
      오류로 처리하지 않고, 알림 메시지만 보이고, 아무 작업도 안한다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블에 속한 트리거 사용 여부를 지정한다.
      비활성화(disable)란 해당 트리거를 지우지는 않고, 
      그냥 그 트리거 실행을 안하게 하는 것을 말한다.
      지연 트리거(DEFERRABLE 옵션이 있는 트리거)는 
      그 트리거 함수가 실재 실행 될 때가 아니라,
      해당 이벤트가 생길 때 활성 상태를 확인한다.
      이 작업은 각각 개별 트리거에 대해서 설정을 할 수도 있고, 
      해당 테이블에 속한 모든 트리거에 대해서도 설정 할 수 있고, 
      사용자가 지정한 트리거에 대해서만 설정할 수도 있다.
      (참조키 검사 같은 내부용 자동으로 만들어지는 트리거도 있는데, 
      이런 트리거는 제외한다는 이야기).
      이런 내부 트리거의 사용 여부 설정은 슈퍼유저만 가능하다.
      이런 조작은 자료 정합성을 지킬 수 없는 상태를 만들기 때문이다.
     </para>

     <para>
      트리거 실행 조건은 <xref linkend="guc-session-replication-role"/>
      환경 설정 매개 변수값에도 영향을 받는다.
      단순하게, 이 환경 설정 값이 <quote>origin</quote> 또는
      <quote>local</quote> 일때, 활성화 된 트리거는 작동한다. (기본 설정)
      해당 세션의 이 환경 설정 값이 <quote>replica</quote> 라면,
      <literal>ENABLE REPLICA</literal> 옵션이 있는 트리거만 작동한다.
      <literal>ENABLE ALWAYS</literal> 옵션이 있는 트리거는
      해당 세션의 현재 복제 역활과 상관 없이 작동한다.
     </para>

     <para>
      The effect of this mechanism is that in the default configuration,
      triggers do not fire on replicas.  This is useful because if a trigger
      is used on the origin to propagate data between tables, then the
      replication system will also replicate the propagated data, and the
      trigger should not fire a second time on the replica, because that would
      lead to duplication.  However, if a trigger is used for another purpose
      such as creating external alerts, then it might be appropriate to set it
      to <literal>ENABLE ALWAYS</literal> so that it is also fired on
      replicas.
     </para>

     <para>
      이 작업은 해당 테이블을 <literal>SHARE ROW EXCLUSIVE</literal> 수준으로
      잠근다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블에 속한 룰의 실행 여부를 지정한다.
      이 구문을 사용하면, 해당 룰을 지우지 않고, 단지 실행이 되지 않게 
      설정할 수 있다.  사용법은 트리거 사용 여부 지정하는 것과 같다.
      이 작업으로도 <literal>ON SELECT</literal> 룰의 실행은 막을 수 없다.
      이 룰은 현재 세션이 기본 복제 역할이 아닐지라도 뷰 작업은 
      항상 동작해야 하기 때문이다. (PostgreSQL의 뷰는 on select 룰이다 - 
      옮긴이)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블에 속한 로우 단위 보안 정책을 활성화 하거나
      비활성화 하는 일을 한다.
      테이블에 해당 정책이 없는데, 활성화로 지정하면, 
      기본 거부 정책이 적용된다.  
      해당 테이블이 로우 단위 보안 정책을 사용하지 않게 설정 되어 있어도
      그 테이블 용 보안 정책은 있을 수 있다. 이 경우, 그 정책은 
      반영이 <emphasis>안되며</emphasis>, 무시된다.
      <xref linkend="sql-createpolicy"/> 참조.
     </para>

     <para>
      The rule firing mechanism is also affected by the configuration variable
      <xref linkend="guc-session-replication-role"/>, analogous to triggers as
      described above.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      현재 사용자가 해당 테이블의 소유주일 때 로우 단위 보안 정책을 
      어떻게 반영할 것인지를 지정하는 구문이다.
      force : 작동, no force: 비작동 (기본값)
      <xref linkend="sql-createpolicy"/> 참고.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <para>
      <xref linkend="sql-cluster"/> 명령에서 사용할 인덱스를 지정한다.
      이 작업은 실재 클러스터 작업은 하지 않는다.
     </para>
     <para>
      이 작업은 <literal>SHARE UPDATE EXCLUSIVE</literal> 수준으로 테이블을 잠근다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      이 구문은 <xref linkend="sql-cluster"/> 작업을 할 때
      사용하는 인덱스 지정을 지운다.
      이 작업은 나중에 클러스터 작업을 할 때, 
      지정된 인덱스가 없기 때문에, 영향을 준다.
     </para>
     <para>
      이 작업은 <literal>SHARE UPDATE EXCLUSIVE</literal> 수준으로 테이블을 잠근다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Backward-compatible syntax for removing the <literal>oid</literal>
      system column.  As <literal>oid</literal> system columns cannot be
      added anymore, this never has an effect.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블의 테이블스페이스를 바꾼다.
      이 작업은 해당 테이블의 물리적인 파일을 새 테이블스페이스 영역으로
      옮김을 의미한다.  이 때 해당 테이블에 딸린 인덱스는 옮기지 않는다.
      인덱스는 따로 해당 <literal>SET TABLESPACE</literal> 명령으로
      옮길 수 있다.
      When applied to a partitioned table, nothing is moved, but any
      partitions created afterwards with
      <command>CREATE TABLE PARTITION OF</command> will use that tablespace,
      unless overridden by a <literal>TABLESPACE</literal> clause.
     </para>

     <para>
      한 데이터베이스 내, 한 테이블스페이스 안에 있는 모든 테이블은
      <literal>ALL IN TABLESPACE</literal> 구문으로 한 번에 옮긴 수있다.
      이 때는 그 모든 테이블이 잠긴다.  이 구문은 
      <literal>OWNED BY</literal> 옵션을 이용해 특정 소유주의 모든 
      테이블도 한 번에 옮긴 수 있다.
      <literal>NOWAIT</literal> 옵션을 사용하면, 
      작업 시점에 원하는 테이블 잠금을 할 수 없으면, 기다리지 않고, 
      오류로 처리하고 마친다.
      시스템 카탈로그는 이 작업으로 모두 한꺼번에 옮길 수는 
      없다. 원한다면, <command>ALTER DATABASE</command> 명령을
      이용하거나, 각 개별 테이블에 대해서  <command>ALTER TABLE</command>
      명령을 이용해야 한다.
      <literal>information_schema</literal> 안 개체들은 제외다.
      <xref linkend="sql-createtablespace"/> 참조.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET { LOGGED | UNLOGGED }</literal></term>
    <listitem>
     <para>
      해당 테이블의 LOGGED, UNLOGGED 설정.
      (<xref linkend="sql-createtable-unlogged"/> 참조).  
      임시 테이블을 대상으로 이 작업은 할 수 없다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">저장_매개변수</replaceable> [= <replaceable class="parameter">값</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블의 저장 매개 변수값을 바꾼다.  사용할 수 변수들은
      <xref linkend="sql-createtable"/> 문서 안 
      <xref linkend="sql-createtable-storage-parameters"/> 부분에서 자세히 다룬다.
      이미 저장된 자료에 대해서 이 작업으로 그 속성이 바뀌지는 않는다.
      이미 저장된 자료를 대상으로 적용하려면,
      <link linkend="sql-vacuum">VACUUM FULL</link> 또는
      <xref linkend="sql-cluster"/> 작업을 해야 한다.
      실행 계획기와 관련된 설정 값을 바꾸는 지정은 그 작업이 완료된
      다음부터 실행 계획기가 그 값을 사용한다.
      실행 중인 쿼리에 대해서는 영향을 끼치지 않는다.
     </para>

     <para>
      <varname>parallel_workers</varname> 같은 실행 계획기 관련 설정 뿐만 아니라,
      fillfactor, toast, autovacuum 관련 저장 매개 변수
      값을 변경할 때는
      <literal>SHARE UPDATE EXCLUSIVE</literal> 수준으로 테이블을 잠근다.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="parameter">저장_매개변수</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      이 구문은 해당 저장 매개 변수 값을 초기값으로 바꾼다.
      <literal>SET</literal> 작업과 마찬가지로, 이렇게 지정한 뒤, 
      이미 있는 자료들의 소급 적용을 위해 추가 작업이 필요할 수도 있다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="parameter">상위테이블</replaceable></literal></term>
    <listitem>
     <para>
      이 구문은 해당 테이블을 지정한 상위 테이블에 종속시킨다.
      이렇게 하면, 그 상위 테이블 대상으로 실행 되는 쿼리는
      해당 테이블에 대해서도 영향을 미친다.  이 작업이 정상 수행 되려면,
      상위 테이블과 하위 테이블의 모든 칼럼 정의가 일치 해야 한다(물론 하위
      테이블에는 그 외 칼럼이 더 있을 수도 있다).
      칼럼 자료형이 같아야 하며, 상위 테이블 칼럼에
      <literal>NOT NULL</literal> 옵션이 있으면, 하위 테이블 칼럼에는
      반드시 있어야 하며, 그 반대는 괜찮다.
     </para>

     <para>
      또, <literal>CHECK</literal> 제약 조건도 같아야 한다. 
      상위 테이블 제약 조건 속성이 <literal>ALTER TABLE ... 
      ADD CONSTRAINT ... NO INHERIT</literal> 구문으로 상속을 안 하도록
      되어 있다면, 서로간 제약 조건이 같지 않아도 된다.
      현재 버전에서는
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>,
      <literal>FOREIGN KEY</literal> 제약 조건은 검사하지 않는다.
      이 특성은 다음 버전에서 바뀔 수 있다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="parameter">상위테이블</replaceable></literal></term>
    <listitem>
     <para>
      이 구문은 지정한 상위 테이블과 종속 관계를 끊는다.
      이 작업을 완료 되면, 지정한 상위 테이블 관련 쿼리에서
      해당 테이블을 더 이상 참조하지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="parameter">자료형이름</replaceable></literal></term>
    <listitem>
     <para>
      이 구문은 <command>CREATE TABLE OF</command> 구문으로 이미 있는 복합 자료형을
      기반으로 테이블을 만드는 것과 같이, 지정한 복한 자료형과, 
      해당 테이블과의 관계를 맺는다.
      테이블과 복합 자료형과의 칼럼 이름, 자료형이 모두 같아야 한다.
      작업 테이블은 상속 관계로 볼 때 하위 테이블이 아니여야 한다.
      이런 제약은 <command>CREATE TABLE OF</command> 작업 결과와 같아야 하기 때문이다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
     <para>
      테이블과 자료형의 관계를 끊는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER TO</literal></term>
    <listitem>
     <para>
      이 구문은 테이블, 시퀀스, 뷰, 구체화한 뷰, 외부 테이블의 소유주를 바꾼다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-replica-identity">
    <term><literal>REPLICA IDENTITY</literal></term>
    <listitem>
     <para>
      이 구문은 업데이트 되거나 삭제 될 식별 자료를 미리 쓰기 로그에 
      남길 때 포함할 정보를 바꾼다.  이 작업은 논리 복제 환경이 아니라면,
      아무런 영향력이 없다.  
      <literal>DEFAULT</literal>: 기본키 칼럼 옛 값을 기록.
      <literal>USING INDEX</literal>: 지정한 인덱스에 있는 해당 칼럼 옛 값을 기록.
      이 인덱스는 유니크 인덱스여야 하며, 부분 인덱스가 아니며, 
      지연 불가능한 인덱스여야 하며, 그 칼럼은 모두 <literal>NOT NULL</literal> 속성이
      있어야 한다.
      <literal>FULL</literal>: 해당 로우의 모든 칼럼 옛 값을 기록.
      <literal>NOTHING</literal>: 옛 로우에 대한 기록은 안 남김.
      (시스템 테이블은 이 값이 기본값이다.) 
      어떤 설정을 하든, 새 버전 로우와 옛 버전 로우과 완벽하게 일치하면,
      미리 쓰기 로그에는 어떠한 기록도 남기지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      <literal>RENAME</literal> 구문은 
      해당 테이블(인덱스, 시퀀스, 뷰, 구체화한 뷰, 외부 테이블)의 
      이름을 바꾸며, 또한 해당 칼럼의 이름과, 제약 조건의 이름을 바꾼다.
      제약 조건의 이름을 바꿀 때 그것과 의존 관계가 있는 인덱스가 있다면,
      그 인덱스 이름도 함께 바뀐다.
      이 작업은 저장된 자료에는 아무런 영향을 미치지 않는다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      스키마 바꾸기.  해당 테이블에 딸린 인덱스, 제약 조건, 칼럼에 딸린
      스키마까지 모두 스키마가 바뀐다.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-attach-partition">
    <term><literal>ATTACH PARTITION <replaceable class="parameter">파티션이름</replaceable> { FOR VALUES <replaceable class="parameter">파티션범위명세</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
      해당 테이블에 하위 파티션 테이블을 추가하는 구문.
      The table can be attached
      as a partition for specific values using <literal>FOR VALUES</literal>
      or as a default partition by using <literal>DEFAULT</literal>.
      For each index in the target table, a corresponding
      one will be created in the attached table; or, if an equivalent
      index already exists, will be attached to the target table's index,
      as if <command>ALTER INDEX ATTACH PARTITION</command> had been executed.
      Note that if the existing table is a foreign table, it is currently not
      allowed to attach the table as a partition of the target table if there
      are <literal>UNIQUE</literal> indexes on the target table.  (See also
      <xref linkend="sql-createforeigntable"/>.)  For each user-defined
      row-level trigger that exists in the target table, a corresponding one
      is created in the attached table.
     </para>

     <para>
      <replaceable class="parameter">파티션범위명세</replaceable> 구문은
      <xref linkend="sql-createtable"/> 명령 설명서에 나온 것과 같음.
      파티션 범위 명세는 해당 테이블(ALTER TABLE의 대상 테이블, 상위 파티션 
      테이블)에서 지정한 파티션 종류와 파티션 키 정의와 맞아야 함.
      추가할 테이블의 칼럼과 칼럼 자료형은 상위 파티션 테이블과
      정확하게 모두 일치 해야 한다. <literal>NOT NULL</literal>,
      <literal>CHECK</literal> 제약조건도 같아야 한다.
      현재 버전에서는 <literal>FOREIGN KEY</literal> 제약 조건은
      일치하는지 검사하지 않는다.
      <literal>UNIQUE</literal>,
      <literal>PRIMARY KEY</literal> 제약 조건이 없는데, 상위 테이블에
      정의 되어 있다면, 자동으로 추가되는 하위 테이블에 만들어진다.
      추가할 테이블에  <literal>CHECK</literal> 제약 조건에,
      <literal>NO INHERIT</literal> 옵션이 있는 경우는 허용하지 않는다.
      <literal>NO INHERIT</literal> 옵션 없이 해당 제약 조건을 다시 만들어야
      추가할 수 있다.
     </para>

     <para>
      추가할 파티션 테이블이 자료가 이미 있는 일반 테이블이라면,
      그 자료들이 파티션 조건에 맞는 자료인지 확인하기 위해 모든 
      자료의 유효성 검사를 한다.  이 작업은 자료가 많은 경우 
      시간이 오래 걸린다. 이 문제를 피하려면, 먼저 그 테이블에 
      파티션 조건에 맞는 <literal>CHECK</literal> 제약 조건을 만든다.
      이렇게 하면, 모든 자료를 대상으로 유효성 검사를 하지 않게 된다.
      하지만, 파티션 키가 표현식이거나, 그 칼럼이, 
      <literal>NOT NULL</literal> 속성이라면, 전체 자료 유효성 검사를
      한다.  <literal>NULL</literal> 값을 허용하지 않는 목록 파티션을
      추가하는 경우에는 해당 파티션 키 칼럼에 <literal>NOT NULL</literal>
      제약 조건을 추가 해야 한다.
      If the new partition is a regular table, a full table scan is performed
      to check that existing rows in the table do not violate the partition
      constraint. It is possible to avoid this scan by adding a valid
      <literal>CHECK</literal> constraint to the table that allows only
      rows satisfying the desired partition constraint before running this
      command. The <literal>CHECK</literal> constraint will be used to
      determine that the table need not be scanned to validate the partition
      constraint. This does not work, however, if any of the partition keys
      is an expression and the partition does not accept
      <literal>NULL</literal> values. If attaching a list partition that will
      not accept <literal>NULL</literal> values, also add
      <literal>NOT NULL</literal> constraint to the partition key column,
      unless it's an expression.
     </para>

     <para>
      추가할 하위 파티션 테이블이 외부 테이블이라면,
      이런 모든 제약 조건 관련 검사를 하지 않는다. 
      (외부 테이블의 제약 조건 이야기는
      <xref linkend="sql-createforeigntable"/> 명령 설명서에서 다룬다.)
     </para>

     <para>
      When a table has a default partition, defining a new partition changes
      the partition constraint for the default partition. The default
      partition can't contain any rows that would need to be moved to the new
      partition, and will be scanned to verify that none are present. This
      scan, like the scan of the new partition, can be avoided if an
      appropriate <literal>CHECK</literal> constraint is present. Also like
      the scan of the new partition, it is always skipped when the default
      partition is a foreign table.
     </para>

     <para>
      Attaching a partition acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the parent table,
      in addition to <literal>ACCESS EXCLUSIVE</literal> locks on the table
      to be attached and on the default partition (if any).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DETACH PARTITION</literal> <replaceable class="parameter">파티션이름</replaceable></term>
    <listitem>
     <para>
      지정한 파티션 이름의 하위 테이블을 해당 테이블과 종속 관계를 끊는다.
      해당 테이블과 아무런 관계가 없게 된다. Any triggers that
      were created as clones of those in the target table are removed.
      <literal>SHARE</literal> lock is obtained on any tables that reference
      this partitioned table in foreign key constraints.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
   <literal>RENAME</literal>, <literal>SET SCHEMA</literal>,
   <literal>ATTACH PARTITION</literal>, <literal>DETACH PARTITION</literal> 
   구문은 딱 한 작업만 할 수 있으며, 그 외 작업들은 
   여러 작업들을 하나의 명령으로 함께 사용할 수 있다.
   예를 들어, 여러 칼럼을 추가하거나, 삭제하고, 자료형을 바꾸는 것은 
   하나의 명령으로 실행할 수 있다.  이런 기능은 
   자료량이 많은 테이블을 대상으로 작업할 때 하나의 작업으로
   처리 되기 때문에, 유용하게 사용될 수 있다.
  </para>

  <para>
   <command>ALTER TABLE</command> 명령은 해당 테이블 소유주가 실행 할 수 있다.
   스키마나 테이블스페이스를 바꿀 때는 새 스키마나 테이블스페이스에 대해서
   해당 사용자에게 <literal>CREATE</literal> 권한이 있어야 한다.
   새로운 하위 테이블을 추가할 때는 그 하위 테이블도 같은 사용자 것이여어야
   한다.  파티션 테이블에서 하위 파티션 테이블을 추가할 때도 마찬가지다.
   소유주를 바꾸는 경우, 기존 소유주는 직간접적으로 새 소유주의 
   소속원이어야 하며, 새 소유주는 해당 스키마에 대해서, 
   <literal>CREATE</literal> 권한이 있어야 한다.
   (새 소유주가 해당 테이블을 삭제 하거나, 새로 만들 수 있어야 하기 때문이다.
   슈퍼유저인 경우는 이런 제약이 없다.)
   자료형을 바꾸는 경우, 새 자료형에 대해서 해당 사용자는
   <literal>USAGE</literal> 권한이 있어야 한다.
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

    <variablelist>

     <varlistentry>
      <term><literal>IF EXISTS</literal></term>
      <listitem>
       <para>
        해당 테이블이 없어도 오류로 처리하지 않고, 알림 메시지만 보여준다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">이름</replaceable></term>
      <listitem>
       <para>
        작업 대상 해당 테이블 이름(스키마 이름 포함).
        이 이름 앞에 <literal>ONLY</literal> 옵션을 사용하면,
        해당 테이블만 작업 대상이 되며, 
        <literal>ONLY</literal> 옵션이 없으면, 해당 테이블과 그 테이블의 하위 
        테이블까지 모두 작업 대상이 된다.  선택적으로
        이 하위 테이블 모두 작업 대상이라고 명시적으로 표시하기 위해
        테이블 이름 뒤에, <literal>*</literal> 문자를 추가할 수도 있다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">칼럼이름</replaceable></term>
      <listitem>
       <para>
        작업 대상 칼럼 이름이나, 새로 추가할 칼럼 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">새칼럼이름</replaceable></term>
      <listitem>
       <para>
        바뀔 칼럼의 새 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">새이름</replaceable></term>
      <listitem>
       <para>
        바뀔 테이블의 새 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">자료형</replaceable></term>
      <listitem>
       <para>
        새로 추가할 칼럼의 자료형이나, 기존 자료형의 바뀔 새 자료형 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">테이블제약조건</replaceable></term>
      <listitem>
       <para>
        해당 테이블의 새 제약 조건 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">제약조건</replaceable></term>
      <listitem>
       <para>
        새로 추가하거나 기존 제약 조건 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
        해당 칼럼이 지울 때, 그 칼럼을 사용하는 다른 모든 개체(예,
        그 칼럼을 참조하는 뷰)들도 함께 지운다.
        (<xref linkend="ddl-depend"/> 참조)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
        해당 칼럼을 지울 때 그 칼럼을 사용하는 다른 개체들이 있으면, 
        해당 칼럼을 지우지 않는다.  이것이 기본값이다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">트리거이름</replaceable></term>
      <listitem>
       <para>
        활성화, 비활성화할 트리거 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
        트리거 활성화, 비활성화 설정을 할 때 대상 트리거를 
        내부 트리거까지 포함해서 모든 트리거로 한 번에 지정할 때 사용 한다.
        (내부 트리거 - 참조키에서 사용하는 트리거, 또는 지연 가능한 유니크 
        제약 조건, 제외 제약 조건 - 까지 대상이 되기 때문에, 이 작업을 할 때는
        슈퍼유저여야 한다.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <para>
        참조키나, 지연 가능한 유니크, 제외 제약 조건에서 사용하는 
        내부 트리거를 제외한 나머지 모든 트리거를 한꺼번에, 
        활성화나 비활성화 할 때 사용하는 키워드.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">인덱스이름</replaceable></term>
      <listitem>
       <para>
        해당 인덱스 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">저장_매개변수</replaceable></term>
      <listitem>
       <para>
        해당 테이블의 저장 매개 변수 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
       <para>
        새롭게 지정할 테이블 저장 매개 변수 값.
        이 값은 해당 매개 변수에 따라 숫자 일수도 있고, 문자열 일 수도 있다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">상위테이블</replaceable></term>
      <listitem>
       <para>
        상속 관계를 맺거나 끊을 해당 테이블의 상위 테이블 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">새소유주</replaceable></term>
      <listitem>
       <para>
        바뀔 해당 테이블의 새 소유주 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">새테이블스페이스</replaceable></term>
      <listitem>
       <para>
        바뀔 해당 테이블의 새 테이블스페이스 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">새스키마</replaceable></term>
      <listitem>
       <para>
        바뀔 해당 테이블의 새 스키마 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">파티션이름</replaceable></term>
      <listitem>
       <para>
        추가하거나, 뺄 파티션 테이블 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">파티션범위명세</replaceable></term>
      <listitem>
       <para>
        지정한 파티션이 어떤 범위를 대상으로 하는지 지정한다.
        여기서 사용하는 문법은 <xref linkend="sql-createtable"/> 명령
        설명서에서 자세히 다룬다.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1 id="sql-altertable-notes" xreflabel="참고">
  <title>참고</title>

   <para>
    <literal>COLUMN</literal> 키워드는 무시 된다. 빠져도 괜찮다.
   </para>

   <para>
    When a column is added with <literal>ADD COLUMN</literal> and a
    non-volatile <literal>DEFAULT</literal> is specified, the default is
    evaluated at the time of the statement and the result stored in the
    table's metadata.  That value will be used for the column for all existing
    rows.  If no <literal>DEFAULT</literal> is specified, NULL is used.  In
    neither case is a rewrite of the table required.
   </para>

   <para>
    Adding a column with a volatile <literal>DEFAULT</literal> or
    changing the type of an existing column will require the entire table and
    its indexes to be rewritten. As an exception, when changing the type of an
    existing column, if the <literal>USING</literal> clause does not change
    the column contents and the old type is either binary coercible to the new
    type or an unconstrained domain over the new type, a table rewrite is not
    needed; but any indexes on the affected columns must still be rebuilt.
    Table and/or index rebuilds may take a
    significant amount of time for a large table; and will temporarily require
    as much as double the disk space.
   </para>

   <para>
    <literal>CHECK</literal> 또는 <literal>NOT NULL</literal>  제약 조건 추가를 할 때는
    기존 자료 모두를 검사하지만, 테이블을 다시 만들 필요는 없다.
   </para>

   <para>
    비슷하게, 새 파티션 테이블을 추가할 때도 그 파티션 조건에 맞게
    자료가 잘 저장 되어 있는지 확인하는 작업을 한다.
   </para>

   <para>
    <command>ALTER TABLE</command> 명령에서 여러 작업들을 함께 사용할 수 있게한
    이유는 그 작업들이 연관성이 있어 하나의 작업으로 처리되어야 
    필요가 있기 때문이다.
   </para>

   <para>
    Scanning a large table to verify a new foreign key or check constraint
    can take a long time, and other updates to the table are locked out
    until the <command>ALTER TABLE ADD CONSTRAINT</command> command is
    committed.  The main purpose of the <literal>NOT VALID</literal>
    constraint option is to reduce the impact of adding a constraint on
    concurrent updates.  With <literal>NOT VALID</literal>,
    the <command>ADD CONSTRAINT</command> command does not scan the table
    and can be committed immediately.  After that, a <literal>VALIDATE
    CONSTRAINT</literal> command can be issued to verify that existing rows
    satisfy the constraint.  The validation step does not need to lock out
    concurrent updates, since it knows that other transactions will be
    enforcing the constraint for rows that they insert or update; only
    pre-existing rows need to be checked.  Hence, validation acquires only
    a <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the table being
    altered.  (If the constraint is a foreign key then a <literal>ROW
    SHARE</literal> lock is also required on the table referenced by the
    constraint.)  In addition to improving concurrency, it can be useful to
    use <literal>NOT VALID</literal> and <literal>VALIDATE
    CONSTRAINT</literal> in cases where the table is known to contain
    pre-existing violations.  Once the constraint is in place, no new
    violations can be inserted, and the existing problems can be corrected
    at leisure until <literal>VALIDATE CONSTRAINT</literal> finally
    succeeds.
   </para>

   <para>
    <literal>DROP COLUMN</literal> 작업은 물리적으로 해당 칼럼을 
    지우지 않고, SQL 작업에서 단지 해당 칼럼을 볼 수 없게만 한다.
    이 작업 뒤 일어나는 자료 추가, 변경 작업에서는 해당 칼럼에 null 값을
    채운다.  이렇게 해서, 칼럼 삭제는 작업 시간을 줄일 수는 있지만,
    당장에 디스크 여유 공간을 확보하지는 못한다.
   </para>

   <para>
    칼럼 삭제 작업으로 물리적으로 해당 자료가 모두 지워지길 바란다면,
    <command>ALTER TABLE</command> 명령에서, 칼럼 삭제 작업과 함께, 
    기존 모든 자료들 대상으로 하는 작업을 함께 지정하면 된다.
    그러면, 그 작업을 하면서 삭제된 칼럼에 대해서는 null 값으로 바꿔
    처리한다.
   </para>

   <para>
    <command>ALTER TABLE</command> 명령의 테이블 다시 쓰기 작업은
    안전하지 않은 MVCC 작업이다.
    어떤 다른 사용자가 테이블 다시 쓰기 작업 전에, 
    해당 테이블 스냅샷을 만들어 사용하고 있다면, 
    테이블 다시 쓰기 작업이 끝난 뒤에는 그 사용자는 빈 테이블을 
    보게 된다.
    이 문제는 <xref linkend="mvcc-caveats"/>에서 자세히 다룬다.
   </para>

   <para>
    <literal>SET DATA TYPE</literal> 구문에서 <literal>USING</literal> 옵션을 
    사용하면, 자료형 변환의 유연성 아주 높아진다.  <literal>USING</literal>
    뒤에 사용하는 표현식으로 얼마든지, 기존 자료에 대한 
    형 변환 작업을 할 수 있기 때문이다.  이 때 주의해야 할 점은
    해당 칼럼의 <literal>DEFAULT</literal> 설정으로 지정한 그 기본값이
    새 자료형에서는 사용할 수 없는 경우가 있다는 것이다.
    이 경우는 먼저 <literal>DROP DEFAULT</literal> 작업을 먼저하고, 
    <literal>ALTER TYPE</literal> 작업 뒤, 새 기본값을 지정하는
    <literal>SET DEFAULT</literal> 작업을 하면 된다.  이런 작업 방식은
    한 칼럼과 관계된 인덱스나, 제약 조건 변경 작업에서도 사용될 수 있다.
   </para>

   <para>
    해당 테이블이 상속 관계의 상위 테이블이라면,
    그 테이블만을 대상으로 칼럼 추가, 삭제, 자료형 바꾸기를 할 수 없다.
    his ensures that the descendants always
    have columns matching the parent.  Similarly, a <literal>CHECK</literal>
    constraint cannot be renamed in the parent without also renaming it in
    all descendants, so that <literal>CHECK</literal> constraints also match
    between the parent and its descendants.  (That restriction does not apply
    to index-based constraints, however.)
    또한 상위 테이블만 참조하면 모든 하위 테이블도 함께 참조하기 때문에, 
    모든 하위 테이블에서 자료 유효성 검사를 하는 제약 조건이 있어야
    상위 테이블에 그 유효성 검사를 추가할 수 있다. 
    이 모든 경우  <command>ALTER TABLE ONLY</command> 명령은 오류로 처리한다.
    (설명이 더 어려운데, 상속 관계 테이블 대상으로 일어나는  문제들은
    서버에서 아주 친절하게 적절한 메시지를 보여준다. 서버 메시지를
    차근하게 읽고 작업하면 된다. - 옮긴이)
   </para>

   <para>
    하위 테이블의 칼럼도 함께 삭제하는 <literal>DROP COLUMN</literal> 
    작업은 그 칼럼이 상위 테이블로부터 상속 받은 칼럼에 대해서만
    함께 삭제한다.
    <command>ALTER TABLE ONLY ... DROP
    COLUMN</command> 구문인 경우는 하위 테이블의 칼럼을 삭제하지 않는다.
    이 작업은 파티션 테이블인 경우는 사용할 수 없다. 파티션 테이블은
    상위 테이블과 하위 테이블의 칼럼 구성이 똑같아야 하기 때문이다.
   </para>

   <para>
    식별 칼럼에 대한 작업(<literal>ADD
    GENERATED</literal>, <literal>SET</literal> 등, <literal>DROP
    IDENTITY</literal>)과,
    <literal>TRIGGER</literal>, <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    <literal>TABLESPACE</literal> 작업은 하위 테이블에 대해서는 자동으로
    함께 작업하지 않는다.  이런 작업은 <literal>오직</literal> 해당 테이블에
    대해서만 작업한다.  
    <literal>CHECK</literal> 제약 조건인 경우, <literal>NO INHERIT</literal> 옵션을
    지정하지 않았다면, 이 작업은 하위 테이블 모두 작업한다.
   </para>

   <para>
    시스템 카탈로그 테이블의 변경은 할 수 없다.
   </para>

   <para>
    사용 가능한 매개 변수에 대한 설명은 <xref linkend="sql-createtable"/> 명령
    설명서에서 자세히 다루고 있으며, 테이블 상속에 대한 자세한 설명은
    <xref linkend="ddl"/>에서 다룬다.
   </para>
 </refsect1>

 <refsect1>
  <title>예제</title>

  <para>
   테이블에 새 칼럼 추가:
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
   That will cause all existing rows in the table to be filled with null
   values for the new column.
  </para>

  <para>
   To add a column with a non-null default:
<programlisting>
ALTER TABLE measurements
  ADD COLUMN mtime timestamp with time zone DEFAULT now();
</programlisting>
   Existing rows will be filled with the current time as the value of the
   new column, and then new rows will receive the time of their insertion.
  </para>

  <para>
   To add a column and fill it with a value different from the default to
   be used later:
<programlisting>
ALTER TABLE transactions
  ADD COLUMN status varchar(30) DEFAULT 'old',
  ALTER COLUMN status SET default 'current';
</programlisting>
   Existing rows will be filled with <literal>old</literal>, but then
   the default for subsequent commands will be <literal>current</literal>.
   The effects are the same as if the two sub-commands had been issued
   in separate <command>ALTER TABLE</command> commands.
  </para>

  <para>
   칼럼 삭제:
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>

  <para>
   하나의 명령으로 두 칼럼의 자료형을 동시에 바꾸는 경우:
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>

  <para>
   정수형 칼럼을  <literal>USING</literal> 옵션을 사용해서,
   <type>timestamp with time zone</type> 자료형으로 바꾸는 경우:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
   윗 예제와 비슷한데, 이 경우는 해당 칼럼에 기본값 설정이 있어,
   그것을 지우고, 자료형 바꾸고, 다시 기본값을 지정하는 것을
   하나의 명령으로 작업하는 경우:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>

  <para>
   칼럼 이름 바꾸기:
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>

  <para>
   테이블 이름 바꾸기:
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>

  <para>
   제약 조건 이름 바꾸기:
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>

  <para>
   칼럼에 NOT NULL 제약 조건 추가:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
   칼럼에 NOT NULL 제약 조건 삭제:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>

  <para>
   To add a check constraint to a table and all its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>

  <para>
   하위 테이블에 상속되지 않는 제약 조건 추가:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
   (이 체크 제약 조건은 앞으로 이 테이블을 상위 테이블로
   상속 받는 새 하위 테이블이 만들어져도 이 제약 조건은 상속 받지 않는다.)
  </para>

  <para>
   해당 테이블 및 하위 테이블 모두 해당 체크 제약 조건 삭제:
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>

  <para>
   해당 테이블만 체크 제약 조건 삭제:
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
   (이 경우는 하위 테이블에는 그 제약 조건이 그대로 남아 있게 된다.)
  </para>

  <para>
   참조키 추가:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>

  <para>
   참조키를 유효성 검사 없이 추가 하고, 그 작업 뒤 유효성 검사를 하는 경우:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>

  <para>
   다중 칼럼 유니크 제약 조건 추가 (이 작업 동안 테이블은 잠긴다 - 옮긴이):
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>

  <para>
   기본키가 없는 테이블에 기본키 제약조건 이름은 임의로 지정하고,
   그 키용 인덱스를 만드는 경우 (이 작업 동안 테이블은 잠긴다 - 옮긴이):
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>

  <para>
   테이블스페이스 바꾸기:
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>

  <para>
   테이블 스키마 바꾸기:
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>

  <para>
   인덱스를 만드는데, 테이블 잠금 없이 만들고,
   그 인덱스를 기본키 제약조건을 새로 지정하는 작업:
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>

  <para>
   범위 파티션된 테이블에 하위 파티션 테이블을 끼워넣기:
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

  <para>
   목록 파티션된 테이블에 하위 파티션 테이블을 끼워넣기:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>

  <para>
   To attach a partition to a hash-partitioned table:
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>

  <para>
   To attach a default partition to a partitioned table:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>

  <para>
   파티션된 테이블에서 하위 파티션 테이블을 떼어놓기:
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>

 </refsect1>

 <refsect1>
  <title>호환성</title>

  <para>
   <literal>ADD</literal> (<literal>USING INDEX</literal> 빼고),
   <literal>DROP [COLUMN]</literal>, <literal>DROP IDENTITY</literal>, <literal>RESTART</literal>,
   <literal>SET DEFAULT</literal>, <literal>SET DATA TYPE</literal> (<literal>USING</literal> 빼고),
   <literal>SET GENERATED</literal>, <literal>SET <replaceable>시퀀스옵션</replaceable></literal> 이런 구문은 표준 SQL을 따른다.  나머지 구문은
   <productname>PostgreSQL</productname> 확장 기능이다.
   또한, 한 번의 명령으로 여러 작업을 동시에 하는 것도 확장 기능이다.
  </para>

  <para>
   <command>ALTER TABLE DROP COLUMN</command> 명령은 해당 테이블에
   모든 칼럼이 없을 때까지도 사용할 수 있다.  이 특성은 확장 기능이다.
   표준에서는 칼럼이 없는 테이블을 허용하지 않는다.
  </para>
 </refsect1>

 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"/></member>
  </simplelist>
 </refsect1>
</refentry>
