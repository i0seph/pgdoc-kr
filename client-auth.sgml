<!-- doc/src/sgml/client-auth.sgml -->

<chapter id="client-authentication">
 <title>클라이언트 인증</title>

 <indexterm zone="client-authentication">
  <primary>클라이언트 인증</primary>
 </indexterm>

 <para>
클라이언트 애플리케이션이 데이터베이스 서버에 연결하는 경우 어떤 <productname>PostgreSQL</productname> 데이터베이스 사용자 이름으로 연결할 것인지 지정하는데, 이것은 특정 사용자로 Unix 컴퓨터에 로그인하는 것과 매우 유사하다. 
SQL 환경 내에서 사용 중인 데이터베이스 사용자 이름은 데이터베이스 개체에 대한 액세스 권한을 결정한다. 자세한 내용은 <xref linkend="user-manag"/>을 참고 바란다. 따라서 연결 가능한 데이터베이스 사용자를 제한하는 것이 중요하다.
 </para>

 <note>
  <para>
<xref linkend="user-manag"/>에서 설명한 대로 <productname>PostgreSQL</productname>은 실제로 <quote>role</quote> 면에서 권한을 관리한다. 이 장에서는 <firstterm>데이터베이스 사용자</firstterm>가 <quote><literal>LOGIN</literal> 권한이 있는 role</quote>이라는 의미로 일관되게 사용된다.
  </para>
 </note>

 <para>
<firstterm>인증</firstterm>은 데이터베이스 서버가 클라이언트 ID를 구축하는 프로세스이며, 더 나아가 요청된 데이터베이스 사용자 이름으로 클라이언트 애플리케이션(또는 클라이언트 애플리케이션을 실행하는 사용자)의 연결을 허용할 것인지 결정하는 프로세스이다.
 </para>

 <para>
  <productname>PostgreSQL</productname>는 서로 다른 여러 가지 클라이언트 인증 방법을 제공한다. 
  특정 클라이언트 연결을 인증하는 데 사용되는 방법은 (클라이언트) 호스트 주소, 데이터베이스 및 사용자를 기준으로 선택할 수 있다.
 </para>

 <para>
  <productname>PostgreSQL</productname> 데이터베이스 사용자 이름은 서버가 실행되는 운영 체제의 사용자 이름과 논리적으로 별개이다. 특정 서버의 모든 사용자도 서버 머신에 계정을 가질 수 있지만 운영 체제 사용자 이름과 일치하는 데이터베이스 사용자 이름을 할당하는 것이 합당하다. 
  그러나, 원격 연결을 수용하는 서버에는 로컬 운영 체제 계정이 없는 데이터베이스 사용자가 다수일 수 있으며, 이런 경우 데이터베이스 사용자 이름과 OS 사용자 이름을 연결 짓는 것은 불필요하다.
 </para>

 <sect1 id="auth-pg-hba-conf">
  <title>The <filename>pg_hba.conf</filename> 파일</title>

  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>

  <para>
   클라이언트 인증은 전통적으로 이름이 <filename>pg_hba.conf</filename>이고 데이터베이스 클러스터의 데이터 디렉터리에 저장되는 환경 설정 파일로 제어된다. (<acronym>HBA</acronym>는 호스트 기반 인증(host-based authentication)의 약어이다.) 
   기본 <filename>pg_hba.conf</filename> 파일은 데이터 디렉터리가 <command>initdb</command>에 의해 초기화될 때 설치된다. 인증 환경 설정 파일을 다른 곳에 배치하는 것도 가능하다. <xref linkend="guc-hba-file"/> 환경 설정 파일을 참조 바란다.
  </para>

  <para>
   <filename>pg_hba.conf</filename> 파일의 일반 형식은 한 줄당 하나씩 있는 레코드 세트이다. 빈 줄은 무시된다. <literal>#</literal> 주석 문자 뒤의 텍스트도 무시된다. 레코드는 줄을 바꿔서 이어질 수 없다. 레코드는 여러 개의 필드로 구성되며, 공백 및/또는 탭으로 구분된다. 
   필드 값에 큰 따옴표를 사용하면 필드에 공백을 포함할 수 있다. 데이터베이스, 사용자 또는 주소 필드의 키워드에 따옴표를 사용하면(예: <literal>all</literal> 또는 <literal>replication</literal>) 단어는 자체의 특수한 의미를 상실하고 해당 이름의 데이터베이스, 사용자 또는 호스트와 동일하게 된다.
  </para>

  <para>
   각 레코드는 이러한 매개 변수와 일치하는 연결에 사용되는 연결 유형, 클라이언트 IP 주소 범위(연결 유형에 해당하는 경우), 데이터베이스 이름, 사용자 이름 및 인증 방법을 지정한다. 
   연결 타입, 클라이언트 주소, 요청된 데이터베이스 및 사용자 이름이 일치하는 첫 번째 레코드는 인증을 수행할 때 사용된다. <quote>제어 이동(fall-through)</quote> 또는 <quote>백업</quote>은 없다. 레코드 하나가 선택되고 인증이 실패한 경우 후속 레코드는 고려되지 않는다. 
   일치하는 레코드가 없으면 액세스가 거부된다.
  </para>

  <para>
   레코드는 다음 여러 형식이다:
<synopsis>
local         <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable> <optional><replaceable>auth-options</replaceable></optional>
host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
   필드의 의미는 다음과 같다.
   <variablelist>
    <varlistentry>
     <term><literal>local</literal></term>
     <listitem>
      <para>
       이 레코드는 Unix 도메인 소켓을 사용한 연결 시도와 일치한다. 이러한 유형의 레코드 없이 Unix 도메인 소켓 연결은 불가능 하다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <para>
       This record matches connection attempts made using TCP/IP.
       <literal>host</literal> records match
       <acronym>SSL</acronym> or non-<acronym>SSL</acronym> connection
       attempts as well as <acronym>GSSAPI</acronym> encrypted or
       non-<acronym>GSSAPI</acronym> encrypted connection attempts.
      </para>
     <note>
      <para>
       기본 동작이 로컬 루프백 주소 <literal>localhost</literal>에 대해서만 TCP/IP 연결을 listen하는 것이므로 <xref linkend="guc-listen-addresses"/> 환경 설정 매개 변수에 적절한 값으로 서버가 시작되지 않으면 원격 TCP/IP 연결이 불가능하다.
      </para>
     </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <para>
       이 레코드는 TCP/IP를 사용한 연결 시도와 일치하지만, <acronym>SSL</acronym> 암호화를 사용한 연결에만 해당된다.
      </para>

      <para>
       이 옵션을 사용하려면 서버는 <acronym>SSL</acronym> 지원이 내장되어 있어야 한다.  또한
       <acronym>SSL</acronym>은 <xref linkend="guc-ssl"/> 환경 설정 매개 변수 값
       지정으로 활성화되어야 한다(자세한 내용은 <xref linkend="ssl-tcp"/> 참조).
       한편, <literal>hostssl</literal> 레코드 지정으로 접속 예외 처리 되는 
       정보는 경고 로그를 남기지 않는다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <para>
       이 레코드 유형은 <literal>hostssl</literal>과는 반대로 동작한다. 
       <acronym>SSL</acronym>을 사용하지 않는 TCP/IP 상의 연결 시도에 대해서만 일치한다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostgssenc</literal></term>
     <listitem>
      <para>
       This record matches connection attempts made using TCP/IP,
       but only when the connection is made with <acronym>GSSAPI</acronym>
       encryption.
      </para>

      <para>
       To make use of this option the server must be built with
       <acronym>GSSAPI</acronym> support.  Otherwise,
       the <literal>hostgssenc</literal> record is ignored except for logging
       a warning that it cannot match any connections.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnogssenc</literal></term>
     <listitem>
      <para>
       This record type has the opposite behavior of <literal>hostgssenc</literal>;
       it only matches connection attempts made over
       TCP/IP that do not use <acronym>GSSAPI</acronym> encryption.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <para>
       이 레코드가 일치하는 데이터베이스 이름을 지정한다. <literal>all</literal> 값은 모든 데이터베이스와 일치하도록 지정한다. <literal>sameuser</literal> 값은 요청된 데이터베이스가 요청된 사용자와 이름이 동일한 경우에 레코드가 일치하도록 지정한다. 
       <literal>samerole</literal> 값은 요청된 사용자가 요청된 데이터베이스와 이름이 동일한 role의 멤버여야 하는지 지정한다. (<literal>samegroup</literal>은 폐지되었지만 <literal>samerole</literal>은 계속 쓸 수 있다.) 
       수퍼유저는 직간접적으로 role의 명시적인 멤버가 아닐 경우, 단지 수퍼유저라는 이유로 <literal>samerole</literal>에 대한 role의 멤버로 간주되지 않는다. <literal>replication</literal> 값은 물리 복제 연결이 요청되는 경우 레코드가 일치하도록 지정한다(복제 연결은 특정 데이터베이스를 지정하지는 않는다). 
       이 경우가 아니라면 특정 <productname>PostgreSQL</productname> 데이터베이스의 이름으로 사용된다. 쉼표로 구분해서 데이터베이스 이름을 여러 개 쓸 수 있다. 데이터베이스 이름이 포함된 파일은 파일 이름 앞에 <literal>@</literal>를 붙여서 지정 가능하다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <para>
       이 레코드와 일치하는 데이터베이스 사용자 이름을 지정한다. <literal>all</literal> 값은 모든 사용자와 일치하도록 지정한다. 이 외에는, 특정한 데이터베이스 사용자의 이름이거나, 앞에 <literal>+</literal>를 붙인 그룹 이름이다. (<productname>PostgreSQL</productname>에서는 사용자와 그룹 이름 간에 실제로 차이는 없다. 
       <literal>+</literal> 마크는 실제로 <quote>이 role의 직접 또는 간접 멤버인 아무 role과 일치함</quote>을 의미하며, <literal>+</literal> 마크가 없는 이름은 유일하게 특정 role과 일치한다.) 
       이러한 이유로, 수퍼유저는 단지 수퍼유저라는 이유 때문이 아니라, 직간접적으로 role의 명시적 멤버인 경우에만 role 멤버로 간주된다. 
       쉼표로 구분함해서 사용자 이름을 여러 개 쓸 수 있다. 사용자 이름이 포함된 파일은 파일 이름 앞에 <literal>@</literal>를 붙여서 지정 가능하다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <para>
       이 레코드가 일치하는 클라이언트 머신 주소(들)를 지정한다.  이 필드는
       호스트 이름, IP 주소 범위 또는 아래 설명된 특수 키워드 중 하나를
       포함할 수 있다.
      </para>

      <para>
       IP 주소 대역은 <acronym>CIDR</acronym> 표기법을 사용하며, 
       빗금 기호를 기준으로 왼쪽은 시작 주소, 오른쪽은 마스크 길이를 지정한다.
       마스크 길이는 일치해야 하는 클라이언트 IP 주소의 상위 비트 수를 나타낸다.
       이것의 오른쪽에 있는 비트는 주어진 IP 주소에서 0이어야 한다. 
       IP 주소, <literal>/</literal> 및 CIDR 마스크 길이 사이에 공백이 있으면 안 된다.
      </para>

      <para>
       이러한 방법으로 지정된 IPv4 주소 범위의 전형적인 예시는
       단일 호스트의 경우 <literal>172.20.143.89/32</literal>,
       소규모 네트워크의 경우 <literal>172.20.143.0/24</literal>,
       대규모 네트워크의 경우 <literal>10.6.0.0/16</literal>일 수 있다. 
       IPv6 주소인 경우는,
       단일 호스트 루프백 주소는 <literal>::1/128</literal>,
       소규모 네트워크인 경우는 <literal>fe80::7a31:c1ff:0000:0000/96</literal>
       형태이다.
       <literal>0.0.0.0/0</literal>은 모든 IPv4 주소를 나타내며
       <literal>::0/0</literal>은 모든 IPv6 주소를 나타낸다. 
       단일 호스트를 지정하려면 IPv4의 마스크 길이값으로 32를 사용하고
       IPv6의 경우 128을 사용해야 한다.
       <acronym>CIDR</acronym> 표기의 시작 주소를 지정할 때는 끝 값이 0이어도 
       생략할 수 없음을 주의 해야 한다.
      </para>

      <para>
       클라이언트가 IPv4 주소로 연결을 시도하면, IPv4 주소 항목에서만 인증 처리를 하고,
       IPv6로 연결을 시도하면, IPv6 주소 항목에서만 인증 처리를 한다.
       즉, <literal>127.0.0.1</literal> 주소와 <literal>::1/128</literal> 같은
       루프백일지라도 각각 처리 된다.
       IPv6 형식의 항목은 표시된 주소가 IPv4-in-IPv6 범위 내이더라도 IPv6 연결만 
       고려한다.
       IPv6 형식의 항목은 시스템의 C 라이브러리가 IPv6 주소를 지원하지 않는 경우 거부된다.
      </para>

      <para>
       사용자는 아무 IP 주소나 일치하도록 <literal>all</literal>을 쓸 수도 있고, 
       서버의 자체 IP 주소 아무거나 일치하도록 <literal>samehost</literal>를 
       쓸 수도 있고, 서버가 직접 연결되는 서브넷의 아무 주소나 
       일치하도록 <literal>samenet</literal>을 쓸 수도 있다.
      </para>

      <para>
       호스트 이름이 지정된 경우(IP 주소 범위가 아니거나 위에서 설명한 특수 예약어로
       호스트 이름을 지정한 경우), 해당 이름은 클라이언트 IP 주소의 
       역방향 이름 분석 결과와 비교된다(예: DNS가 사용되는 경우 역방향 DNS 조회).
       호스트 이름 비교는 대소문자를 구분하지 않는다. 
       일치가 있는 경우, 순방향 이름 분석(예: 순방향 DNS 조회)은 분석할 주소가 클라이언트의 IP 주소와 동일한지 검사하기 위해 호스트 이름에 대해 수행한다. 양방향으로 일치할 경우 항목이 일치하는 것으로 간주된다. 
       (<filename>pg_hba.conf</filename>에서 사용되는 호스트 이름은 클라이언트 IP 주소의 주소-이름 분석(address-to-name resolution)이 리턴하는 것이어야 하며, 아닐 경우 줄이 일치하지 않게 된다. 
       일부 호스트 이름 데이터베이스는 IP 주소를 호스트 이름 여러 개와 연결하는 것을 허용하지만, IP 주소를 분석하도록 요청된 경우 운영 체제는 호스트 이름을 하나만 리턴한다.
      </para>

      <para>
       점(<literal>.</literal>)으로 시작되는 호스트 이름 규격은 실제 호스트 이름의 접미사와 일치한다. 
       따라서, <literal>.example.com</literal>은 <literal>foo.example.com</literal>과 일치하게 된다(<literal>example.com</literal>만으로는 일치하지 않음).
      </para>

      <para>
       호스트 이름이 <filename>pg_hba.conf</filename>에 지정된 경우 이름 분석이 상당히 빠른지 확인해야 한다. 
       <command>nscd</command> 같은 로컬 이름 분석 캐시를 설정하는 것이 유리할 수 있다. 
       또한 사용자는 환경 설정 매개 변수 <varname>log_hostname</varname>을 활성화하여 로그의 IP 주소 대신 클라이언트의 호스트 이름을 볼 수 있다.
      </para>

      <para>
       이 필드는 <literal>local</literal> 레코드에는 사용할 수 없다.
      </para>

      <note>
       <para>
        클라이언트 IP 주소의 역방향 조회를 비롯한 두 가지 이름 분석 같이 이렇게 복잡한 방식으로 호스트 이름을 처리하는 이유를 궁금해 하는 사용자도 있다. 
        이것은 클라이언트의 역방향 DNS 항목이 설정되지 않았거나 바람직하지 않은 호스트 이름을 넘겨주는 경우에는 기능 사용을 복잡하게 만든다. 이것은 기본적으로 효율성을 위한 것이다. 
        이와 같은 연결 시도는 기껏해야 두 가지 리졸버(resolver) 조회(역방향 하나 및 순방향 하나)를 시도한다. 일부 주소에 리졸버(resolver) 문제가 있는 경우 이것은 해당 클라이언트만의 문제이다. 
        순방향 조회만 수행했던 가상적 대안의 구현은 <filename>pg_hba.conf</filename>에 나오는 모든 호스트 이름을 연결 시도할 때마다 분석해야 한다. 이름이 많을 경우 속도가 매우 느려진다. 
        그리고, 호스트 이름 중 한 가지에 리졸버(resolver) 문제가 있는 경우 이것은 전체의 문제가 된다.
       </para>

       <para>
        또한, 패턴 일치를 위해서는 실제 클라이언트 호스트 이름을 알고 있어야 하므로 역방향 조회는 접미사 일치 기능을 구현할 필요가 있다.
       </para>

       <para>
        이러한 동작은 Apache HTTP 서버 및 TCP 래퍼 같은 다른 유명한 호스트 이름 기반 액세스 제어 구현과 일치한다.
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <para>
       이 두 필드는 <replaceable>IP-주소</replaceable><literal>/</literal><replaceable>마스크길이</replaceable>
       표기의 대안으로 사용될 수 있다. 마스크 길이를 지정하는 대신,
       실제 마스크를 지정한다.
       예를 들면, <literal>255.0.0.0</literal>은 IPv4 CIDR 마스크 길이 8을 나타내고,
       <literal>255.255.255.255</literal>는 CIDR 마스크 길이 32를 나타낸다.
      </para>

      <para>
       이 필드는 <literal>local</literal> 레코드에는 사용할 수 없다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-method</replaceable></term>
     <listitem>
      <para>
       연결이 이 레코드와 일치할 때 사용하는 인증 방법을 지정한다. 
       가능한 선택안이 여기에 요약되어 있다. 자세한 내용은 <xref linkend="auth-methods"/>을 참조 바란다.

       <variablelist>
        <varlistentry>
         <term><literal>trust</literal></term>
         <listitem>
         <para>
          무조건 연결을 허용한다. 이 방법은 패스워드나 다른 인증 없이 임의의 <productname>PostgreSQL</productname> 데이터베이스 사용자로 로그인하여 누구나 <productname>PostgreSQL</productname> 데이터베이스 서버에 연결할 수 있다. 
          자세한 내용은 <xref
          linkend="auth-trust"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>reject</literal></term>
        <listitem>
         <para>
          무조건 연결을 거부한다. 이것은 그룹에서 특정 호스트를 <quote>필터링</quote>할 때 유용하다. 
          예를 들면, <literal>reject</literal> 줄은 특정 호스트의 연결을 차단하고, 그 이후의 줄은 특정 네트워크에서 나머지 호스트의 연결을 허용한다.
         </para>
        </listitem>
       </varlistentry>

      <varlistentry>
        <term><literal>scram-sha-256</literal></term>
        <listitem>
         <para>
          Perform SCRAM-SHA-256 authentication to verify the user's
          password. See <xref linkend="auth-password"/> for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>md5</literal></term>
        <listitem>
         <para>
          Perform SCRAM-SHA-256 or MD5 authentication to verify the
          user's password. See <xref linkend="auth-password"/>
          for details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</literal></term>
        <listitem>
         <para>
          클라이언트가 인증을 위해 암호화되지 않은 패스워드를 제공해야 한다. 
          패스워드는 네트워크 상에서 일반 텍스트로 전송되므로 신뢰하지 않는 네트워크에서 이것을 사용하면 안 된다. 
          자세한 내용은 <xref linkend="auth-password"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</literal></term>
        <listitem>
         <para>
          GSSAPI를 사용하여 사용자를 인증한다.  이것은
          TCP/IP 연결에서만 사용할 수 있다. 자세한 내용은 <xref
          linkend="gssapi-auth"/>을 참조 바란다.  이것은
          GSSAPI 암호화와 함께 사용할 있다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</literal></term>
        <listitem>
         <para>
          SSPI를 사용하여 사용자를 인증한다. 이것은 Windows에서만 사용할 수 있다. 자세한 내용은 <xref
          linkend="sspi-auth"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</literal></term>
        <listitem>
         <para>
          클라이언트의 ident 서버에 접촉함으로써 클라이언트의 운영 체제 사용자 이름을 획득하고, 요청된 데이터베이스 사용자 이름과 일치하는지 확인한다. 
          Ident 인증은 TCP/IP 연결에서만 사용할 수 있다. 
          로컬 연결에 대해 지정하는 경우 피어(peer) 인증이 대신 사용된다. 자세한 내용은 <xref linkend="auth-ident"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</literal></term>
        <listitem>
         <para>
          클라이언트의 운영 체제 사용자 이름을 운영 체제에서 획득하고, 요청된 데이터베이스 사용자 이름과 일치하는지 확인한다. 
          이것은 로컬 연결에서만 사용할 수 있다. 자세한 내용은 <xref linkend="auth-peer"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</literal></term>
        <listitem>
         <para>
          <acronym>LDAP</acronym> 서버를 사용하여 인증한다. 자세한 내용은 <xref
          linkend="auth-ldap"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</literal></term>
        <listitem>
         <para>
          RADIUS 서버를 사용하여 인증한다. 자세한 내용은 <xref
          linkend="auth-radius"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</literal></term>
        <listitem>
         <para>
          SSL 클라이언트 인증을 사용하여 인증한다. 자세한 내용은 <xref linkend="auth-cert"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</literal></term>
        <listitem>
         <para>
          운영 체제에서 제공하는 PAM(Pluggable Authentication Modules)을 사용하여 인증한다. 
          자세한 내용은 <xref
          linkend="auth-pam"/>을 참조 바란다.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>bsd</literal></term>
        <listitem>
         <para>
          운영체제에서 제공하는 BSD 인증 서비스를 이용해서 인증한다. 아래
          <xref linkend="auth-bsd"/>에서 자세히 설명한다.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <para>
       <replaceable>auth-method</replaceable> 필드 이후에 인증 방법에 대한 옵션을 지정하는 <replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable> 형식의 필드가 있을 수 있다. 
       인증 방법에서 사용할 수 있는 옵션에 대한 자세한 내용은 아래에 나와 있다.
      </para>
      <para>
       In addition to the method-specific options listed below, there is one
       method-independent authentication option <literal>clientcert</literal>, which
       can be specified in any <literal>hostssl</literal> record.
       This option can be set to <literal>verify-ca</literal> or
       <literal>verify-full</literal>. Both options require the client
       to present a valid (trusted) SSL certificate, while
       <literal>verify-full</literal> additionally enforces that the
       <literal>cn</literal> (Common Name) in the certificate matches
       the username or an applicable mapping.
       This behavior is similar to the <literal>cert</literal> authentication
       method (see <xref linkend="auth-cert"/>) but enables pairing
       the verification of client certificates with any authentication
       method that supports <literal>hostssl</literal> entries.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   <literal>@</literal> 구문이 포함된 파일은, 공백 또는 쉼표로 구분된 이름 목록으로 읽는다. 
   <filename>pg_hba.conf</filename>처럼 <literal>#</literal>로 표시된 주석 및 중첩된 <literal>@</literal> 구문이 허용된다. 파일 이름 뒤에 <literal>@</literal>가 나오는 것이 절대 경로가 아니면 참고 파일이 있는 디렉터리의 상대 경로로 취급된다.
  </para>

  <para>
   <filename>pg_hba.conf</filename> 레코드는 각 연결 시도에 대해 순차적으로 검사되므로 레코드의 순서는 중요하다. 일반적으로 초기 레코드는 연결 일치 매개 변수는 치밀하고, 인증 방법은 느슨한 반면, 후기 레코드는 일치 매개 변수는 느슨하고 인증 방법은 강력하다. 
   예를 들면, 로컬 TCP/IP 연결에 대한 <literal>trust</literal> 인증을 사용하려고 하면서 원격 TCP/IP 연결을 원할 수도 있다. 이런 경우 127.0.0.1로부터 연결을 위한 <literal>trust</literal> 인증을 지정한 레코드는 다양한 허용 클라이언트 IP 주소에 대해 패스워드 인증을 지원하는 레코드 앞에 나타난다.
  </para>

  <para>
   <filename>pg_hba.conf</filename> 파일은 시작 시 및 메인 서버 프로세스가 <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm> 신호를 수신하면 읽어오기 된다. 
   활성 시스템에서 파일을 편집하는 경우 파일을 다시
   읽어오려면 postmaster에 신호를 전송해야 한다
   (<literal>pg_ctl reload</literal> 또는 <function>pg_reload_conf()</function>
   SQL 함수 호출 또는  <literal>kill -HUP</literal> 사용).
  </para>

  <note>
   <para>
    The preceding statement is not true on Microsoft Windows: there, any
    changes in the <filename>pg_hba.conf</filename> file are immediately
    applied by subsequent new connections.
   </para>
  </note>

  <para>
   The system view
   <link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>
   can be helpful for pre-testing changes to the <filename>pg_hba.conf</filename>
   file, or for diagnosing problems if loading of the file did not have the
   desired effects.  Rows in the view with
   non-null <structfield>error</structfield> fields indicate problems in the
   corresponding lines of the file.
  </para>

  <tip>
   <para>
    특수한 데이터베이스에 연결하려면 <filename>pg_hba.conf</filename> 검사만 통과해서는 안 되며 데이터베이스에 대한 <literal>CONNECT</literal> 권한이 사용자에게 있어야 한다. 
    데이터베이스에 연결 가능한 사용자를 제한하고 싶으면 <filename>pg_hba.conf</filename> 항목에 규칙을 입력하는 것보다 <literal>CONNECT</literal> 권한을 부여/취소하는 것이 일반적으로 쉽다.
   </para>
  </tip>

  <para>
   <filename>pg_hba.conf</filename> 항목에 대한 몇 가지 예시가 <xref linkend="example-pg-hba.conf"/>에 나와 있다. 서로 다른 인증 방법에 대한 자세한 내용은 다음 절을 참조 바란다.
  </para>

   <example id="example-pg-hba.conf">
    <title><filename>pg_hba.conf</filename> 항목 예시</title>
<programlisting>
# Allow any user on the local system to connect to any database with
# any database user name using Unix-domain sockets (the default for local
# connections).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# The same using local loopback TCP/IP connections.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# The same as the previous line, but using a separate netmask column
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

# The same over IPv6.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# The same using a host name (would typically cover both IPv4 and IPv6).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# Allow any user from any host with IP address 192.168.93.x to connect
# to database "postgres" as the same user name that ident reports for
# the connection (typically the operating system user name).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# Allow any user from host 192.168.12.10 to connect to database
# "postgres" if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        scram-sha-256

# Allow any user from hosts in the example.com domain to connect to
# any database if the user's password is correctly supplied.
#
# Require SCRAM authentication for most users, but make an exception
# for user 'mike', who uses an older client that doesn't support SCRAM
# authentication.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             .example.com            md5
host    all             all             .example.com            scram-sha-256

# In the absence of preceding "host" lines, these three lines will
# reject all connections from 192.168.54.1 (since that entry will be
# matched first), but allow GSSAPI-encrypted connections from anywhere else
# on the Internet.  The zero mask causes no bits of the host IP address to
# be considered, so it matches any host.  Unencrypted GSSAPI connections
# (which "fall through" to the third line since "hostgssenc" only matches
# encrypted GSSAPI connections) are allowed, but only from 192.168.12.10.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
hostgssenc all          all             0.0.0.0/0               gss
host    all             all             192.168.12.10/32        gss

# Allow users from 192.168.x.x hosts to connect to any database, if
# they pass the ident check.  If, for example, ident says the user is
# "bryanh" and he requests to connect as PostgreSQL user "guest1", the
# connection is allowed if there is an entry in pg_ident.conf for map
# "omicron" that says "bryanh" is allowed to connect as "guest1".
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# If these are the only three lines for local connections, they will
# allow local users to connect only to their own databases (databases
# with the same name as their database user name) except for administrators
# and members of role "support", who can connect to all databases.  The file
# $PGDATA/admins contains a list of names of administrators.  Passwords
# are required in all cases.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# The last two lines above can be combined into a single line:
local   all             @admins,+support                        md5

# The database column can also use lists and file names:
local   db1,db2,@demodbs  all                                   md5
</programlisting>
   </example>
 </sect1>

 <sect1 id="auth-username-maps">
  <title>사용자 이름 맵</title>

  <indexterm zone="auth-username-maps">
   <primary>사용자 이름 맵</primary>
  </indexterm>

  <para>
   Ident 또는 GSSAPI 같은 외부 인증 시스템을 사용하는 경우, 연결을 시작하는 운영 체제 사용자의 이름은 연결해야 하는 데이터베이스 사용자 이름(롤 이름)과 다를 수 있다. 
   이런 경우 사용자 이름 맵을 사용하여 운영 체제 사용자 이름과 데이터베이스 사용자 이름을 매핑할 수 있다. 
   사용자 이름 매핑을 사용하려면 pg_hba.conf 옵션 필드에서 <literal>map</literal>=<replaceable>map-name</replaceable>을 지정해야 한다. 
   이 옵션은 외부 사용자 이름을 수신하는 모든 인증 방법에서 지원된다. 
   서로 다른 연결에 서로 다른 매핑이 필요할 수 있으므로 연결별로 사용할 맵을 지정하기 위해 사용할 맵의 이름은 <filename>pg_hba.conf</filename>의 <replaceable>map-name</replaceable> 매개 변수에서 지정된다.
  </para>

  <para>
   사용자 이름 맵은 ident 맵 파일에서 정의되며, 기본적으로 이름은 <filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>이며 클러스터의 데이터 디렉터리에 저장된다. 
   (맵 파일을 다른 곳에 배치할 수도 있다. <xref linkend="guc-ident-file"/> 환경 설정 매개 변수를 참조 바란다.)
<synopsis>
<replaceable>map-name</replaceable> <replaceable>system-username</replaceable> <replaceable>database-username</replaceable>
</synopsis>
   주석 및 공백은 <filename>pg_hba.conf</filename>에서와 동일하게 처리된다. <replaceable>map-name</replaceable>은 <filename>pg_hba.conf</filename>에서 이 매핑을 참고하기 위해 사용되는 임의의 이름이다. 
   나머지 2개의 필드는 운영 체제 사용자 이름 및 일치하는 데이터베이스 사용자 이름을 지정한다. 
   동일한 <replaceable>map-name</replaceable>을 여러 번 사용해서 단일 맵 내에서 복수의 사용자 매핑을 지정할 수 있다.
  </para>
  <para>
   주어진 한 명의 운영 체제 사용자가 몇 명의 데이터베이스 사용자에 대응하는지에 대해서는 아무런 제한이 없다(그 반대로 마찬가지). 
   따라서, 맵의 항목은 사용자가 동일함을 의미한다기보다 <quote>이 운영 체제 사용자는 이 데이터베이스 사용자로서 연결이 허용된다</quote>로 생각되어야 한다. 
   사용자가 연결 요청을 한 데이터베이스 사용자 이름을 사용하여 외부 인증 시스템에서 획득한 사용자 이름과 쌍을 이루는 맵 항목이 있을 경우 연결이 허용된다.
  </para>
  <para>
   <replaceable>system-username</replaceable> 필드가 슬래시(<literal>/</literal>)로 시작되는 경우 필드의 나머지는 정규식으로 처리된다. (<productname>PostgreSQL</productname>의 정규식 구문에 대한 내용은 <xref linkend="posix-syntax-details"/>을 참조 바란다.) 
   정규식은 단일 캡처 또는 괄호 표현식을 포함할 수 있으며, <literal>\1</literal> (역슬래시 1개)로 <replaceable>database-username</replaceable> 필드에서 참조가 가능하다.  이것은 한 줄로 된 복수의 사용자 이름을 매핑할 수 있으며, 단순 구문 대체 시 특히 유용하다. 
   예를 들면,
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   이 항목은 <literal>@mydomain.com</literal>로 끝나는 시스템 사용자 이름을 사용하여 사용자에 대한 도메인 부분을 삭제하고, 시스템 이름이 <literal>@otherdomain.com</literal>로 끝나는 모든 사용자가 <literal>guest</literal>로 로그인하는 것을 허용한다.
  </para>

  <tip>
   <para>
    기본적으로 정규식은 string의 일부만 일치할 수 있다는 점에 유의해야 한다. 위의 예시처럼 전체 시스템 사용자 이름에 일치되도록 강제하려면 <literal>^</literal> 및 <literal>$</literal>를 사용하는 것이 현명하다.
   </para>
  </tip>

  <para>
   <filename>pg_ident.conf</filename> 파일은 시작 시 및 메인 서버 프로세스가 <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm> 신호를 수신하면 읽어지게 된다. 
   활성 중인 시스템에서 파일을 편집하는 경우 파일을 다시 읽어오려면 postmaster에 신호를 전송해야 한다
   (<literal>pg_ctl reload</literal> 또는 <function>pg_reload_conf()</function> 
   SQL 함수 호출 또는 <literal>kill -HUP</literal> 사용).
  </para>

  <para>
   <xref
   linkend="example-pg-hba.conf"/>에서 <filename>pg_ident.conf</filename> 파일과 함께 사용할 수 있는 <filename>pg_hba.conf</filename> 파일이 <xref
   linkend="example-pg-ident.conf"/>에 나와 있다. 이 예제에서 운영 체제 사용자 이름 <literal>bryanh</literal> 또는 <literal>ann</literal>, <literal>robert</literal>가 없는 192.168 네트워크에서 머신에 로그인한 사용자는 액세스 권한을 부여 받지 못한다. 
   Unix 사용자 <literal>robert</literal>는 <literal>robert</literal> 또는 다른 사람이 아니라 <productname>PostgreSQL</productname> 사용자인 <literal>bob</literal>으로 연결을 시도하는 경우에만 액세스가 허용된다. 
   <literal>ann</literal>은 <literal>ann</literal>으로 연결할 때만 허용된다. 사용자 <literal>bryanh</literal>은 <literal>bryanh</literal> 또는 <literal>guest1</literal>일 때만 연결이 허용된다.
  </para>

  <example id="example-pg-ident.conf">
   <title><filename>pg_ident.conf</filename> 파일 예시</title>
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
# bob has user name robert on these machines
omicron         robert                  bob
# bryanh can also connect as guest1
omicron         bryanh                  guest1
</programlisting>
  </example>
 </sect1>

 <sect1 id="auth-methods">
  <title>인증 방법</title>

  <para>
   <productname>PostgreSQL</productname> 다음과 같은 다양한
   사용자 인증 방법을 제공한다:

   <itemizedlist>
    <listitem>
     <para>
      <link linkend="auth-trust">Trust authentication</link>, which
      simply trusts that users are who they say they are.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-password">Password authentication</link>, which
      requires that users send a password.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="gssapi-auth">GSSAPI authentication</link>, which
      relies on a GSSAPI-compatible security library.  Typically this is
      used to access an authentication server such as a Kerberos or
      Microsoft Active Directory server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="sspi-auth">SSPI authentication</link>, which
      uses a Windows-specific protocol similar to GSSAPI.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ident">Ident authentication</link>, which
      relies on an <quote>Identification Protocol</quote> (RFC 1413)
      service on the client's machine.  (On local Unix-socket connections,
      this is treated as peer authentication.)
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-peer">Peer authentication</link>, which
      relies on operating system facilities to identify the process at the
      other end of a local connection.  This is not supported for remote
      connections.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ldap">LDAP authentication</link>, which
      relies on an LDAP authentication server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-radius">RADIUS authentication</link>, which
      relies on a RADIUS authentication server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-cert">Certificate authentication</link>, which
      requires an SSL connection and authenticates users by checking the
      SSL certificate they send.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-pam">PAM authentication</link>, which
      relies on a PAM (Pluggable Authentication Modules) library.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-bsd">BSD authentication</link>, which
      relies on the BSD Authentication framework (currently available
      only on OpenBSD).
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Peer authentication is usually recommendable for local connections,
   though trust authentication might be sufficient in some circumstances.
   Password authentication is the easiest choice for remote connections.
   All the other options require some kind of external security
   infrastructure (usually an authentication server or a certificate
   authority for issuing SSL certificates), or are platform-specific.
  </para>

  <para>
   인증 방법은 다음 장부터 자세히 다룬다.
  </para>
 </sect1>

  <sect1 id="auth-trust">
   <title>트러스트 인증</title>

   <para>
    <literal>trust</literal> 인증이 지정된 경우 <productname>PostgreSQL</productname>는 지정한 데이터베이스 사용자 이름을 사용하여 서버에 연결 가능한 모든 이가 데이터베이스 액세스에 대한 인증을 받는 것으로 간주한다(수퍼유저 이름 포함). 
    물론, <literal>database</literal> 및 <literal>user</literal> 컬럼의 제한도 계속 적용된다. 
    이 방법은 서버 연결에 대한 적절한 운영 체제 수준의 보호가 제공되는 경우에만 사용되어야 한다.
   </para>

   <para>
    <literal>trust</literal> 인증은 단일 사용자 워크스테이션에 대한 로컬 연결 시 적절하며, 매우 편리하다. 다중 사용자 머신에서는 일반적으로 적절하지 <emphasis>않다</emphasis>. 
    그러나, 파일 시스템 권한을 사용하여 서버의 Unix 도메인 소켓 파일에 대한 액세스를 제한하는 경우 다중 사용자 머신에서도 <literal>trust</literal>를 사용 가능할 수 있다. 
    이렇게 하려면 <varname>unix_socket_permissions</varname>(및 가능하면 <varname>unix_socket_group</varname>) 환경 설정 매개 변수를 <xref linkend="runtime-config-connection"/>에서 설명한 대로 설정해야 한다. 
    또는 <varname>unix_socket_directories</varname> 환경 설정 매개 변수를 설정하여 소켓 파일을 적절히 제한된 디렉터리에 배치할 수 있다.
   </para>

   <para>
    파일 시스템 권한 설정은 Unix 소켓 연결 시에만 유용하다. 로컬 TCP/IP 연결은 파일 시스템 권한에 의해 제한되지 않는다. 
    따라서 로컬 보안을 위해 파일 시스템 권한을 사용하려면 <literal>host ... 127.0.0.1 ...</literal> 줄을 <filename>pg_hba.conf</filename>에서 삭제하거나, 비 <literal>trust</literal> 방법으로 변경해야 한다.
   </para>

   <para>
    <literal>trust</literal> 인증은 <literal>trust</literal>를 지정하는 <filename>pg_hba.conf</filename> 줄에 의해 서버로의 연결이 허용된 모든 머신의 모든 사용자를 신뢰하는 경우에 TCP/IP 연결에 대해서만 적합하다. 
    <systemitem>localhost</systemitem>(127.0.0.1) 외에 TCP/IP 연결에 대해 <literal>trust</literal>를 사용하는 것은 별로 합당하지 않다.
   </para>

  </sect1>

  <sect1 id="auth-password">
   <title>패스워드 인증</title>

   <indexterm>
    <primary>MD5</primary>
   </indexterm>
   <indexterm>
    <primary>SCRAM</primary>
   </indexterm>
   <indexterm>
    <primary>패스워드</primary>
    <secondary>인증</secondary>
   </indexterm>

   <para>
    There are several password-based authentication methods.  These methods
    operate similarly but differ in how the users' passwords are stored on the
    server and how the password provided by a client is sent across the
    connection.
   </para>

   <variablelist>
    <varlistentry>
     <term><literal>scram-sha-256</literal></term>
     <listitem>
      <para>
       The method <literal>scram-sha-256</literal> performs SCRAM-SHA-256
       authentication, as described in
       <ulink url="https://tools.ietf.org/html/rfc7677">RFC 7677</ulink>.  It
       is a challenge-response scheme that prevents password sniffing on
       untrusted connections and supports storing passwords on the server in a
       cryptographically hashed form that is thought to be secure.
      </para>

      <para>
       This is the most secure of the currently provided methods, but it is
       not supported by older client libraries.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>md5</literal></term>
     <listitem>
      <para>
       The method <literal>md5</literal> uses a custom less secure challenge-response
       mechanism.  It prevents password sniffing and avoids storing passwords
       on the server in plain text but provides no protection if an attacker
       manages to steal the password hash from the server.  Also, the MD5 hash
       algorithm is nowadays no longer considered secure against determined
       attacks.
      </para>

      <para>
       The <literal>md5</literal> method cannot be used with
       the <xref linkend="guc-db-user-namespace"/> feature.
      </para>

      <para>
       To ease transition from the <literal>md5</literal> method to the newer
       SCRAM method, if <literal>md5</literal> is specified as a method
       in <filename>pg_hba.conf</filename> but the user's password on the
       server is encrypted for SCRAM (see below), then SCRAM-based
       authentication will automatically be chosen instead.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>password</literal></term>
     <listitem>
      <para>
       The method <literal>password</literal> sends the password in clear-text and is
       therefore vulnerable to password <quote>sniffing</quote> attacks. It should
       always be avoided if possible. If the connection is protected by SSL
       encryption then <literal>password</literal> can be used safely, though.
       (Though SSL certificate authentication might be a better choice if one
       is depending on using SSL).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>
    <productname>PostgreSQL</productname> 데이터베이스 패스워드는 운영 체제 사용자 패스워드와
    구분된다.  각 데이터베이스 사용자에 대한 패스워드는 <literal>pg_authid</literal>
    시스템 카탈로그에 저장된다.  패스워드는 SQL 명령 <xref linkend="sql-createrole"/>
    및 <xref linkend="sql-alterrole"/>으로 관리할 수 있으며, 예를
    들면 <userinput>CREATE ROLE foo WITH LOGIN PASSWORD 'secret'</userinput>, 
    또는 <application>psql</application> 내장 명령어
    <literal>\password</literal> 같은 작업으로 처리한다.  패스워드가 사용자에 대해 설정되지 않은
    경우 저장된 패스워드는 null이고 패스워드 인증은 해당 사용자에 대해 항상 실패한다.
   </para>

   <para>
    The availability of the different password-based authentication methods
    depends on how a user's password on the server is encrypted (or hashed,
    more accurately).  This is controlled by the configuration
    parameter <xref linkend="guc-password-encryption"/> at the time the
    password is set.  If a password was encrypted using
    the <literal>scram-sha-256</literal> setting, then it can be used for the
    authentication methods <literal>scram-sha-256</literal>
    and <literal>password</literal> (but password transmission will be in
    plain text in the latter case).  The authentication method
    specification <literal>md5</literal> will automatically switch to using
    the <literal>scram-sha-256</literal> method in this case, as explained
    above, so it will also work.  If a password was encrypted using
    the <literal>md5</literal> setting, then it can be used only for
    the <literal>md5</literal> and <literal>password</literal> authentication
    method specifications (again, with the password transmitted in plain text
    in the latter case).  (Previous PostgreSQL releases supported storing the
    password on the server in plain text.  This is no longer possible.)  To
    check the currently stored password hashes, see the system
    catalog <literal>pg_authid</literal>.
   </para>

   <para>
    To upgrade an existing installation from <literal>md5</literal>
    to <literal>scram-sha-256</literal>, after having ensured that all client
    libraries in use are new enough to support SCRAM,
    set <literal>password_encryption = 'scram-sha-256'</literal>
    in <filename>postgresql.conf</filename>, make all users set new passwords,
    and change the authentication method specifications
    in <filename>pg_hba.conf</filename> to <literal>scram-sha-256</literal>.
   </para>
  </sect1>

  <sect1 id="gssapi-auth">
   <title>GSSAPI 인증</title>

   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>

   <para>
    <productname>GSSAPI</productname> is an industry-standard protocol
    for secure authentication defined in
    <ulink url="https://tools.ietf.org/html/rfc2743">RFC 2743</ulink>.
    <productname>PostgreSQL</productname>
    supports <productname>GSSAPI</productname> for authentication,
    communications encryption, or both.
    <productname>GSSAPI</productname> provides automatic authentication
    (single sign-on) for systems that support it. The authentication itself is
    secure.  If <productname>GSSAPI</productname> encryption
    or <acronym>SSL</acronym> encryption is
    used, the data sent along the database connection will be encrypted;
    otherwise, it will not.
   </para>

   <para>
    GSSAPI는 PostgreSQL이 빌드된 경우 활성화되어야 한다.  자세한
    내용은 <xref linkend="installation"/>을 참조 바란다.
   </para>

   <para>
    When <productname>GSSAPI</productname> uses
    <productname>Kerberos</productname>, it uses a standard service
    principal (authentication identity) name in the format
    <literal><replaceable>servicename</replaceable>/<replaceable>hostname</replaceable>@<replaceable>realm</replaceable></literal>.
    The principal name used by a particular installation is not encoded in
    the <productname>PostgreSQL</productname> server in any way; rather it
    is specified in the <firstterm>keytab</firstterm> file that the server
    reads to determine its identity.  If multiple principals are listed in
    the keytab file, the server will accept any one of them.
    The server's realm name is the preferred realm specified in the Kerberos
    configuration file(s) accessible to the server.
   </para>

   <para>
    When connecting, the client must know the principal name of the server
    it intends to connect to.  The <replaceable>servicename</replaceable>
    part of the principal is ordinarily <literal>postgres</literal>,
    but another value can be selected via <application>libpq</application>'s
    <xref linkend="libpq-connect-krbsrvname"/> connection parameter.
    The <replaceable>hostname</replaceable> part is the fully qualified
    host name that <application>libpq</application> is told to connect to.
    The realm name is the preferred realm specified in the Kerberos
    configuration file(s) accessible to the client.
   </para>

   <para>
    The client will also have a principal name for its own identity
    (and it must have a valid ticket for this principal).  To
    use <productname>GSSAPI</productname> for authentication, the client
    principal must be associated with
    a <productname>PostgreSQL</productname> database user name.
    The <filename>pg_ident.conf</filename> configuration file can be used
    to map principals to user names; for example,
    <literal>pgusername@realm</literal> could be mapped to just <literal>pgusername</literal>.
    Alternatively, you can use the full <literal>username@realm</literal> principal as
    the role name in <productname>PostgreSQL</productname> without any mapping.
   </para>

   <para>
    <productname>PostgreSQL</productname> also supports mapping
    client principals to user names by just stripping the realm from
    the principal.  This method is supported for backwards compatibility and is
    strongly discouraged as it is then impossible to distinguish different users
    with the same user name but coming from different realms.  To enable this,
    set <literal>include_realm</literal> to 0.  For simple single-realm
    installations, doing that combined with setting the
    <literal>krb_realm</literal> parameter (which checks that the principal's realm
    matches exactly what is in the <literal>krb_realm</literal> parameter)
    is still secure; but this is a
    less capable approach compared to specifying an explicit mapping in
    <filename>pg_ident.conf</filename>.
   </para>

   <para>
    The location of the server's keytab file is specified by the <xref
    linkend="guc-krb-server-keyfile"/> configuration parameter.
    For security reasons, it is recommended to use a separate keytab
    just for the <productname>PostgreSQL</productname> server rather
    than allowing the server to read the system keytab file.
    Make sure that your server keytab file is readable (and preferably
    only readable, not writable) by the <productname>PostgreSQL</productname>
    server account.  (See also <xref linkend="postgres-user"/>.)
   </para>

   <para>
    The keytab file is generated using the Kerberos software; see the
    Kerberos documentation for details. The following example shows
    doing this using the <application>kadmin</application> tool of
    MIT-compatible Kerberos 5 implementations:
<screen>
<prompt>kadmin% </prompt><userinput>addprinc -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput>
</screen>
   </para>

   <para>
    다음 환경 설정 옵션을 <productname>GSSAPI</productname> 인증용으로 사용할 수 있다:
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        If set to 0, the realm name from the authenticated user principal is
        stripped off before being passed through the user name mapping
        (<xref linkend="auth-username-maps"/>). This is discouraged and is
        primarily available for backwards compatibility, as it is not secure
        in multi-realm environments unless <literal>krb_realm</literal> is
        also used.  It is recommended to
        leave <literal>include_realm</literal> set to the default (1) and to
        provide an explicit mapping in <filename>pg_ident.conf</filename> to convert
        principal names to <productname>PostgreSQL</productname> user names.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        시스템과 데이터베이스 사용자 이름 사이의 매핑을 허용한다.  자세한
        내용은 <xref linkend="auth-username-maps"/>을 참조 바란다. 
        For a GSSAPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        user name used for mapping is
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>, respectively),
        unless <literal>include_realm</literal> has been set to 0, in which case
        <literal>username</literal> (or <literal>username/hostbased</literal>)
        is what is seen as the system user name when mapping.

       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        사용자 보안 주체(principal) 이름과 일치하는 영역(realm)을 설정한다. 이 매개 변수가 설정된 경우 해당 영역(realm)의 사용자만 허용된다. 
        설정되지 않으면 모든 영역(realm)의 사용자가 연결할 수 있으며, 사용자 이름 매핑 완료 여부에 달려 있다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    In addition to these settings, which can be different for
    different <filename>pg_hba.conf</filename> entries, there is the
    server-wide <xref linkend="guc-krb-caseins-users"/> configuration
    parameter.  If that is set to true, client principals are matched to
    user map entries case-insensitively.  <literal>krb_realm</literal>, if
    set, is also matched case-insensitively.
   </para>
  </sect1>

  <sect1 id="sspi-auth">
   <title>SSPI 인증</title>

   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>

   <para>
    <productname>SSPI</productname>는 단일 사인온(sign-on)의 보안 인증을 위한 <productname>Windows</productname> 기술이다. <productname>PostgreSQL</productname>은 <literal>negotiate</literal>모드에서 SSPI를 사용한다. 
    이것은 가능한 경우 <productname>Kerberos</productname>를 사용하고, 그 외에는 <productname>NTLM</productname>으로 자동 폴백(fall back)된다. 
    <productname>SSPI</productname> 인증은 서버와 클라이언트가 모두 <productname>Windows</productname>를 사용하는 경우에만 작동되고, <productname>GSSAPI</productname>를 사용할 수 있는 경우에는 비 Windows에서 작동된다.
   </para>

   <para>
    <productname>Kerberos</productname> 인증 사용 중에는 <productname>SSPI</productname>가 <productname>GSSAPI</productname>와 동일한 방식으로 작동된다. 
    자세한 내용은 <xref linkend="gssapi-auth"/>을 참조 바란다.
   </para>

   <para>
    다음 환경 설정 옵션이 <productname>SSPI</productname>에 대해 지원된다.
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        If set to 0, the realm name from the authenticated user principal is
        stripped off before being passed through the user name mapping
        (<xref linkend="auth-username-maps"/>). This is discouraged and is
        primarily available for backwards compatibility, as it is not secure
        in multi-realm environments unless <literal>krb_realm</literal> is
        also used.  It is recommended to
        leave <literal>include_realm</literal> set to the default (1) and to
        provide an explicit mapping in <filename>pg_ident.conf</filename> to convert
        principal names to <productname>PostgreSQL</productname> user names.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>compat_realm</literal></term>
      <listitem>
       <para>
        If set to 1, the domain's SAM-compatible name (also known as the
        NetBIOS name) is used for the <literal>include_realm</literal>
        option. This is the default. If set to 0, the true realm name from
        the Kerberos user principal name is used.
       </para>
       <para>
        Do not disable this option unless your server runs under a domain
        account (this includes virtual service accounts on a domain member
        system) and all clients authenticating through SSPI are also using
        domain accounts, or authentication will fail.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>upn_username</literal></term>
      <listitem>
       <para>
        If this option is enabled along with <literal>compat_realm</literal>,
        the user name from the Kerberos UPN is used for authentication. If
        it is disabled (the default), the SAM-compatible user name is used.
        By default, these two names are identical for new user accounts.
       </para>
       <para>
        Note that <application>libpq</application> uses the SAM-compatible name if no
        explicit user name is specified. If you use
        <application>libpq</application> or a driver based on it, you should
        leave this option disabled or explicitly specify user name in the
        connection string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        시스템과 데이터베이스 사용자 이름 사이의 매핑을 허용한다. 자세한 내용은 <xref linkend="auth-username-maps"/>을 참조 바란다.
        For a SSPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        user name used for mapping is
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>, respectively),
        unless <literal>include_realm</literal> has been set to 0, in which case
        <literal>username</literal> (or <literal>username/hostbased</literal>)
        is what is seen as the system user name when mapping.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        사용자 보안 주체(principal) 이름과 일치하는 영역(realm)을 설정한다. 이 매개 변수가 설정된 경우 해당 영역(realm)의 사용자만 허용된다. 
        설정되지 않으면 모든 영역(realm)의 사용자가 연결할 수 있으며, 영역은 사용자 이름 매핑 완료 여부에 달려 있다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect1>

  <sect1 id="auth-ident">
   <title>Ident 인증</title>

   <indexterm>
    <primary>ident</primary>
   </indexterm>

   <para>
    ident 인증 방법은 클라이언트의 운영 체제 사용자 이름을 ident 서버로부터 획득하고, 허용된 데이터베이스 사용자 이름으로 사용함으로써 작동된다(선택적 사용자 이름 매핑 사용). 이것은 TCP/IP 연결에서만 지원된다.
   </para>

   <note>
    <para>
     로컬(비 TCP/IP) 연결에 대해 ident를 지정하는 경우 피어(peer) 인증이 대신 사용된다(<xref linkend="auth-peer"/> 참조).
    </para>
   </note>

   <para>
    다음 구성 옵션이 <productname>ident</productname>에 대해 지원된다.
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        시스템과 데이터베이스 사용자 이름 사이의 매핑을 허용한다. 자세한 내용은 <xref linkend="auth-username-maps"/>을 참조 바란다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <quote>신분확인 프로토콜(Identification Protocol)</quote>은 RFC 1413에 설명되어 있다. 실제로 모든 Unix 류의 운영 체제에는 기본적으로 TCP 포트 113에서 listen하는 ident 서버가 내장되어 있다. 
    ident 서버의 기본적인 기능은, <quote>너의 포트 <replaceable>X</replaceable>에서 출력되어 내 포트 <replaceable>Y</replaceable>에 연결되는 연결을 초기화한 사용자는 누구인가?</quote> 같은 질문에 응답하는 것이다. 
    실제 연결이 성립되면 <productname>PostgreSQL</productname>은 <replaceable>X</replaceable>와 <replaceable>Y</replaceable>를 모두 알고 있으므로 연결 클라이언트의 호스트에 대한 정보를 ident 서버에서 얻을 수 있으며, 주어진 연결에서 운영 체제 사용자를 이론적으로 판단할 수 있다.
   </para>

   <para>
    이 방법의 단점은 클라이언트의 무결성에 따라 달라진다. 클라이언트 머신을 신뢰할 수 없거나 손상된 경우 공격자(attacker)는 포트 113에서 프로그램을 실행하고, 선택한 사용자 이름으로 리턴할 수 있다. 
    따라서 인증 방법은 각 클라이언트 머신이 엄격하게 제어되고, 데이터베이스 및 시스템 관리자의 협력이 긴밀하게 이뤄지는 폐쇄된 네트워크의 경우에만 적합하다. 즉, 사용자는 ident 서버가 실행되는 머신을 신뢰해야 한다. 
    다음 경고에 유의해야 한다.
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      신분확인 프로토콜은 인증 또는 액세스 제어 프로토콜로 사용할 수 없다(The Identification Protocol is not intended as an authorization or access control protocol).
     </para>
    </blockquote>
   </para>

   <para>
    일부 ident 서버는 원래 머신의 관리자만 알고 있는 키를 사용하여, 리턴된 사용자 이름을 암호화되도록 하는 비표준 옵션이 있다. 
    <productname>PostgreSQL</productname>는 실제 사용자 이름을 결정하기 위해 리턴된 string의 암호를 해제할 방법이 없으므로 ident 서버에서 <productname>PostgreSQL</productname>을 사용하는 경우에는 이 옵션을 사용해서는 <emphasis>안</emphasis> 된다.
   </para>
  </sect1>

  <sect1 id="auth-peer">
   <title>피어(peer) 인증</title>

   <indexterm>
    <primary>피어</primary>
   </indexterm>

   <para>
    피어(peer) 인증 방법은 클라이언트의 운영 체제 사용자 이름을 커널로부터 획득하고, 허용된 데이터베이스 사용자 이름으로 사용함으로써 작동된다(선택적 사용자 이름 매핑 사용). 
    이 방법은 로컬 연결에만 지원된다.
   </para>

   <para>
    다음 구성 옵션이 <productname>피어</productname>(<productname>peer</productname>)에 대해 지원된다.
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        시스템과 데이터베이스 사용자 이름 사이의 매핑을 허용한다. 자세한 내용은 <xref linkend="auth-username-maps"/>을 참조 바란다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    피어(Peer) 인증은 <function>getpeereid()</function> 함수, <symbol>SO_PEERCRED</symbol> 소켓 매개 변수 또는 유사 메커니즘이 제공되는 운영 체제에서만 사용할 수 있다. 현재 <systemitem class="osname">Linux</systemitem>가 포함되며, 
    <systemitem class="osname">macOS</systemitem> 및 <systemitem class="osname">Solaris</systemitem>를 비롯한 <systemitem class="osname">BSD</systemitem>가 가장 선호된다.
   </para>

  </sect1>

  <sect1 id="auth-ldap">
   <title>LDAP 인증</title>

   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>

   <para>
    이 인증 방법은 패스워드 검증 방법으로 LDAP를 사용할 때 외에는 <literal>password</literal>와 유사하게 작동된다. LDAP는 사용자 이름/패스워드 쌍을 검증할 때에만 사용된다. 
    따라서 LDAP를 인증에 사용하기 전에 사용자가 데이터베이스에 존재해야 한다.
   </para>

   <para>
    LDAP 인증은 2가지 모드로 수행할 수 있다. 간단한 바인딩 모드라고 하는 첫 번째 방법은 서버가 <replaceable>prefix</replaceable> <replaceable>username</replaceable> <replaceable>suffix</replaceable>로 구성된 고유한 이름에 바인딩하는 것이다. 
    일반적으로 <replaceable>prefix</replaceable> 매개 변수는 Active Directory 환경에서 <literal>cn=</literal> 또는 <replaceable>DOMAIN</replaceable><literal>\</literal>을 지정하는 데 사용된다. <replaceable>suffix</replaceable>는 비 Active Directory 환경의 나머지 부분을 지정할 때 사용된다.
   </para>

   <para>
    검색+바인딩 모드라고 하는 두 번째 모드에서 서버는 <replaceable>ldapbinddn</replaceable> 및
    <replaceable>ldapbindpasswd</replaceable>로 지정 및 고정된 사용자 이름과 패스워드를
    사용하여 LDAP 디렉터리에 먼저 바인딩한 다음, 데이터베이스에 로그인하려는 사용자를 검색한다. 
    사용자 및 패스워드가 구성되지 않은 경우 익명 바인딩이 디렉터리에 시도된다.
    <replaceable>ldapbasedn</replaceable>의 서브 트리에서 검색이 수행되고
    <replaceable>ldapsearchattribute</replaceable>에서 지정된 속성과 정확히 일치하는 것을 찾는다. 
    이 검색에서 사용자를 찾았으며, 서버는 연결을 끊고, 로그인이 올바른지 검증하기 위해
    클라이언트에서 지정된 패스워드를 사용하여 이 사용자로 디렉터리에 다시 바인딩한다. 
    이 모드는 Apache <literal>mod_authnz_ldap</literal> 및 <literal>pam_ldap</literal> 같은
    다른 소프트웨어의 LDAP 인증 스키마에서 사용되는 것과 동일하다. 이 방법은 사용자
    개체가 디렉터리에 있는 곳에서 더 많은 유연성을 허용하지만 LDAP 서버에
    대한 2개의 연결이 초래된다.
   </para>

   <para>
    다음 구성 옵션이 양쪽 모드에 사용된다:
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        연결할 LDAP 서버의 이름 또는 IP 주소. 공백으로 구분된 서버를 여러 개 지정할 수 있다.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        연결할 LDAP 서버의 포트 번호. 포트가 지정되지 않으면 LDAP 라이브러리의 기본 포트 설정이 사용된다.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapscheme</literal></term>
      <listitem>
       <para>
        Set to <literal>ldaps</literal> to use LDAPS.  This is a non-standard
        way of using LDAP over SSL, supported by some LDAP server
        implementations.  See also the <literal>ldaptls</literal> option for
        an alternative.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        1로 설정하면 TLS 암호화를 사용하여 PostgreSQL과 LDAP 서버가
        연결된다.  This uses the <literal>StartTLS</literal>
        operation per RFC 4513.  See also the <literal>ldapscheme</literal>
        option for an alternative.
   </para>

   <para>
    Note that using <literal>ldapscheme</literal> or
    <literal>ldaptls</literal> only encrypts the traffic between the
    PostgreSQL server and the LDAP server.  The connection between the
    PostgreSQL server and the PostgreSQL client will still be unencrypted
    unless SSL is used there as well.
   </para>

      </listitem>
     </varlistentry>
    </variablelist>

    다음 옵션은 간단 바인딩 모드에만 사용된다.
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        간단 바인딩 인증 수행 시 DN 바인딩의 사용자 이름 앞에 추가하는 string.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        간단 바인딩 인증 수행 시 DN 바인딩의 사용자 이름 뒤에 추가하는 string.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    다음 옵션은 검색+바인딩 모드에만 사용된다.
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        검색+바인딩 인증 수행 시 사용자 검색을 시작하는 루트 DN.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        검색+바인딩 인증 수행 시 검색 수행하기 위해 디렉터리에 바인딩하는 사용자 DN.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        검색+바인딩 인증 수행 시 검색 수행하기 위해 디렉터리에 바인딩하는 사용자의 패스워드.
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         검색+바인딩 인증 수행 시 검색에서 사용자 이름에 대해 일치하는 속성. 속성이 지정되지 않으면 <literal>uid</literal> 속성이 사용된다.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchfilter</literal></term>
       <listitem>
        <para>
         The search filter to use when doing search+bind authentication.
         Occurrences of <literal>$username</literal> will be replaced with the
         user name.  This allows for more flexible search filters than
         <literal>ldapsearchattribute</literal>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         RFC 4516 LDAP URL. 이것은 다른 LDAP 옵션 중 일부를 좀 더 간결한 표준 형식으로 작성하는 다른 방법이다. 기본값은 다음과 같다.
<synopsis>
ldap[s]://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>][?[<replaceable>filter</replaceable>]]]]
</synopsis>
         <replaceable>scope</replaceable>는 <literal>base</literal>, <literal>one</literal>, <literal>sub</literal> 중 하나여야 하며,
         일반적으로 후자이다.  (The default is <literal>base</literal>, which
         is normally not useful in this application.)  <replaceable>attribute</replaceable> can
         nominate a single attribute, in which case it is used as a value for
         <literal>ldapsearchattribute</literal>.  If
         <replaceable>attribute</replaceable> is empty then
         <replaceable>filter</replaceable> can be used as a value for
         <literal>ldapsearchfilter</literal>.
        </para>

        <para>
         The URL scheme <literal>ldaps</literal> chooses the LDAPS method for
         making LDAP connections over SSL, equivalent to using
         <literal>ldapscheme=ldaps</literal>.  To use encrypted LDAP
         connections using the <literal>StartTLS</literal> operation, use the
         normal URL scheme <literal>ldap</literal> and specify the
         <literal>ldaptls</literal> option in addition to
         <literal>ldapurl</literal>.
        </para>

        <para>
         For non-anonymous binds, <literal>ldapbinddn</literal>
         and <literal>ldapbindpasswd</literal> must be specified as separate
         options.
        </para>

        <para>
         LDAP URL은 현재 Windows가 아니라  with OpenLDAP에서만 지원된다.
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>

   <para>
    간단한 바인딩의 구성 옵션과 검색+바인딩의 옵션을 혼용하는 것은 에러이다.
   </para>

   <para>
    When using search+bind mode, the search can be performed using a single
    attribute specified with <literal>ldapsearchattribute</literal>, or using
    a custom search filter specified with
    <literal>ldapsearchfilter</literal>.
    Specifying <literal>ldapsearchattribute=foo</literal> is equivalent to
    specifying <literal>ldapsearchfilter="(foo=$username)"</literal>.  If neither
    option is specified the default is
    <literal>ldapsearchattribute=uid</literal>.
   </para>

   <para>
     If <productname>PostgreSQL</productname> was compiled with
     <productname>OpenLDAP</productname> as the LDAP client library, the
     <literal>ldapserver</literal> setting may be omitted.  In that case, a
     list of host names and ports is looked up via RFC 2782 DNS SRV records.
     The name <literal>_ldap._tcp.DOMAIN</literal> is looked up, where
     <literal>DOMAIN</literal> is extracted from <literal>ldapbasedn</literal>.
   </para>

   <para>
    간단한 바인딩 LDAP 구성의 예시는 다음과 같다.
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    데이터베이스 사용자 <literal>someuser</literal>로 데이터베이스 서버에 연결이 요청된 경우 PostgreSQL은 DN <literal>cn=someuser, dc=example,
    dc=net</literal> 및 클라이언트에서 제공된 패스워드를 사용하여 LDAP 서버에 바인딩을 시도한다. 
    해당 연결이 성공하면 데이터베이스 액세스가 허용된다.
   </para>

   <para>
    검색+바인딩 구성의 예시는 다음과 같다.
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    데이터베이스 사용자 <literal>someuser</literal>로 데이터베이스 서버에 연결이 요청된 경우 PostgreSQL은 익명으로(<literal>ldapbinddn</literal>가 지정되지 않았으므로) LDAP 서버에 바인딩을 시도하고 지정된 베이스 DN 아래에서 <literal>(uid=someuser)</literal>에 대한 검색을 수행한다. 
    항목이 발견되면 발견된 정보와 클라이언트가 제공한 패스워드를 사용하여 바인딩을 시도한다. 해당 제2차 연결이 성공하면 데이터베이스 액세스가 허용된다.
   </para>

   <para>
    URL로 작성한 동일한 검색+바인딩 구성은 다음과 같다.
<programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    LDAP에 대한 인증을 지원하는 일부 다른 소프트웨어는 동일한 URL 형식을 사용하므로 구성을 공유하기 쉬워진다.
   </para>

   <para>
    Here is an example for a search+bind configuration that uses
    <literal>ldapsearchfilter</literal> instead of
    <literal>ldapsearchattribute</literal> to allow authentication by
    user ID or email address:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchfilter="(|(uid=$username)(mail=$username))"
</programlisting>
   </para>

   <para>
    Here is an example for a search+bind configuration that uses DNS SRV
    discovery to find the host name(s) and port(s) for the LDAP service for the
    domain name <literal>example.net</literal>:
<programlisting>
host ... ldap ldapbasedn="dc=example,dc=net"
</programlisting>
   </para>

   <tip>
    <para>
     LDAP는 주로 쉼표와 공백을 사용하여 DN의 서로 다른 부분을 구분하므로 예시에 표시된 대로 LDAP 옵션을 구성할 때 매개 변수를 큰따옴표로 둘러싸야 하는 경우가 있다.
    </para>
   </tip>

  </sect1>

  <sect1 id="auth-radius">
   <title>RADIUS 인증</title>

   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>

   <para>
    이 인증 방법은 패스워드 검증 방법으로 RADIUS를 사용할 때 외에는 <literal>password</literal>와 유사하게 작동된다. RADIUS는 사용자 이름/패스워드 쌍을 검증할 때에만 사용된다. 따라서 RADIUS를 인증에 사용하기 전에 사용자가 데이터베이스에 존재해야 한다.
    authentication.
   </para>

   <para>
    RADIUS 인증을 사용 중인 경우 구성된 RADIUS 서버로 액세스 요청(Access Request) 메시지가 전송된다. 이 요청은 <literal>Authenticate Only</literal> 유형이며, <literal>user name</literal>, <literal>password</literal>(암호화됨) 및 <literal>NAS Identifier</literal>에 대한 매개 변수가 포함된다. 
    요청은 서버와 공유되는 비밀을 사용하여 암호화된다. RADIUS 
    서버는 <literal>Access Accept</literal> 또는 
    <literal>Access Reject</literal>를 사용하여 이 요청에
    응답한다.  RADIUS 계정에 대한 지원은 없다.
   </para>

   <para>
    Multiple RADIUS servers can be specified, in which case they will
    be tried sequentially. If a negative response is received from
    a server, the authentication will fail. If no response is received,
    the next server in the list will be tried. To specify multiple
    servers, separate the server names with commas and surround the list
    with double quotes. If multiple servers are specified, the other
    RADIUS options can also be given as comma-separated lists, to provide
    individual values for each server. They can also be specified as
    a single value, in which case that value will apply to all servers.
   </para>

   <para>
    다음 구성 옵션이 RADIUS에 대해 지원된다.
     <variablelist>
      <varlistentry>
       <term><literal>radiusservers</literal></term>
       <listitem>
        <para>
         연결할 RADIUS 서버의 DNS 이름 또는 IP 주소. 이 매개 변수는 필수이다. (쉼표 구분으로 여러개 지정 가능)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecrets</literal></term>
       <listitem>
        <para>
         보안을 유지하면서 RADIUS 서버와 통신할 때 사용되는 공유 비밀. 이것은 PostgreSQL 및 RADIUS 서버에서 값이 정확하게 동일해야 한다. 최소 16자의 string이 권장된다. 이 매개 변수는 필수이다.
         <note>
         <para>
          사용되는 암호화 벡터는 <productname>PostgreSQL</productname>가 <productname>OpenSSL</productname>을 지원하도록 빌드된 경우 강력한 방식으로 암호화되어야 한다. 
          그 외의 경우에, RADIUS 서버로의 전송은 보안이 되지 않은 obfuscated로 간주해야 하며, 필요 시 외부 보안 대책을 적용해야 한다.
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusports</literal></term>
       <listitem>
        <para>
         연결할 RADIUS 서버의 포트 번호. 포트가 지정되지 않으면 기본 포트(<literal>1812</literal>)가 사용된다.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifiers</literal></term>
       <listitem>
        <para>
         RADIUS 요청에서 <literal>NAS Identifier</literal>로 사용되는 string. 
         이 매개 변수는 예를 들면, 사용자가 인증하려는 데이터베이스 사용자를 식별하여 RADIUS 서버에서 정책 일치용으로 이용되는 제2의 매개 변수로 사용될 수 있다. 
         식별자가 지정되지 않으면 기본 <literal>postgresql</literal>이 사용된다.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>

   <para>
    If it is necessary to have a comma or whitespace in a RADIUS parameter
    value, that can be done by putting double quotes around the value, but
    it is tedious because two layers of double-quoting are now required.
    An example of putting whitespace into RADIUS secret strings is:
<programlisting>
host ... radius radiusservers="server1,server2" radiussecrets="""secret one"",""secret two"""
</programlisting>
   </para>
  </sect1>

  <sect1 id="auth-cert">
   <title>인증서 인증</title>

   <indexterm zone="auth-cert">
    <primary>인증서</primary>
   </indexterm>

   <para>
    이 인증 방법은 SSL 클라이언트 인증서를 사용하여 인증을 수행한다.  따라서
    SSL 연결에서만 사용 가능하다.  이 인증 방법을 사용하는 경우 서버는 
    클라이언트가 유효한 (신뢰할 수 있는) 인증서를 제공할 것을
    요구한다.  패스워드 없음 프롬프트는
    클라이언트로 전송된다.  인증서의 <literal>cn</literal>(공통 이름) 속성은
    요청된 데이터베이스 사용자 이름과 비교되며, 일치하는 경우 로그인이
    허용된다.  사용자 이름 매핑을 사용하여 <literal>cn</literal>을 데이터베이스
    사용자 이름과 다르게 할 수 있다.
   </para>

   <para>
    다음 구성 옵션이 SSL 인증서 인증에 대해 지원된다.
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        시스템과 데이터베이스 사용자 이름 사이의 매핑을 허용한다. 자세한 내용은 <xref linkend="auth-username-maps"/>을 참조 바란다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    It is redundant to use the <literal>clientcert</literal> option with
    <literal>cert</literal> authentication because <literal>cert</literal>
    authentication is effectively <literal>trust</literal> authentication
    with <literal>clientcert=verify-full</literal>.
   </para>
  </sect1>


  <sect1 id="auth-pam">
   <title>PAM 인증</title>

   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>

   <para>
    이 인증 방법은 인증 메커니즘으로 PAM(Pluggable Authentication Modules)을
    사용하며, 나머지는 <literal>password</literal> 인증 방식과 비슷하다.  기본
    PAM 서비스 이름은 <literal>postgresql</literal>이다.  PAM 인증은 사용자
    이름/비밀번호 조합의 유효성만 검사하거나, 선택적으로
    접속하는 원격 호스트 이름 또는 IP 주소의 유효성을 검사하는데만 사용 된다.
    그래서, PAM 인증에 사용될 사용자 이름은 해당 데이터베이스 사용자로
    먼저 만들어져있어야 한다.  PAM에 대한 자세한 정보는
    <ulink url="https://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</productname> 페이지</ulink>를 참고 바란다.
   </para>

   <para>
    다음 구성 옵션이 PAM에 대해 지원된다.
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        PAM 서비스 이름.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>pam_use_hostname</literal></term>
      <listitem>
       <para>
        Determines whether the remote IP address or the host name is provided
        to PAM modules through the <symbol>PAM_RHOST</symbol> item.  By
        default, the IP address is used.  Set this option to 1 to use the
        resolved host name instead.  Host name resolution can lead to login
        delays.  (Most PAM configurations don't use this information, so it is
        only necessary to consider this setting if a PAM configuration was
        specifically created to make use of it.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <note>
    <para>
     PAM이 <filename>/etc/shadow</filename>를 읽도록 설정된 경우 PostgreSQL 서버는 root가 아닌 다른 사용자로 시작되므로 인증이 실패한다. 단, PAM이 LDAP 또는 다른 인증 방법을 사용하도록 구성된 경우 이것이 실행되지 않는다.
    </para>
   </note>
  </sect1>

  <sect1 id="auth-bsd">
   <title>BSD 인증</title>

   <indexterm zone="auth-bsd">
    <primary>BSD 인증</primary>
   </indexterm>

   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses BSD Authentication
    to verify the password. BSD Authentication is used only
    to validate user name/password pairs. Therefore the user's role must
    already exist in the database before BSD Authentication can be used
    for authentication. BSD 인증 프레임워크는 현재
    OpenBSD에서만 사용할 수 있다.
   </para>

   <para>
    BSD Authentication in <productname>PostgreSQL</productname> uses
    the <literal>auth-postgresql</literal> login type and authenticates with
    the <literal>postgresql</literal> login class if that's defined
    in <filename>login.conf</filename>. By default that login class does not
    exist, and <productname>PostgreSQL</productname> will use the default login class.
   </para>

   <note>
    <para>
     To use BSD Authentication, the PostgreSQL user account (that is, the
     operating system user running the server) must first be added to
     the <literal>auth</literal> group.  The <literal>auth</literal> group
     exists by default on OpenBSD systems.
    </para>
   </note>
  </sect1>

  <sect1 id="client-authentication-problems">
   <title>인증 문제</title>

   <para>
    인증 실패 및 관련 문제는 일반적으로 다음과 같은 에러 메시지를 통해 드러난다.
   </para>

   <para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
    이것은 사용자가 서버와의 접촉에 성공했을 경우 나타날 가능성이 가장 높은 메시지이지만, 통신이 가능한 것은 아니다. 메시지에 나타난 대로, 서버는 <filename>pg_hba.conf</filename> 환경 설정 파일에서 일치하는 항목을 찾기 못해서 연결 요청을 거부했다.
   </para>

   <para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
    이 메시지는 사용자가 서버에 접촉했으며, 통신은 가능하지만 <filename>pg_hba.conf</filename> 파일에 지정된 인증 방법을 통과해야 함을 의미한다. 
    사용자가 입력한 패스워드를 검사하거나, 이러한 인증 유형에 문제가 있는 경우에 사용자의 Kerberos 또는 ident 소프트웨어를 검사해야 한다.
   </para>

   <para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
    표시된 데이터베이스 사용자 이름을 찾지 못했다.
   </para>

   <para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
    연결하려는 데이터베이스가 존재하지 않는다. 데이터베이스 이름을 지정하지 않으면 옳든 아니든, 데이터베이스 사용자 이름이 기본값으로 지정된다.
   </para>

   <tip>
   <para>
    서버 로그에 클라이언트에 리포트된 것보다 더 자세한 인증 실패 정보가 나와 있다. 실패 이유가 명확하지 않은 경우 서버 로그를 확인해야 한다.
   </para>
   </tip>
  </sect1>

 </chapter>
