<!-- doc/src/sgml/xfunc.sgml -->

 <sect1 id="xfunc">
  <title>사용자 정의 함수</title>

  <indexterm zone="xfunc">
   <primary>함수</primary>
   <secondary>사용자 정의</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> 에서는 다음과 같이
   네가지 종류의 함수를 지원한다:

   <itemizedlist>
    <listitem>
     <para>
      쿼리 언어 함수 (<acronym>SQL</acronym>로 만든 함수)
      (<xref linkend="xfunc-sql"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      프로시져 언어 함수 (<application>PL/pgSQL</application>이나
      <application>PL/Tcl</application> 로 만든 함수)
      (<xref linkend="xfunc-pl"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      내장 함수 (<xref linkend="xfunc-internal"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      C-언어 함수 (<xref linkend="xfunc-c"/>)
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   모든 함수는 그 인자 (매개 변수)로 기본 자료형, 복합 자료형, 
   또는 그 조합을 사용할 수 있다.  아울러
   모든 함수는 기본 자료형이나 복합 자료형을 반환할 수 있다. 
   또, 함수는 이 반환을 집합 형태로(레코드 집합) 반환할 수 있다.
  </para>

  <para>
   많은 종류의 함수들은 의사 자료형(다각형 자료형 같은)을 인자로 쓰거나
   반환할 수도 있지만, 그 구현 방법이 다양하다.
   자세한 내용은 각 종류별 함수 설명에서 다룬다.
  </para>

  <para>
   <acronym>SQL</acronym>로 만드는 함수가 제일 쉽다.
   여기서는 이 함수에 대한 이야기로 시작한다.
   <acronym>SQL</acronym> 함수에 대한 기본적인 이야기는
   대부분의 다른 형태의 함수들에서도 그대로 적용 된다.
  </para>

  <para>
   이 장에 이어서,  여기서 다루고 있는 부분을
   좀 더 빠르게 이해하려면 <xref linkend="sql-createfunction"/> 명령의
   설명을 살펴보는 것도 좋다.
   여기서 다루는 몇몇 예제들은 <productname>PostgreSQL</productname>
   소스 디렉터리 안 <filename>src/tutorial</filename> 안 
   <filename>funcs.sql</filename>, <filename>funcs.c</filename>
   파일에서 찾을 수 있다.
  </para>
  </sect1>

  <sect1 id="xproc">
   <title>User-Defined Procedures</title>

  <indexterm zone="xproc">
   <primary>procedure</primary>
   <secondary>user-defined</secondary>
  </indexterm>

   <para>
    A procedure is a database object similar to a function.
    The key differences are:

    <itemizedlist>
     <listitem>
      <para>
       Procedures are defined with the <xref linkend="sql-createprocedure"/>
       command, not <command>CREATE FUNCTION</command>.
      </para>
     </listitem>
     <listitem>
      <para>
       Procedures do not return a function value; hence <command>CREATE
       PROCEDURE</command> lacks a <literal>RETURNS</literal> clause.
       However, procedures can instead return data to their callers via
       output parameters.
      </para>
     </listitem>
     <listitem>
      <para>
       While a function is called as part of a query or DML command, a
       procedure is called in isolation using
       the <xref linkend="sql-call"/> command.
      </para>
     </listitem>
     <listitem>
      <para>
       A procedure can commit or roll back transactions during its
       execution (then automatically beginning a new transaction), so long
       as the invoking <command>CALL</command> command is not part of an
       explicit transaction block.  A function cannot do that.
      </para>
     </listitem>
     <listitem>
      <para>
       Certain function attributes, such as strictness, don't apply to
       procedures.  Those attributes control how the function is
       used in a query, which isn't relevant to procedures.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    The explanations in the following sections about how to define
    user-defined functions apply to procedures as well, except for the
    points made above.
   </para>

   <para>
    Collectively, functions and procedures are also known
    as <firstterm>routines</firstterm><indexterm><primary>routine</primary></indexterm>.
    There are commands such as <xref linkend="sql-alterroutine"/>
    and <xref linkend="sql-droproutine"/> that can operate on functions and
    procedures without having to know which kind it is.  Note, however, that
    there is no <literal>CREATE ROUTINE</literal> command.
   </para>
  </sect1>

  <sect1 id="xfunc-sql">
   <title>쿼리 언어 (<acronym>SQL</acronym>) 함수</title>

   <indexterm zone="xfunc-sql">
    <primary>함수</primary>
    <secondary>사용자 정의</secondary>
    <tertiary>SQL 기반</tertiary>
   </indexterm>

   <para>
    SQL 함수는 여러 개의 SQL 구문을 한 번에 실행 할 수 있으며, 
    그 구문들 가운데 마지막 실행 된 구문의 결과를 반환 한다.
    (집합을 반환하지 않는) 단순 SQL 함수는 마지막 쿼리의 
    결과 가운데 첫 로우를 반환한다.
    (<quote>첫번째 로우</quote>는 <literal>ORDER BY</literal>
    구문을 사용하지 않는 이상 항상 같은 로우를 반환하지 않을 수도 
    있음에 주의해야 한다.)
    실행 된 마지막 쿼리의 결과값이 없는 경우는 null을 
    반환한다.
   </para>

   <para>
    또 달리, SQL 함수가 집합(다중 로우)을 반환 하도록 지정할 수도 있다.
    이렇게 하려면, 함수 만들기 구문의 반환값을 지정할 때,
    <literal>SETOF <replaceable>임의자료형</replaceable></literal> 구문을 
    사용하거나, <literal>RETURNS TABLE(<replaceable>칼럼들</replaceable>)</literal>
    구문을 사용한다.  이런 형태의 함수인 경우는 그 마지막 실행되는 
    쿼리의 모든 결과를 반환한다.  보다 자세한 내용은 아래에서 다룬다.
   </para>

   <para>
    SQL 함수의 내용은 세미콜론으로 구분되는 
    SQL 구문들로 구성되어야 한다. 마지막 SQL 구문 뒤에는 
    세미콜론을 써도 되고 안 써도 된다.  
    함수 반환값으로 <type>void</type>를 지정하지 않았다면,  
    함수 내용의 마지막 쿼리는 <command>SELECT</command> 명령이어야 하고,
    <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>
    명령이라면, <literal>RETURNING</literal> 구문이 있어야 한다.
   </para>

    <para>
     <acronym>SQL</acronym>로 된 어떤 명령들도 한 함수에서
     함께 사용될 수 있다. <command>SELECT</command> 쿼리 뿐만 아니라, 
     자료를 변경 하는 쿼리들 (<command>INSERT</command>,
     <command>UPDATE</command>, 및 <command>DELETE</command> 쿼리들)
     도 함수 내용으로 사용할 수 있으며, 또한 다른 쿼리들도 
     사용할 수 있다. (여기서 기억해야 할 것은 
     트랜잭션을 제어야하는 <command>COMMIT</command>, <command>SAVEPOINT</command>
     같은 명령과, <literal>VACUUM</literal> 명령은 <acronym>SQL</acronym>
     함수 안에서는 사용할 수 없다.)
     반면, 함수 내용의 마지막에 오는 명령은
     <command>SELECT</command> 명령이나, 
     함수의 반환 자료형과 일치하는 <literal>RETURNING</literal> 구문을 
     포함하는 어떤 명령이어야 한다.
     부가적으로, 만일 어떤 작업을 수행하는데, 특별히 반환해야할 
     자료형이 없다면, 함수를 정의할 때 반환값으로 <type>void</type>를
     지정한다.
     다음 예제는 <literal>emp</literal> 테이블에서 
     판매액이 음수인 로우를 지우는 함수를 만들고 실행한 것이다:

<screen>
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)
</screen>
    </para>

    <note>
     <para>
      함수 내용으로 지정된 각 명령은 그 명령이 실행 되는 시점에 
      구문 분석을 한다.  함수의 내용으로 시스템 카탈로그 정보를 변경하는 
      작업 (예, <command>CREATE TABLE</command>)이 있다면, 
      이 작업의 최종 반영은 해당 함수 내용이 모두 정상적으로 진행 되었을 때
      이루워진다.  예를 들어, 
      <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>
      이런 형태로 함수가 만들어졌다면, <command>INSERT</command> 작업을 할 때, 
      <structname>foo</structname> 테이블이 없다며 오류를 낼 것이다.  이런 형태의
      함수를 원한다면, <application>PL/pgSQL</application> 함수로 작성하는 것이 좋다.
     </para>
   </note>

   <para>
    <command>CREATE FUNCTION</command> 명령에서 함수 내용은 하나의 
    문자열로 정의한다. 즉, 그 문자열 안에 어떤 문자열 정의가 필요하다면,
    그것을 위해 문자열 지정 문자(<literal>'</literal> 작은 따옴표)를 하나 더 써야 한다. 
    (<xref linkend="sql-syntax-strings"/> 참고)
    일반적으로 이런 번거로움을 피하기 위해서, 달러 문자를 이용한 
    문자열 표기 규칙을 사용한다(이것에 대한 자세한 이야기는 <xref
    linkend="sql-syntax-dollar-quoting"/>을 참고).
   </para>

   <sect2 id="xfunc-sql-function-arguments">
    <title><acronym>SQL</acronym> 함수 인자</title>

   <indexterm>
    <primary>함수</primary>
    <secondary>이름 기반 인자</secondary>
   </indexterm>

    <para>
     SQL 함수의 인자들은 함수 내용에서 그 이름 기반이나, 번호 기반으로
     참조 될 수 있다. 두 방법에 대한 예제는 아래에 나온다.
    </para>

    <para>
     함수 인자로 이름을 사용하려면, 그냥 함수 내용 안에서 그 이름을 적당한
     위치에서 사용하면 된다.  만일 그 이름이 칼럼 이름과 똑 같다면, 
     해당 칼럼 값이 먼저 사용된다.  그래도 같은 이름을 사용하고 싶다면, 
     <literal><replaceable>함수이름</replaceable>.<replaceable>인자이름</replaceable></literal>
     형태로 함수 이름을 먼저 지정해서 인자 이름을 지정할 수 있고, 
     이 경우도 해당 함수와 테이블 이름이 같다면, 해당 테이블의 해당 칼럼 값이
     사용된다.  이런 경우에도 꼭 함수 인자를 해당 이름으로 사용해야 한다면, 
     테이블이나, 칼럼의 별칭을 이용해야 한다.
    </para>

    <para>
     오래된 번호 기반 함수 인자 사용법은 <literal>$<replaceable>n</replaceable></literal>
     형태다: <literal>$1</literal>은 그 함수의 첫번째 인자를 뜻하며, 
     <literal>$2</literal>는 두번째 인자를 뜻한다.  이런 함수 인자 참조는 
     그 함수 인자를 이름 기반으로 지정했을 때도 그대로 사용할 수 있다.
    </para>

    <para>
     인자가 복합 자료형이라면, 함수 내용에서
     <literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal>
     또는 <literal>$1.<replaceable>fieldname</replaceable></literal>
     형태로 사용한다. 물론 
     인자 이름에서 충돌이 생긴다면, 함수 이름을 함께 사용해서 그 충돌을
     피한다.
    </para>

    <para>
     SQL 함수 인자는 식별자로 사용될 수 없다. 오직 자료의 
     값으로만 사용될 수 있다.  다음 예제는 그 대표적인 예다:
<programlisting>
INSERT INTO mytable VALUES ($1);
</programlisting>
윗 구문은 정상적이지만, 아래 구문은 오류를 낸다.
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
    </para>

    <note>
     <para>
      이름 기반 함수 인자 사용은 <productname>PostgreSQL</productname> 9.2
      버전부터 제공한다.  그 이전 버전에서는 
      <literal>$<replaceable>n</replaceable></literal> 형태의 번호 기반 인자만 사용할 수 있다.
     </para>
    </note>
   </sect2>

   <sect2 id="xfunc-sql-base-functions">
    <title>기본 자료형을 사용하는 <acronym>SQL</acronym> 함수</title>

    <para>
     <acronym>SQL</acronym> 함수의 가장 기본 형태는 다음과 같이 인자가 없고, 
     <type>integer</type> 자료형 같이 기본 자료형을 반환하는 경우다:

<screen>
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-- 함수 내용을 작은 따옴표로 정의한 구문
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1
</screen>
    </para>

    <para>
     윗 예제와 같이 함수 내용에서 반환값에 대한 칼럼 별칭(<literal>result</literal>)을 
     사용할 수는 있지만, 함수 실행 결과에서는 그 이름이 보이지 않는 점을
     기억해야 한다.  결국 <literal>result</literal> 대신에, 
     <literal>one</literal> 이라는 함수 이름이 칼럼 이름으로 사용된다.
    </para>

    <para>
     다음은 
     기본 자료형을 함수 인자로 사용하는 <acronym>SQL</acronym> 함수의
     대표적인 예다:

<screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>

    <para>
     이 함수를 다시 번호 기반 인자를 사용하면 다음과 같다:

<screen>
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>

    <para>
     이런 형태의 실무 함수는 다음과 같은 은행 출금 업무용 함수다:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

     이 함수를 이용해 17번 고객의 통장에서 100 달러를 출금하는 작업:

<programlisting>
SELECT tf1(17, 100.0);
</programlisting>
    </para>

    <para>
     이 예제를 보면, 함수의 첫번째 인자인 <literal>accountno</literal> 인자 이름이
     <literal>bank</literal> 테이블의 칼럼 이름으로도 사용하고 있다면,
     충돌이 일어난다.  <command>UPDATE</command>
     명령에서 인자 값을 전달하기 위해서는 
     <literal>bank.accountno</literal>, <literal>tf1.accountno</literal> 같이 
     각각 구분해서 사용해서 사용해야 한다.
    </para>

    <para>
     좀 더 유연한 함수로 반환값을 무조건 1로 넘기는 것이 아니라, 
     잔액을 반환하도록 하려면 다음과 같이 만들 수 있다:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;
</programlisting>

     윗 함수는 다시 아래와 같이
     <literal>RETURNING</literal> 구문을 이용해서 보다 깔끔하게 만들 수도 있다:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>

    <para>
     If the final <literal>SELECT</literal> or <literal>RETURNING</literal>
     clause in a <acronym>SQL</acronym> function does not return exactly
     the function's declared result
     type, <productname>PostgreSQL</productname> will automatically cast
     the value to the required type, if that is possible with an implicit
     or assignment cast.  Otherwise, you must write an explicit cast.
     For example, suppose we wanted the
     previous <function>add_em</function> function to return
     type <type>float8</type> instead.  It's sufficient to write

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

     since the <type>integer</type> sum can be implicitly cast
     to <type>float8</type>.
     (See <xref linkend="typeconv"/> or <xref linkend="sql-createcast"/>
     for more about casts.)
    </para>
   </sect2>

   <sect2 id="xfunc-sql-composite-functions">
    <title>복합 자료형을 사용하는 <acronym>SQL</acronym> 함수</title>

    <para>
     복합 자료형을 함수의 인자로 사용 할 때, 그 인자는 필요한 인자값 뿐만
     아니라, 해당 인자에 따른 모든 속성(필드)을 포함 한다는 것을 
     기억해 둘 필요가 있다.  예를 들어, 사원 자료가 <type>emp</type>
     테이블에 있고 그 테이블 자체를 함수의 인자로 사용한다면, 
     그 함수는 해당 테이블의 한 로우를 전체를 인자로 사용한다.  
     아래에서 누군가의 매출에 대한 그 두 배를 구하는 
     <function>double_salary</function> 함수를 이 예제로 소개하고 있다:

<screen>
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400
</screen>
    </para>

    <para>
     함수에서 해당 로우의 개별 칼럼을 사용하려면,
     <literal>$1.salary</literal> 형태로 사용한다.
     또한 이 함수를 사용할 때, 입력 인자는 
     <command>SELECT</command> 명령에서 <replaceable>테이블이름</replaceable><literal>.*</literal>
     문자를 사용해서 해당 로우 전체를 지정한다. 
     물론 위 예제와 같은 경우라면, 아래와 같이 참조하는 
     테이블 이름만을 인자로 사용할 수 있다.
<screen>
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     하지만 이 방식은 읽는데 혼란을 초래해 그리 권장하지는 않는다.
     (테이블 로우의 복합 자료형 값을 표시하는 두가지 방법에 대한
     자세한 설명은 <xref linkend="rowtypes-usage"/>에 있다.)
    </para>

    <para>
     가끔 즉석에서 복합 자료형 형태의 인자를 만들어서 함수의
     인자로 사용할 때도 있다.  이럴 때는 <literal>ROW</literal> 구문을
     이용한다.  아래 예제가 그 사용법이다:
<screen>
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</screen>
    </para>

    <para>
     또한 함수의 반환값으로 복합 자료형을 지정할 수 있다.
     아래 예제에서 <type>emp</type> 테이블의 한 로우를 반환하는 함수를 
     만드는 방법을 소개한다:

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

     이 예제에서 처럼 반환하는 자료형은 <type>emp</type> 테이블의
     속성과 일치해야 정상 작동하며, 물론 그 값은 위와 같이 
     각 칼럼의 값으로 임의 상수를 지정할 수도 있다.
    </para>

    <para>
     여기서 이런 함수의 두 가지 속성이 있음을 기억해야 한다:

     <itemizedlist>
      <listitem>
       <para>
        쿼리에서 지정한 칼럼 순서는 복합 자료형의 칼럼 순서와
        정확하게 같아야 한다.
        (칼럼 이름은 위에서 
        설명한 대로 실재 반환할 때의 반환 자료형을 이름을 따른다.)
       </para>
      </listitem>
      <listitem>
       <para>
        그 칼럼의 자료형 또한 복합 자료형의 각 칼럼 자료형과 같아야
        한다.  자료형이 다르면 다음과 같은 오류 메시지를 보여준다:
<screen>
<computeroutput>
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</computeroutput>
</screen>
        기본 자료형을 사용할 때와 마찬가지로, 함수에서는 
        묵시적 형변화과 형변환 지정만 허용하지,
        자동으로 명시적 형변환을 하지 않는다.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     윗 예제와 똑같은 기능을 하는 함수를 다음과 같이 만들 수도 있다:

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;
</programlisting>

     <command>SELECT</command> 명령으로 즉석으로 반환할 자료형에 맞춰 
     한 번에 만든다.  하지만, 실무에서는 그리 좋은 방법은 아니지만,
     로우 전체를 또 다시 다른 함수로 넘겨주는 형태로 사용할 때는
     유용하게 쓰이기도 한다.
     Another example is that if we are trying to write a function that
     returns a domain over composite, rather than a plain composite type,
     it is always necessary to write it as returning a single column,
     since there is no way to cause a coercion of the whole row result.
    </para>

    <para>
     이 함수는 아래와 같이 스칼라 함수를 호출 하듯이 사용할 수 있고:

<screen>
SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")
</screen>

      또는, 아래와 같이 테이블 함수처럼 호출 할 수도 있다:

<screen>
SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)
</screen>

     두 번째 사용법에 대해서는 <xref
     linkend="xfunc-sql-table-functions"/>에서 자세히 다룬다.
    </para>

    <para>
     복합 자료형을 반환하는 함수를 사용할 때,
     그 결과의 한 필드만 사용하려면, 다음과 같이 사용한다:

<screen>
SELECT (new_emp()).name;

 name
------
 None
</screen>

     조심해야 할 것은 해당 함수에 대한 결과에 대해서 그 안에 있는 속성을 
     뜻하기 때문에, 위와 같이 괄호가 필요하다.  만일 
     괄호가 빠지면, 다음과 같은 오류가 발생한다:

<screen>
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</screen>
    </para>

    <para>
     또 다른 방법으로는 뽑으려는 속성을 마치 함수처럼 사용하는 방법도 있다:

<screen>
SELECT name(new_emp());

 name
------
 None
</screen>

     <xref linkend="rowtypes-usage"/>에서 설명하고 있는 것처럼,
     필드 지정방식이나, 함수 지정 방식은 같다.
    </para>

    <para>
     복합 자료형을 반환하는 함수의 또 다른 사용법은
     다음과 같이 그 반환값을 또다른 함수의 입력 인자로 사용하는 것이다:

<screen>
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)
</screen>
    </para>
   </sect2>

   <sect2 id="xfunc-output-parameters">
    <title><acronym>SQL</acronym> 함수에서 출력 매개 변수 사용하기</title>

   <indexterm>
    <primary>함수</primary>
    <secondary>출력 매개 변수</secondary>
   </indexterm>

    <para>
     함수의 반환값을 <firstterm>출력 매개 변수</firstterm>로 지정할 수도 있다.
     다음은 그 예제다:

<screen>
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)
</screen>

     이 함수는 <xref linkend="xfunc-sql-base-functions"/>에서 소개한
     <literal>add_em</literal> 함수와 똑 같은 함수다.
     이렇게 사용하는 이유는 여러 칼럼을 한 번에 반환하려고 할 때 
     편하다. 예를 들어,

<screen>
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)
</screen>

     이런 형태로 이 함수는 임의의 복합 자료형을 반환한다.  이 함수는 
     아래와 같은 방식으로도 구현할 수 있다:

<screen>
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</screen>

     하지만 위와 같이 반환할 복합 자료형을 미리 만들어 그것을 반환하는 
     함수를 만드는 것이 좀 더 명확하다.  출력 매개 변수를 지정할 때 
     사용했던 그 변수 이름은 그 함수 반환값의 칼럼 이름으로 사용된다는 
     점도 기억해야 한다.  이 이름을 생략하면, 서버가 자동으로 부여한다.
    </para>

    <para>
     또 하나 알고 있어야 할 점은 <productname>PostgreSQL</productname>에서
     함수 구분은 그 함수 이름과 입력 인자의 자료형 뿐이다는 것이다.  즉
     같은 이름의 함수에서 같은 이름의 입력 인자로 구성하는데, 
     반환값이 다른 함수는 만들 수 없다.  이 때문에, 만일 반환값을 변경하고자
     한다면, 해당 함수를 지우고 다시 만들어야 한다.  이런 특성 때문에,
     아래 함수를 지우는 두 명령은 동일한 작업을 한다.

<screen>
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</screen>
    </para>

    <para>
     함수 매개 변수 종류는 <literal>IN</literal> (기본값), <literal>OUT</literal>,
     <literal>INOUT</literal>, <literal>VARIADIC</literal> 네 종류다.
     <literal>INOUT</literal> 매개 변수는 입출력이 같은 이름과 같은 자료형 임을
     뜻하고, <literal>VARIADIC</literal> 매개 변수는 여러 인자를 하나의 인자로
     입력하겠다는 것을 뜻한다.  이 부분에 대해서는 다음 절에서 자세히 소개한다.
    </para>
   </sect2>

   <sect2 id="xfunc-sql-variadic-functions">
    <title><acronym>SQL</acronym> 함수에서 여러 인자를 입력하기</title>

    <indexterm>
     <primary>함수</primary>
     <secondary>variadic</secondary>
    </indexterm>

    <indexterm>
     <primary>인자 개수가 가변인 함수</primary>
    </indexterm>

    <para>
     <acronym>SQL</acronym> 함수는 인자의 개수가 가변적인 함수를 
     만들 수 있고, 인자 수가 가변적인 인자는 그 모든 인자가 
     같은 자료형이어야 하며, 모든 인자가 <quote>선택적</quote>일 수
     있다.  이 인자는 통상 인자들 가운데, 맨 뒤에 오고, 
     배열형이어야 하고, 인자를 지정할 때, 앞에
     <literal>VARIADIC</literal> 예약어를 사용한다.  사용 예:

<screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
--------
     -1
(1 row)
</screen>

     위와 같이 <literal>VARIADIC</literal> 예약어로 지정한 인자 수가 가변적인
     인자는 개별 인자처럼 입력하고, 내부적으로는 일차원 배열형으로 처리된다.
     만일 아래와 같이 사용했다면, 오류를 낸다:

<screen>
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- 작동 안함
</screen>

     위와 같이 사용하는 것은 하나의 인자인데, 그 인자가 숫자형 요소들로
     구성된 배열형 인자임을 뜻한다.  이 경우 해당 자료형으로 하는
     함수가 있는지 확인하고, 없으면 오류를 낸다.  위에서 만든 함수라면, 
     해당 인자의 자료형이 숫자형임으로 함수의 인자로는 함수 내용 안에서
     사용할 배열의 요소를 각각 입력한다.
    </para>

    <para>
     가끔 해당 인자가 이미 배열형으로 구성이 된 경우라면, 그것을 다시 
     개별 인자로 분리하지 않고 그냥 앞에 <literal>VARIADIC</literal> 예약어를
     지정해서 이런 인자수가 가변적인 함수의 인자로 바로 수 있다.
     Also,
     this is the only secure way to call a variadic function found in a schema
     that permits untrusted users to create objects; see
     <xref linkend="typeconv-func"/>.  You can do this by
     specifying <literal>VARIADIC</literal> in the call:


<screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</screen>

     이렇게 하면, 이 예약어에 따라 배열의 요소를 각각 함수의 인자로 변환해서
     넘겨주며, <literal>VARIADIC</literal> 인자는 함수의 맨 마지막 인자로 사용
     되어야 한다.
    </para>

    <para>
     <literal>VARIADIC</literal> 인자를 쓰는 경우 빈 배열을 넘기고 싶다면, 
     다음과 같이 빈 배열을 만들어 넘겨야 한다.

<screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</screen>

     단순히 <literal>SELECT mleast()</literal> 형태로 사용한다면, 
     인자가 없는 같은 이름의 또 다른 함수가 없다면, 오류를 낸다. 
     (만일 어떤 함수의 두 번째 인자가 이런 형태라고 하더라도, 
     두 번째 인자는 지정해 주어야 한다. - 인자 개수가 가변인 것이지
     그 인자를 생략할 수는 없다.)
    </para>

    <para>
     이런 처리 방식은 인자 이름 기반 호출 방식(<xref
     linkend="sql-syntax-calling-funcs"/> 참조)에도 
     그대로 적용된다. 
     바른 사용법 예:

<screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>

     하지만, 아래 구문을 오류를 낸다:

<screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>
    </para>
   </sect2>

   <sect2 id="xfunc-sql-parameter-defaults">
    <title><acronym>SQL</acronym> 함수의 인자 기본값 지정</title>

    <indexterm>
     <primary>함수</primary>
     <secondary>인자 기본값</secondary>
    </indexterm>

    <para>
     함수에서 지정하는 인자들의 기본값을 지정할 수 있다.
     기본값은 해당 함수를 호출 할 때, 그 함수에서 사용하는 
     인자를 모두 정확하게 입력하지 않았을 때, 그 기본값으로 
     함수 내용에서 사용한다.  함수 인자의 생략은 항상 마지막 인자만
     생략할 수 있다.  즉 생략된 인자 앞의 인자 또한 기본값이 지정되어
     있다면, 그 인자가 마지막 인자로 처리되어 또 생략할 수 있다.  하지만,
     여러 인자 가운데, 맨 마지막이 아닌 다른 위치의 인자를 생략하고, 
     다음 인자는 사용자 그 값을 지정했다면 오류를 낸다.  (물론
     인자 이름 기반 지정이라면 상관 없다.)
     Whether or not you use it,
     this capability creates a need for precautions when calling functions in
     databases where some users mistrust other users; see
     <xref linkend="typeconv-func"/>.
    </para>

    <para>
     사용 예:
<screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-----
  60
(1 row)

SELECT foo(10, 20);
 foo 
-----
  33
(1 row)

SELECT foo(10);
 foo 
-----
  15
(1 row)

SELECT foo();  -- fails since there is no default for the first argument
ERROR:  function foo() does not exist
</screen>
     기본값을 지정하는 <literal>DEFAULT</literal> 예약어는 
     <literal>=</literal> 문자로 바꿔 쓸 수 있다.
    </para>
   </sect2>

   <sect2 id="xfunc-sql-table-functions">
    <title><acronym>SQL</acronym> 함수에서 테이블 사용</title>

    <para>
     모든 SQL 함수는 <literal>FROM</literal>절에서도 사용할 수 있지만, 
     특히 이 특성은 반환되는 자료형이 복합 자료형인 경우 유용하다.
     함수가 기본 자료형을 반환 한다면, 하나의 칼럼을 가진 테이블을 
     조회 한 것과 같은 형식으로 처리되며, 복합 자료형을 반환한다면,
     그 자료형 각각의 속성이 하나의 칼럼으로 구성된 테이블을 조회하는
     것처럼 처리된다.
    </para>

    <para>
     사용 예:

<screen>
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)
</screen>

     예제처럼 함수 변환값은 마치 일반 테이블처럼 처리된다.
    </para>

    <para>
     주의 해야 할 부분은 윗 예제처럼 함수를 만들 때, <literal>SETOF</literal>
     예약어를 사용하지 않았다면, 하나의 로우만 반환한다.
     이것에 대한 설명은 아래에서 자세히 다룬다.
    </para>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-set">
    <title><acronym>SQL</acronym> 함수에서 집합 반환하기</title>

    <indexterm>
     <primary>함수</primary>
     <secondary>SETOF 사용</secondary>
    </indexterm>

    <para>
     SQL 함수를 만들 때, 그 반환값을 지정하는 부분에서, 
     <literal>SETOF <replaceable>어떤자료형</replaceable></literal> 형태로
     만들면, 함수 내용에 있는 쿼리 결과가 여러 로우인 경우
     해당 되는 그 모든 로우를 반환한다.
    </para>

    <para>
     이런 함수는 <literal>FROM</literal>절에서 호출해서 사용한다.
     이렇게 하면, 함수의 반환값이 마치 테이블인 것 처럼 다룰 수 있게 된다.
     예를 들어, 앞에서 소개한  <literal>foo</literal> 함수를 조금 고쳐
     테이블을 반환할 수 있도록 만들고, 그것을 사용하는 방법을 소개한다:

<programlisting>
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
</programlisting>

     이 쿼리 결과는 아래와 같이 보인다:
<screen>
 fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</screen>
    </para>

    <para>
     또한 출력 매개 변수를 다중으로 그 이름과 함께 지정하는 방식으로도 
     만들 수 있다. 사용예:

<programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
</programlisting>

     함수의 반환값이 단일 로우가 아닌, 다중 로우 형태가 되도록 하려면,
     그 함수의 반환값을 정의할 때, <literal>RETURNS SETOF record</literal>
     형태로 함수를 만든다는 것이 핵심이다.
     윗 예제에서 단일 칼럼만 반환하려면, <type>record</type> 자료형 대신에, 
     그 칼럼의 자료형을 지정하면 된다.
    </para>

    <para>
     이런 함수는 하나의 집합 반환 함수를 여러 번 호출해서 
     쿼리 결과를 만들어 내는데 흔하게 사용된다.
     이 때, 여러 번 호출 때의 함수 인자가 또 다른 집합이 되어
     하나의 쿼리로 여러 작업을 한 번에 할 수 있는 효과를 낸다.
     <xref linkend="queries-lateral"/>에서 설명하고
     있는 <literal>LATERAL</literal> 예약어를 사용하는 것이 
     권장하는 방법이다.
     다음 예제는 집합 반환 함수를 사용해서 계층형 구조를 표현하는 것이다:

<screen>
SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     이 예제는 일반 단순 조인 작업으로는 이런 결과를 얻을 수 없음을 
     보여주는 것이다.  더 나아가 이 기능은 좀 더 복잡한 환경에서도
     이런 작업을 할 때,
     사용자는 별 신경 쓰지 않고 작업을 할 수 있게 한다.
    </para>

    <para>
     집합을 반환하는 함수는 쿼리의 출력 칼럼을 지정하는 
     자리에서도 사용이 가능하다.  
     이렇게 호출되면 각 로우에 대해서 
     각각 함수가 실행되어, 그 함수 또한 여러 로우를 반환할 수 있다.
     이런 방식으로 앞에서 설명한
     쿼리와 같은 결과를 만드는 쿼리는 다음과 같다:

<screen>
SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     이 예제에서 주의 깊게 살펴 볼 부분은 <literal>Child2</literal>, <literal>Child3</literal>
     로우가 보이지 않는 것이다.  왜냐하면, <function>listchildren</function> 함수의
     인자로 이 값이 입력되었을 때 반환값이 없기 때문이다. 
     이는 <literal>LATERAL</literal> 예약어를 사용하는 구문에서도 마찬가지다.
    </para>

    <para>
     <productname>PostgreSQL</productname>'s behavior for a set-returning function in a
     query's select list is almost exactly the same as if the set-returning
     function had been written in a <literal>LATERAL FROM</literal>-clause item
     instead.  For example,
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
     is almost equivalent to
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
     It would be exactly the same, except that in this specific example,
     the planner could choose to put <structname>g</structname> on the outside of the
     nested-loop join, since <structname>g</structname> has no actual lateral dependency
     on <structname>tab</structname>.  That would result in a different output row
     order.  Set-returning functions in the select list are always evaluated
     as though they are on the inside of a nested-loop join with the rest of
     the <literal>FROM</literal> clause, so that the function(s) are run to
     completion before the next row from the <literal>FROM</literal> clause is
     considered.
    </para>

    <para>
     If there is more than one set-returning function in the query's select
     list, the behavior is similar to what you get from putting the functions
     into a single <literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>-clause
     item.  For each row from the underlying query, there is an output row
     using the first result from each function, then an output row using the
     second result, and so on.  If some of the set-returning functions
     produce fewer outputs than others, null values are substituted for the
     missing data, so that the total number of rows emitted for one
     underlying row is the same as for the set-returning function that
     produced the most outputs.  Thus the set-returning functions
     run <quote>in lockstep</quote> until they are all exhausted, and then
     execution continues with the next underlying row.
    </para>

    <para>
     Set-returning functions can be nested in a select list, although that is
     not allowed in <literal>FROM</literal>-clause items.  In such cases, each level
     of nesting is treated separately, as though it were
     a separate <literal>LATERAL ROWS FROM( ... )</literal> item.  For example, in
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
     the set-returning functions <function>srf2</function>, <function>srf3</function>,
     and <function>srf5</function> would be run in lockstep for each row
     of <structname>tab</structname>, and then <function>srf1</function> and <function>srf4</function>
     would be applied in lockstep to each row produced by the lower
     functions.
    </para>

    <para>
     Set-returning functions cannot be used within conditional-evaluation
     constructs, such as <literal>CASE</literal> or <literal>COALESCE</literal>.  For
     example, consider
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
     It might seem that this should produce five repetitions of input rows
     that have <literal>x &gt; 0</literal>, and a single repetition of those that do
     not; but actually, because <function>generate_series(1, 5)</function> would be
     run in an implicit <literal>LATERAL FROM</literal> item before
     the <literal>CASE</literal> expression is ever evaluated, it would produce five
     repetitions of every input row.  To reduce confusion, such cases produce
     a parse-time error instead.
    </para>

    <note>
     <para>
      함수 내용 가운데, 마지막 명령이 <literal>RETURNING</literal> 구문이 있는
      <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command> 명령인 경우,
      그 구문에 오류가 없을 경우, 무조건 해당 자료 변경 작업은 진행을 완료
      한다. 그 함수가 <literal>SETOF</literal> 예약어를 이용한 자료 반환이 아니어도,
      또 반환 로우가 모두 출력되지 않았다 하더라도, 변경 작업은 완료 된다.
      <literal>SETOF</literal> 없는 함수인 경우는
       <literal>RETURNING</literal> 작업으로 출력해야 할 부가적인 로우는 
      내부적으로 무시되고, 마지막 로우만 리턴하겠지만,  테이블 변경 작업은
      모두 수행한다. (그리고, 그 함수가 반환 작업을 하기 전에 그 작업은 
      완료된다.)
     </para>
    </note>

    <note>
     <para>
      Before <productname>PostgreSQL</productname> 10, putting more than one
      set-returning function in the same select list did not behave very
      sensibly unless they always produced equal numbers of rows.  Otherwise,
      what you got was a number of output rows equal to the least common
      multiple of the numbers of rows produced by the set-returning
      functions.  Also, nested set-returning functions did not work as
      described above; instead, a set-returning function could have at most
      one set-returning argument, and each nest of set-returning functions
      was run independently.  Also, conditional execution (set-returning
      functions inside <literal>CASE</literal> etc) was previously allowed,
      complicating things even more.
      Use of the <literal>LATERAL</literal> syntax is recommended when writing
      queries that need to work in older <productname>PostgreSQL</productname> versions,
      because that will give consistent results across different versions.
      If you have a query that is relying on conditional execution of a
      set-returning function, you may be able to fix it by moving the
      conditional test into a custom set-returning function.  For example,
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
      could become
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
      This formulation will work the same in all versions
      of <productname>PostgreSQL</productname>.
     </para>
    </note>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-table">
    <title><acronym>SQL</acronym> 함수에서 <literal>테이블</literal> 반환하기</title>

    <indexterm>
     <primary>함수</primary>
     <secondary>RETURNS TABLE</secondary>
    </indexterm>

    <para>
     함수가 집합을 반환하도록 작성하는 방법 가운데 또 다른 방법은
     <literal>RETURNS TABLE(<replaceable>칼럼들</replaceable>)</literal> 구문을 사용하는 것이다.
     이 방법은 하나 이상의 <literal>OUT</literal> 인자를 지정하고, 
     <literal>SETOF record</literal> 구문을 쓰는 방법과 똑같은 결과를 반환한다.
     이 구문은 최근 SQL 표준을 준수하기 위해서 만들어졌다. 그래서
     기존 방식으로 작성된 구문을 이 구문으로 바꾸는 것이
     쿼리 호환성을 높이는 방법이 될 것이다.
    </para>

    <para>
     다음 예제는 더하기와 곱하기에 대한 것이다:

<programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
</programlisting>

     이 <literal>RETURNS TABLE</literal> 구문을 사용하면,
     <literal>OUT</literal>, <literal>INOUT</literal> 인자는 사용할 수 없다 &mdash; 즉,
     출력에 관련된 모든 칼럼 정의는 <literal>TABLE</literal> 다음에 오는
     칼럼 목록에서 정의해야 한다.
    </para>
   </sect2>

   <sect2 id="xfunc-sql-polymorphic-functions">
    <title>다형 polymorphic <acronym>SQL</acronym> 함수</title>

    <para>
     <acronym>SQL</acronym> 함수는 
     <xref linkend="extend-types-polymorphic"/>에서 소개하고
     있는 다형 자료형을 반환할 수 있다.
     다음은 두 개의 인자를 입력 받아, 그것을 각 요소로
     하는 배열을 반환하는 <function>make_array</function> 함수를 
     만들고 사용한 예다:
<screen>
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)
</screen>
    </para>

    <para>
     여기서 주의할 점은 입력된 인자가 문자열인 경우, 
     자동 형변환이 모호해서 사용자 개입이 필요하다는 것이다.  <literal>'a'::text</literal>
     형태로 이 자료가 <type>text</type> 자료형이라도 지정해 주어야
     한다.  지정하지 않으면, <type>unknown</type> 형으로 간주하는데, 
     배열 요소로 쓸 수 있는 자료형으로는 <type>unknown</type>형을
     쓸 수 없기 때문이다.  이런 자료형 지시자를 추가하지 않으면,
     다음과 같은 오류를 낸다:
<screen>
ERROR:  could not determine polymorphic type because input has type unknown
</screen>
    </para>

    <para>
     With <function>make_array</function> declared as above, you must
     provide two arguments that are of exactly the same data type; the
     system will not attempt to resolve any type differences.  Thus for
     example this does not work:
<screen>
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</screen>
     An alternative approach is to use the <quote>common</quote> family of
     polymorphic types, which allows the system to try to identify a
     suitable common type:
<screen>
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
--------------
 {1,2.5}
(1 row)
</screen>
     Because the rules for common type resolution default to choosing
     type <type>text</type> when all inputs are of unknown types, this
     also works:
<screen>
SELECT make_array2('a', 'b') AS textarray;
 textarray 
-----------
 {a,b}
(1 row)
</screen>
    </para>

    <para>
     다형 인자에 대한 반환 자료형이 고정된 형태는 지원하지만,
     그 반대인 경우는 지원하지 않는다. 사용 예:
<screen>
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</screen>
    </para>

    <para>
     이 다형 기법은 출력 매개 변수에서도 사용될 수 있다. 사용 예:
<screen>
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)
</screen>
    </para>

    <para>
     이 다형 기법은 인자 개수가 가변적인 경우도 사용될 수 있다: 사용 예:
<screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
---------------
 1|4|2
(1 row)
</screen>
    </para>
   </sect2>

   <sect2>
    <title>자국어 정렬과 관계된 <acronym>SQL</acronym> 함수</title>

    <indexterm>
     <primary>collation</primary>
     <secondary>SQL 함수</secondary>
    </indexterm>

    <para>
     SQL 함수에서 하나 이상의 자국어 정렬이 가능한 매개 변수를 사용할 경우,
     자국어 기반 문자열 정렬은 각 개별 인자에서 지정한 자국어 정렬 방법에 
     따른다 (<xref linkend="collation"/> 참조).
     자국어 정렬이 바르게 지정되면,
     (예를 들어, 각각의 정렬 기준이 서로 충돌하지 않는다면,)
     모든 자국어 정렬이 가능한 매개 변수 값들은 그 정렬 기준이 암묵적으로
     적용된다.  이 기능은 함수 내에 자국어 정렬과 관계된 작업이 있어 날 때
     모두 적용된다.  앞에서 만들었던 
     <function>anyleast</function> 함수를 가지고 이 부분에 대한 예제를 살펴보면:
<programlisting>
SELECT anyleast('abc'::text, 'ABC');
</programlisting>
     윗 결과는 데이터베이스 기본 lc_collate 값에 따라 다르다.  <literal>C</literal>
     로케일인 경우는 <literal>ABC</literal>를 보여주지만, 대부분의 다른 
     로케일에서는 <literal>abc</literal>를 보여준다.  인자에 대한 자국어 정렬 
     기준을 강제로 지정하려면, <literal>COLLATE</literal> 절을 다음과 같이
     추가 한다:
<programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
</programlisting>
     다른 방법으로, 이 자국어 정렬 방식을 함수 내용 안에, 
     <literal>COLLATE</literal> 절을 포함 해서 입력 인자 쪽에서 
     개별적으로 지정하는 번거로움을 피할 수도 있다.
     아래 예제는 <function>anyleast</function> 함수에서 입력 받은 자료를 
     함수 내부에서 강제로 <literal>en_US</literal> 문자 정렬로 사용하는 경우다:
<programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
</programlisting>
     하지만, 윗 함수에 자국어 정렬 불가능한 자료형이 입력되면, 
     오류를 낸다는 것에 주의해야 한다.
    </para>

    <para>
     실재 인자에 일반적이지 않은 자국어 정렬 방식을 지정했고, 
     함수의 실 작업에서 사용할 정렬 방식을 결정 할 수 없다면, 
     데이터베이스 기본 정렬 방식을 사용한다. (이 값은 데이터베이스
     lc_collate 값을 말한다.)
    </para>

    <para>
     이 함수 인자에 대한 자국어 정렬 처리 기능은 문자열 자료, 그 문자열
     을 다루는 배열에 대해서만 적용된다.
    </para>
   </sect2>
  </sect1>

  <sect1 id="xfunc-overload">
   <title>함수 오버로드</title>

   <indexterm zone="xfunc-overload">
    <primary>오버로드</primary>
    <secondary>함수</secondary>
   </indexterm>

   <para>
    More than one function can be defined with the same SQL name, so long
    as the arguments they take are different.  In other words,
    function names can be <firstterm>overloaded</firstterm>.  Whether or not
    you use it, this capability entails security precautions when calling
    functions in databases where some users mistrust other users; see
    <xref linkend="typeconv-func"/>.  When a query is executed, the server
    will determine which function to call from the data types and the number
    of the provided arguments.  Overloading can also be used to simulate
    functions with a variable number of arguments, up to a finite maximum
    number.
   </para>

   <para>
    When creating a family of overloaded functions, one should be
    careful not to create ambiguities.  For instance, given the
    functions:
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
    it is not immediately clear which function would be called with
    some trivial input like <literal>test(1, 1.5)</literal>.  The
    currently implemented resolution rules are described in
    <xref linkend="typeconv"/>, but it is unwise to design a system that subtly
    relies on this behavior.
   </para>

   <para>
    A function that takes a single argument of a composite type should
    generally not have the same name as any attribute (field) of that type.
    Recall that <literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal> is considered equivalent
    to <literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>.  In the case that there is an
    ambiguity between a function on a composite type and an attribute of
    the composite type, the attribute will always be used.  It is possible
    to override that choice by schema-qualifying the function name
    (that is, <literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)</literal>) but it's better to
    avoid the problem by not choosing conflicting names.
   </para>

   <para>
    Another possible conflict is between variadic and non-variadic functions.
    For instance, it is possible to create both <literal>foo(numeric)</literal> and
    <literal>foo(VARIADIC numeric[])</literal>.  In this case it is unclear which one
    should be matched to a call providing a single numeric argument, such as
    <literal>foo(10.1)</literal>.  The rule is that the function appearing
    earlier in the search path is used, or if the two functions are in the
    same schema, the non-variadic one is preferred.
   </para>

   <para>
    When overloading C-language functions, there is an additional
    constraint: The C name of each function in the family of
    overloaded functions must be different from the C names of all
    other functions, either internal or dynamically loaded.  If this
    rule is violated, the behavior is not portable.  You might get a
    run-time linker error, or one of the functions will get called
    (usually the internal one).  The alternative form of the
    <literal>AS</literal> clause for the SQL <command>CREATE
    FUNCTION</command> command decouples the SQL function name from
    the function name in the C source code.  For instance:
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
    LANGUAGE C;
</programlisting>
    The names of the C functions here reflect one of many possible conventions.
   </para>
  </sect1>

  <sect1 id="xfunc-volatility">
   <title>휘발성에 따른 함수 분류</title>

   <indexterm zone="xfunc-volatility">
    <primary>휘발성</primary>
    <secondary>함수</secondary>
   </indexterm>
   <indexterm zone="xfunc-volatility">
    <primary>VOLATILE</primary>
   </indexterm>
   <indexterm zone="xfunc-volatility">
    <primary>STABLE</primary>
   </indexterm>
   <indexterm zone="xfunc-volatility">
    <primary>IMMUTABLE</primary>
   </indexterm>

   <para>
    모든 함수는 <firstterm>휘발성</firstterm>이라는 속성에 따라 
    <literal>VOLATILE</literal>, <literal>STABLE</literal>, <literal>IMMUTABLE</literal> 함수로 
    구분 된다.
    <xref linkend="sql-createfunction"/> 명령으로 함수를 만들 때,
    이 속성을 따로 지정하지 않으면, 기본값으로
    <literal>VOLATILE</literal> 속성이 지정된다.
    이 휘발성 속성은 쿼리 최적화기에서 그 함수를 어떻게 처리할 것인가에 대한
    약속이다.

   <itemizedlist>
    <listitem>
     <para>
      <literal>VOLATILE</literal> 함수는 데이터베이스 조작 작업을 포함하는
      대부분의 함수다.
      이런 함수는 같은 매개 변수값에 대해서 다른 결과값을 반환할 수 있다.
      쿼리 최적화기는 이 함수에 대해서는 어떠한 관여도 하지 않는다.
      이 함수를 사용하는 쿼리는 각 로우에 대해서 매번 그 비용을 
      계산 한다.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>STABLE</literal> 함수는 데이터베이스를 조작하는 작업이 없는
      같은 매개 변수값에 항상 같은 결과값을 반환하는 함수다.
      한 쿼리 안에서 이 함수가 사용되면, 쿼리 최적화기는 
      여러 로우 안에서 사용되더라도 한 번 사용하는 것 처럼 그 비용을
      계산 한다.
      특히, 이 함수는 인덱스 검색에서 사용될 수 있다.
      (<literal>VOLATILE</literal> 함수는 반환값이 다를 수 있기 때문에, 
      쿼리 최적화기는 그 값과 비교되는 칼럼에 대한 인덱스 사용여부를
      결정 할 수 없어 인덱스 검색을 하지 않는다.)
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>IMMUTABLE</literal> 함수는 <literal>STABLE</literal> 함수와 같으나, 
      쿼리 최적화기는 이 형태의 함수인 경우 그 반환값을 미리 계산 해서 
      상수로 변경한 다음 처리한다. 예를 들어, 
      <literal>SELECT ... WHERE x = 2 + 2</literal> 구문은 최적화기가
      <literal>SELECT ... WHERE x = 4</literal> 형태로 바꾼다. 왜냐하면,
      정수에 대한 더하기 연산자가 사용하는 함수가 바로 
      <literal>IMMUTABLE</literal> 함수이기 때문이다.
     </para>
    </listitem>
   </itemizedlist>
   </para>

   <para>
    가장 좋은 쿼리 성능을 얻으려면, 자신이 만든 함수에 대해서 
    가장 적당한 휘발성 분류를 지정해 주는 것이다.
   </para>

   <para>
    의도되지 않은 결과를 초래할 수 있는 함수라고 생각되면 
    그 함수는 <emphasis>반드시</emphasis> <literal>VOLATILE</literal> 함수로
    만드는 것이 좋다. 그렇게 해야 최적화기가 실행 계획을 만들 때
    의도되지 않은 엉뚱한 결과를 만들지 않는다.
    물론 그 함수의 내용이 명확하고 다른 부작용도 없다고 확신해도,
    <literal>random()</literal>, <literal>currval()</literal>, <literal>timeofday()</literal>
    이런 함수 같이 변환값이 항상 다른 함수를 사용하는 경우라면,
    <literal>VOLATILE</literal> 함수로 만들어야 한다.
   </para>

   <para>
    다른 중요한 예로, <function>current_timestamp</function> 계열 함수를 
    사용한다면, <literal>STABLE</literal> 함수로 만들어도 괜찮다. 왜냐하면, 
    이 계열 함수들은 하나의 트랜잭션 내에서는 
    항상 같은 값을 반환하기 때문이다.
   </para>

   <para>
    일반적인 대화형 쿼리에서는 <literal>STABLE</literal> 함수나, 
    <literal>IMMUTABLE</literal> 함수 사이 차이가 별로 없다.
    어차피 그 쿼리가 실행 될 때 둘 다, 한 번은 그 함수 처리를 위한 
    비용 계산을 하기 때문이다.
    가장 큰 차이점은 그 실행 계획이 저장되거나 재사용될 경우다.
    <literal>IMMUTABLE</literal> 함수로 만들어,
    그 함수의 반환값이 상수화 되어 실행 계획이 작성되고, 
    그 상수값이 그대로 재사용된다면, 의도하지 않게 나쁜 실행 계획이 
    될 수도 있다. 미리 준비된 구문 prepared statement 을 사용하는 경우나, 
    <application>PL/pgSQL</application> 같이 그 실행 계획이 미리 저장되는 
    프로시져 언어로 작성된 함수에서 이런 위험이 있을 수 있다.
   </para>

   <para>
    SQL이나 표준 프로시져 언어로 작성된 함수에서 주의해야 할 두번째 사항은
    그 함수가 사용되는 쿼리가 반환하는 자료의 가시성 부분이다. 
    <literal>VOLATILE</literal> 함수는 항상 상황에 맞는 결과를 반환하지만,
    <literal>STABLE</literal>, <literal>IMMUTABLE</literal> 함수는 그렇지 않다.
    이 처리 방식은 MVCC (<xref linkend="mvcc"/> 참조) 스냅샷 작동방식을
    사용해서 구현되었다.
    <literal>STABLE</literal>, <literal>IMMUTABLE</literal> 함수는 
    처음 쿼리가 호출 될 때 스냅샷을 찍고, <literal>VOLATILE</literal> 함수는
    해당 쿼리에서 사용될 때 마다 스냅샷을 찍는다.
   </para>

   <note>
    <para>
     C 언어로 함수를 만드는 경우는 이 스냅샷 관리를 자체적으로 할 수도 있지만,
     일반적으로 그 모듈을 이용하는 함수를 만들 때, 그 함수의 휘발성을 
     지정하는 것이 좋은 방법이다.
    </para>
   </note>

   <para>
    이런 스냅샷 처리 방식 때문에, 
    <literal>STABLE</literal> 함수에서는 
    그 해당 자료가 다른 세션에 의해 변경 되었다 하더라도
    안전한 <command>SELECT</command> 작업을 할 수 있다.
    <productname>PostgreSQL</productname>의 
    <literal>STABLE</literal> 함수 안에서 사용되는 명령들은
    스냅샷 처리를 하여, 그 세션이 보아야 할 자료만 각각 볼 수 있다.
   </para>

   <para>
    또한 이 스냅샷 처리 방식의 <command>SELECT</command> 작업은
    <literal>IMMUTABLE</literal> 함수에서도 그대로 적용된다.
    하지만, 그 결과는 <literal>STABLE</literal> 함수와 달리
    의도되지 않은 것일 수 있다. 왜냐하면, 
    해당 테이블의 자료가 다른 세션에 의해 바뀔 수 있기 때문이다.
    그럼에도 불구하고, <productname>PostgreSQL</productname> 이런 문제점에
    대해서 사용자 몫으로 남겨둔다. <literal>IMMUTABLE</literal> 함수에서도
    <command>SELECT</command> 작업을 할 수는 있다.
   </para>

   <para>
    일반적인 오류는 <literal>IMMUTABLE</literal> 함수의 반환값이
    서버 환경 설정 매개 변수값에 영향을 받는 경우다.
    예를 들어, 시간을 처리하는 함수는 <xref linkend="guc-timezone"/>
    설정값에 의존적이다.
    안전을 위해, 이런 함수들은 <literal>STABLE</literal> 함수로 만든다.
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname>에서는
     자료 변경을 방지하기 위해, <literal>STABLE</literal> 또는
     <literal>IMMUTABLE</literal> 함수인 경우 데이터베이스 처리 작업으로
     <command>SELECT</command> 명령만 허용한다.
     (하지만 이처리가 완벽하지는 않다. <literal>VOLATILE</literal> 함수의 
     내용 가운데, <literal>STABLE</literal>, <literal>IMMUTABLE</literal>
     함수를 사용하는 구문이 있고, 이런 함수들의 반환값이 데이터베이스가
     변경 된 부분에 대한 반영을 제대로 했는지를 모두
     꼼꼼하게 검사하지는 못했다.)
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-pl">
   <title>Procedural Language Functions</title>

   <para>
    <productname>PostgreSQL</productname> allows user-defined functions
    to be written in other languages besides SQL and C.  These other
    languages are generically called <firstterm>procedural
    languages</firstterm> (<acronym>PL</acronym>s).
    Procedural languages aren't built into the
    <productname>PostgreSQL</productname> server; they are offered
    by loadable modules.
    See <xref linkend="xplang"/> and following chapters for more
    information.
   </para>
  </sect1>

  <sect1 id="xfunc-internal">
   <title>Internal Functions</title>

   <indexterm zone="xfunc-internal"><primary>function</primary><secondary>internal</secondary></indexterm>

   <para>
    Internal functions are functions written in C that have been statically
    linked into the <productname>PostgreSQL</productname> server.
    The <quote>body</quote> of the function definition
    specifies the C-language name of the function, which need not be the
    same as the name being declared for SQL use.
    (For reasons of backward compatibility, an empty body
    is accepted as meaning that the C-language function name is the
    same as the SQL name.)
   </para>

   <para>
    Normally, all internal functions present in the
    server are declared during the initialization of the database cluster
    (see <xref linkend="creating-cluster"/>),
    but a user could use <command>CREATE FUNCTION</command>
    to create additional alias names for an internal function.
    Internal functions are declared in <command>CREATE FUNCTION</command>
    with language name <literal>internal</literal>.  For instance, to
    create an alias for the <function>sqrt</function> function:
<programlisting>
CREATE FUNCTION square_root(double precision) RETURNS double precision
    AS 'dsqrt'
    LANGUAGE internal
    STRICT;
</programlisting>
    (Most internal functions expect to be declared <quote>strict</quote>.)
   </para>

   <note>
    <para>
     Not all <quote>predefined</quote> functions are
     <quote>internal</quote> in the above sense.  Some predefined
     functions are written in SQL.
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-c">
   <title>C-Language Functions</title>

   <indexterm zone="xfunc-c">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in C</tertiary>
   </indexterm>

   <para>
    User-defined functions can be written in C (or a language that can
    be made compatible with C, such as C++).  Such functions are
    compiled into dynamically loadable objects (also called shared
    libraries) and are loaded by the server on demand.  The dynamic
    loading feature is what distinguishes <quote>C language</quote> functions
    from <quote>internal</quote> functions &mdash; the actual coding conventions
    are essentially the same for both.  (Hence, the standard internal
    function library is a rich source of coding examples for user-defined
    C functions.)
   </para>

   <para>
    Two different calling conventions are currently used for C functions.
    The newer <quote>version 1</quote> calling convention is indicated by writing
    a <literal>PG_FUNCTION_INFO_V1()</literal> macro call for the function,
    as illustrated below.  Lack of such a macro indicates an old-style
    (<quote>version 0</quote>) function.  The language name specified in <command>CREATE FUNCTION</command>
    is <literal>C</literal> in either case.  Old-style functions are now deprecated
    because of portability problems and lack of functionality, but they
    are still supported for compatibility reasons.
   </para>

  <sect2 id="xfunc-c-dynload">
   <title>Dynamic Loading</title>

   <indexterm zone="xfunc-c-dynload">
    <primary>dynamic loading</primary>
   </indexterm>

   <para>
    The first time a user-defined function in a particular
    loadable object file is called in a session,
    the dynamic loader loads that object file into memory so that the
    function can be called.  The <command>CREATE FUNCTION</command>
    for a user-defined C function must therefore specify two pieces of
    information for the function: the name of the loadable
    object file, and the C name (link symbol) of the specific function to call
    within that object file.  If the C name is not explicitly specified then
    it is assumed to be the same as the SQL function name.
   </para>

   <para>
    The following algorithm is used to locate the shared object file
    based on the name given in the <command>CREATE FUNCTION</command>
    command:

    <orderedlist>
     <listitem>
      <para>
       If the name is an absolute path, the given file is loaded.
      </para>
     </listitem>

     <listitem>
      <para>
       If the name starts with the string <literal>$libdir</literal>,
       that part is replaced by the <productname>PostgreSQL</productname> package
        library directory
       name, which is determined at build time.<indexterm><primary>$libdir</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       If the name does not contain a directory part, the file is
       searched for in the path specified by the configuration variable
       <xref linkend="guc-dynamic-library-path"/>.<indexterm><primary>dynamic_library_path</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       Otherwise (the file was not found in the path, or it contains a
       non-absolute directory part), the dynamic loader will try to
       take the name as given, which will most likely fail.  (It is
       unreliable to depend on the current working directory.)
      </para>
     </listitem>
    </orderedlist>

    If this sequence does not work, the platform-specific shared
    library file name extension (often <filename>.so</filename>) is
    appended to the given name and this sequence is tried again.  If
    that fails as well, the load will fail.
   </para>

   <para>
    It is recommended to locate shared libraries either relative to
    <literal>$libdir</literal> or through the dynamic library path.
    This simplifies version upgrades if the new installation is at a
    different location.  The actual directory that
    <literal>$libdir</literal> stands for can be found out with the
    command <literal>pg_config --pkglibdir</literal>.
   </para>

   <para>
    The user ID the <productname>PostgreSQL</productname> server runs
    as must be able to traverse the path to the file you intend to
    load.  Making the file or a higher-level directory not readable
    and/or not executable by the <systemitem>postgres</systemitem>
    user is a common mistake.
   </para>

   <para>
    In any case, the file name that is given in the
    <command>CREATE FUNCTION</command> command is recorded literally
    in the system catalogs, so if the file needs to be loaded again
    the same procedure is applied.
   </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> will not compile a C function
     automatically.  The object file must be compiled before it is referenced
     in a <command>CREATE
     FUNCTION</command> command.  See <xref linkend="dfunc"/> for additional
     information.
    </para>
   </note>

   <indexterm zone="xfunc-c-dynload">
    <primary>magic block</primary>
   </indexterm>

   <para>
    To ensure that a dynamically loaded object file is not loaded into an
    incompatible server, <productname>PostgreSQL</productname> checks that the
    file contains a <quote>magic block</quote> with the appropriate contents.
    This allows the server to detect obvious incompatibilities, such as code
    compiled for a different major version of
    <productname>PostgreSQL</productname>. To include a magic block,
    write this in one (and only one) of the module source files, after having
    included the header <filename>fmgr.h</filename>:

<programlisting>
PG_MODULE_MAGIC;
</programlisting>
   </para>

   <para>
    After it is used for the first time, a dynamically loaded object
    file is retained in memory.  Future calls in the same session to
    the function(s) in that file will only incur the small overhead of
    a symbol table lookup.  If you need to force a reload of an object
    file, for example after recompiling it, begin a fresh session.
   </para>

   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_init</primary>
   </indexterm>
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_fini</primary>
   </indexterm>
   <indexterm zone="xfunc-c-dynload">
    <primary>library initialization function</primary>
   </indexterm>
   <indexterm zone="xfunc-c-dynload">
    <primary>library finalization function</primary>
   </indexterm>

   <para>
    Optionally, a dynamically loaded file can contain initialization and
    finalization functions.  If the file includes a function named
    <function>_PG_init</function>, that function will be called immediately after
    loading the file.  The function receives no parameters and should
    return void.  If the file includes a function named
    <function>_PG_fini</function>, that function will be called immediately before
    unloading the file.  Likewise, the function receives no parameters and
    should return void.  Note that <function>_PG_fini</function> will only be called
    during an unload of the file, not during process termination.
    (Presently, unloads are disabled and will never occur, but this may
    change in the future.)
   </para>

  </sect2>

   <sect2 id="xfunc-c-basetype">
    <title>Base Types in C-Language Functions</title>

    <indexterm zone="xfunc-c-basetype">
     <primary>data type</primary>
     <secondary>internal organization</secondary>
    </indexterm>

    <para>
     To know how to write C-language functions, you need to know how
     <productname>PostgreSQL</productname> internally represents base
     data types and how they can be passed to and from functions.
     Internally, <productname>PostgreSQL</productname> regards a base
     type as a <quote>blob of memory</quote>.  The user-defined
     functions that you define over a type in turn define the way that
     <productname>PostgreSQL</productname> can operate on it.  That
     is, <productname>PostgreSQL</productname> will only store and
     retrieve the data from disk and use your user-defined functions
     to input, process, and output the data.
    </para>

    <para>
     Base types can have one of three internal formats:

     <itemizedlist>
      <listitem>
       <para>
        pass by value, fixed-length
       </para>
      </listitem>
      <listitem>
       <para>
        pass by reference, fixed-length
       </para>
      </listitem>
      <listitem>
       <para>
        pass by reference, variable-length
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     By-value  types  can  only be 1, 2, or 4 bytes in length
     (also 8 bytes, if <literal>sizeof(Datum)</literal> is 8 on your machine).
     You should be careful to define your types such that they will be the
     same size (in bytes) on all architectures.  For example, the
     <literal>long</literal> type is dangerous because it is 4 bytes on some
     machines and 8 bytes on others, whereas <type>int</type> type is 4 bytes
     on most Unix machines.  A reasonable implementation of the
     <type>int4</type> type on Unix machines might be:

<programlisting>
/* 4-byte integer, passed by value */
typedef int int4;
</programlisting>

     (The actual PostgreSQL C code calls this type <type>int32</type>, because
     it is a convention in C that <type>int<replaceable>XX</replaceable></type>
     means <replaceable>XX</replaceable> <emphasis>bits</emphasis>.  Note
     therefore also that the C type <type>int8</type> is 1 byte in size.  The
     SQL type <type>int8</type> is called <type>int64</type> in C.  See also
     <xref linkend="xfunc-c-type-table"/>.)
    </para>

    <para>
     On  the  other hand, fixed-length types of any size can
     be passed by-reference.  For example, here is a  sample
     implementation of a <productname>PostgreSQL</productname> type:

<programlisting>
/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     Only  pointers  to  such types can be used when passing
     them in and out of <productname>PostgreSQL</productname> functions.
     To return a value of such a type, allocate the right amount of
     memory with <literal>palloc</literal>, fill in the allocated memory,
     and return a pointer to it.  (Also, if you just want to return the
     same value as one of your input arguments that's of the same data type,
     you can skip the extra <literal>palloc</literal> and just return the
     pointer to the input value.)
    </para>

    <para>
     Finally, all variable-length types must also be  passed
     by  reference.   All  variable-length  types must begin
     with an opaque length field of exactly 4 bytes, which will be set
     by <symbol>SET_VARSIZE</symbol>; never set this field directly! All data to
     be  stored within that type must be located in the memory
     immediately  following  that  length  field.   The
     length field contains the total length of the structure,
     that is,  it  includes  the  size  of  the  length  field
     itself.
    </para>

    <para>
     Another important point is to avoid leaving any uninitialized bits
     within data type values; for example, take care to zero out any
     alignment padding bytes that might be present in structs.  Without
     this, logically-equivalent constants of your data type might be
     seen as unequal by the planner, leading to inefficient (though not
     incorrect) plans.
    </para>

    <warning>
     <para>
      <emphasis>Never</emphasis> modify the contents of a pass-by-reference input
      value.  If you do so you are likely to corrupt on-disk data, since
      the pointer you are given might point directly into a disk buffer.
      The sole exception to this rule is explained in
      <xref linkend="xaggr"/>.
     </para>
    </warning>

    <para>
     As an example, we can define the type <type>text</type> as
     follows:

<programlisting>
typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
</programlisting>

     The <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> notation means that the actual
     length of the data part is not specified by this declaration.
    </para>

    <para>
     When manipulating
     variable-length types, we must  be  careful  to  allocate
     the  correct amount  of memory and set the length field correctly.
     For example, if we wanted to  store  40  bytes  in  a <structname>text</structname>
     structure, we might use a code fragment like this:

<programlisting><![CDATA[
#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]>
</programlisting>

     <literal>VARHDRSZ</literal> is the same as <literal>sizeof(int32)</literal>, but
     it's considered good style to use the macro <literal>VARHDRSZ</literal>
     to refer to the size of the overhead for a variable-length type.
     Also, the length field <emphasis>must</emphasis> be set using the
     <literal>SET_VARSIZE</literal> macro, not by simple assignment.
    </para>

    <para>
     <xref linkend="xfunc-c-type-table"/> specifies which C type
     corresponds to which SQL type when writing a C-language function
     that uses a built-in type of <productname>PostgreSQL</productname>.
     The <quote>Defined In</quote> column gives the header file that
     needs to be included to get the type definition.  (The actual
     definition might be in a different file that is included by the
     listed file.  It is recommended that users stick to the defined
     interface.)  Note that you should always include
     <filename>postgres.h</filename> first in any source file, because
     it declares a number of things that you will need anyway.
    </para>

     <table tocentry="1" id="xfunc-c-type-table">
      <title>Equivalent C Types for Built-in SQL Types</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
         <entry>
          SQL Type
         </entry>
         <entry>
          C Type
         </entry>
         <entry>
          Defined In
         </entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><type>boolean</type></entry>
         <entry><type>bool</type></entry>
         <entry><filename>postgres.h</filename> (maybe compiler built-in)</entry>
        </row>
        <row>
         <entry><type>box</type></entry>
         <entry><type>BOX*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>bytea</type></entry>
         <entry><type>bytea*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>"char"</type></entry>
         <entry><type>char</type></entry>
         <entry>(compiler built-in)</entry>
        </row>
        <row>
         <entry><type>character</type></entry>
         <entry><type>BpChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>cid</type></entry>
         <entry><type>CommandId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>date</type></entry>
         <entry><type>DateADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>smallint</type> (<type>int2</type>)</entry>
         <entry><type>int16</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>int2vector</type></entry>
         <entry><type>int2vector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>integer</type> (<type>int4</type>)</entry>
         <entry><type>int32</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>real</type> (<type>float4</type>)</entry>
         <entry><type>float4*</type></entry>
        <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>double precision</type> (<type>float8</type>)</entry>
         <entry><type>float8*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>interval</type></entry>
         <entry><type>Interval*</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>lseg</type></entry>
         <entry><type>LSEG*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>name</type></entry>
         <entry><type>Name</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>oid</type></entry>
         <entry><type>Oid</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>oidvector</type></entry>
         <entry><type>oidvector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>path</type></entry>
         <entry><type>PATH*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>point</type></entry>
         <entry><type>POINT*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>regproc</type></entry>
         <entry><type>regproc</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>text</type></entry>
         <entry><type>text*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>tid</type></entry>
         <entry><type>ItemPointer</type></entry>
         <entry><filename>storage/itemptr.h</filename></entry>
        </row>
        <row>
         <entry><type>time</type></entry>
         <entry><type>TimeADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>time with time zone</type></entry>
         <entry><type>TimeTzADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>timestamp</type></entry>
         <entry><type>Timestamp</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>varchar</type></entry>
         <entry><type>VarChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>xid</type></entry>
         <entry><type>TransactionId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Now that we've gone over all of the possible structures
     for base types, we can show some examples of real functions.
    </para>
   </sect2>

   <sect2>
    <title>Version 1 Calling Conventions</title>

    <para>
     The version-1 calling convention relies on macros to suppress most
     of the complexity of passing arguments and results.  The C declaration
     of a version-1 function is always:
<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>
     In addition, the macro call:
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
     must appear in the same source file.  (Conventionally, it's
     written just before the function itself.)  This macro call is not
     needed for <literal>internal</literal>-language functions, since
     <productname>PostgreSQL</productname> assumes that all internal functions
     use the version-1 convention.  It is, however, required for
     dynamically-loaded functions.
    </para>

    <para>
     In a version-1 function, each actual argument is fetched using a
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macro that corresponds to the argument's data type.  (In non-strict
     functions there needs to be a previous check about argument null-ness
     using <function>PG_ARGISNULL()</function>; see below.)
     The result is returned using a
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     macro for the return type.
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     takes as its argument the number of the function argument to
     fetch, where the count starts at 0.
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     takes as its argument the actual value to return.
    </para>

    <para>
     Here are some examples using the version-1 calling convention:
    </para>

<programlisting><![CDATA[
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"

PG_MODULE_MAGIC;

/* by value */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* by reference, fixed length */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* The macros for FLOAT8 hide its pass-by-reference nature. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Here, the pass-by-reference nature of Point is not hidden. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;

    PG_RETURN_POINT_P(new_point);
}

/* by reference, variable length */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);

    /*
     * VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
     * VARHDRSZ or VARHDRSZ_SHORT of its header.  Construct the copy with a
     * full-length header.
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
     * VARDATA is a pointer to the data region of the new struct.  The source
     * could be a short datum, so retrieve its data through VARDATA_ANY.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA_ANY(t), /* source */
           VARSIZE_ANY_EXHDR(t));   /* how many bytes */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}
]]>
</programlisting>

    <para>
     Supposing that the above code has been prepared in file
     <filename>funcs.c</filename> and compiled into a shared object,
     we could define the functions to <productname>PostgreSQL</productname>
     with commands like this:
    </para>

<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- note overloading of SQL function name "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>

    <para>
     Here, <replaceable>DIRECTORY</replaceable> stands for the
     directory of the shared library file (for instance the
     <productname>PostgreSQL</productname> tutorial directory, which
     contains the code for the examples used in this section).
     (Better style would be to use just <literal>'funcs'</literal> in the
     <literal>AS</literal> clause, after having added
     <replaceable>DIRECTORY</replaceable> to the search path.  In any
     case, we can omit the system-specific extension for a shared
     library, commonly <literal>.so</literal>.)
    </para>

    <para>
     Notice that we have specified the functions as <quote>strict</quote>,
     meaning that
     the system should automatically assume a null result if any input
     value is null.  By doing this, we avoid having to check for null inputs
     in the function code.  Without this, we'd have to check for null values
     explicitly, using <function>PG_ARGISNULL()</function>.
    </para>

    <para>
     The macro <function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>
     allows a function to test whether each input is null.  (Of course, doing
     this is only necessary in functions not declared <quote>strict</quote>.)
     As with the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros,
     the input arguments are counted beginning at zero.  Note that one
     should refrain from executing
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> until
     one has verified that the argument isn't null.
     To return a null result, execute <function>PG_RETURN_NULL()</function>;
     this works in both strict and nonstrict functions.
    </para>

    <para>
     At first glance, the version-1 coding conventions might appear
     to be just pointless obscurantism, compared to using
     plain <literal>C</literal> calling conventions.  They do however allow
     us to deal with <literal>NULL</literal>able arguments/return values,
     and <quote>toasted</quote> (compressed or out-of-line) values.
    </para>

    <para>
     Other options provided by the version-1 interface are two
     variants of the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macros. The first of these,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,
     guarantees to return a copy of the specified argument that is
     safe for writing into. (The normal macros will sometimes return a
     pointer to a value that is physically stored in a table, which
     must not be written to. Using the
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>
     macros guarantees a writable result.)
    The second variant consists of the
    <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
    macros which take three arguments. The first is the number of the
    function argument (as above). The second and third are the offset and
    length of the segment to be returned. Offsets are counted from
    zero, and a negative length requests that the remainder of the
    value be returned. These macros provide more efficient access to
    parts of large values in the case where they have storage type
    <quote>external</quote>. (The storage type of a column can be specified using
    <literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER
    COLUMN <replaceable>colname</replaceable> SET STORAGE
    <replaceable>storagetype</replaceable></literal>. <replaceable>storagetype</replaceable> is one of
    <literal>plain</literal>, <literal>external</literal>, <literal>extended</literal>,
     or <literal>main</literal>.)
    </para>

    <para>
     Finally, the version-1 function call conventions make it possible
     to return set results (<xref linkend="xfunc-c-return-set"/>) and
     implement trigger functions (<xref linkend="triggers"/>) and
     procedural-language call handlers (<xref
     linkend="plhandler"/>).  For more details
     see <filename>src/backend/utils/fmgr/README</filename> in the
     source distribution.
    </para>
   </sect2>

   <sect2>
    <title>Writing Code</title>

    <para>
     Before we turn to the more advanced topics, we should discuss
     some coding rules for <productname>PostgreSQL</productname>
     C-language functions.  While it might be possible to load functions
     written in languages other than C into
     <productname>PostgreSQL</productname>, this is usually difficult
     (when it is possible at all) because other languages, such as
     C++, FORTRAN, or Pascal often do not follow the same calling
     convention as C.  That is, other languages do not pass argument
     and return values between functions in the same way.  For this
     reason, we will assume that your C-language functions are
     actually written in C.
    </para>

    <para>
     The basic rules for writing and building C functions are as follows:

     <itemizedlist>
      <listitem>
       <para>
        Use <literal>pg_config
        --includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm>
        to find out where the <productname>PostgreSQL</productname> server header
        files are installed on your system (or the system that your
        users will be running on).
       </para>
      </listitem>

      <listitem>
       <para>
        Compiling and linking your code so that it can be dynamically
        loaded into <productname>PostgreSQL</productname> always
        requires special flags.  See <xref linkend="dfunc"/> for a
        detailed explanation of how to do it for your particular
        operating system.
       </para>
      </listitem>

      <listitem>
       <para>
        Remember to define a <quote>magic block</quote> for your shared library,
        as described in <xref linkend="xfunc-c-dynload"/>.
       </para>
      </listitem>

      <listitem>
       <para>
        When allocating memory, use the
        <productname>PostgreSQL</productname> functions
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm> and <function>pfree</function><indexterm><primary>pfree</primary></indexterm>
        instead of the corresponding C library functions
        <function>malloc</function> and <function>free</function>.
        The memory allocated by <function>palloc</function> will be
        freed automatically at the end of each transaction, preventing
        memory leaks.
       </para>
      </listitem>

      <listitem>
       <para>
        Always zero the bytes of your structures using <function>memset</function>
        (or allocate them with <function>palloc0</function> in the first place).
        Even if you assign to each field of your structure, there might be
        alignment padding (holes in the structure) that contain
        garbage values.  Without this, it's difficult to
        support hash indexes or hash joins, as you must pick out only
        the significant bits of your data structure to compute a hash.
        The planner also sometimes relies on comparing constants via
        bitwise equality, so you can get undesirable planning results if
        logically-equivalent values aren't bitwise equal.
       </para>
      </listitem>

      <listitem>
       <para>
        Most of the internal <productname>PostgreSQL</productname>
        types are declared in <filename>postgres.h</filename>, while
        the function manager interfaces
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.)  are in
        <filename>fmgr.h</filename>, so you will need to include at
        least these two files.  For portability reasons it's best to
        include <filename>postgres.h</filename> <emphasis>first</emphasis>,
        before any other system or user header files.  Including
        <filename>postgres.h</filename> will also include
        <filename>elog.h</filename> and <filename>palloc.h</filename>
        for you.
       </para>
      </listitem>

      <listitem>
       <para>
        Symbol names defined within object files must not conflict
        with each other or with symbols defined in the
        <productname>PostgreSQL</productname> server executable.  You
        will have to rename your functions or variables if you get
        error messages to this effect.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

&dfunc;

   <sect2>
    <title>Composite-Type Arguments</title>

    <para>
     Composite types do not have a fixed layout like C structures.
     Instances of a composite type can contain null fields.  In
     addition, composite types that are part of an inheritance
     hierarchy can have different fields than other members of the
     same inheritance hierarchy.  Therefore,
     <productname>PostgreSQL</productname> provides a function
     interface for accessing fields of composite types from C.
    </para>

    <para>
     Suppose we want to write a function to answer the query:

<programlisting>
SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';
</programlisting>

     Using the version-1 calling conventions, we can define
     <function>c_overpaid</function> as:

<programlisting><![CDATA[
#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */

    PG_RETURN_BOOL(DatumGetInt32(salary) > limit);
}
]]>
</programlisting>
    </para>

    <para>
     <function>GetAttributeByName</function> is the
     <productname>PostgreSQL</productname> system function that
     returns attributes out of the specified row.  It has
     three arguments: the argument of type <type>HeapTupleHeader</type> passed
     into
     the  function, the name of the desired attribute, and a
     return parameter that tells whether  the  attribute
     is  null.   <function>GetAttributeByName</function> returns a <type>Datum</type>
     value that you can convert to the proper data type by using the
     appropriate <function>DatumGet<replaceable>XXX</replaceable>()</function>
     macro.  Note that the return value is meaningless if the null flag is
     set; always check the null flag before trying to do anything with the
     result.
    </para>

    <para>
     There is also <function>GetAttributeByNum</function>, which selects
     the target attribute by column number instead of name.
    </para>

    <para>
     The following command declares the function
     <function>c_overpaid</function> in SQL:

<programlisting>
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;
</programlisting>

     Notice we have used <literal>STRICT</literal> so that we did not have to
     check whether the input arguments were NULL.
    </para>
   </sect2>

   <sect2>
    <title>Returning Rows (Composite Types)</title>

    <para>
     To return a row or composite-type value from a C-language
     function, you can use a special API that provides macros and
     functions to hide most of the complexity of building composite
     data types.  To use this API, the source file must include:
<programlisting>
#include "funcapi.h"
</programlisting>
    </para>

    <para>
     There are two ways you can build a composite data value (henceforth
     a <quote>tuple</quote>): you can build it from an array of Datum values,
     or from an array of C strings that can be passed to the input
     conversion functions of the tuple's column data types.  In either
     case, you first need to obtain or construct a <structname>TupleDesc</structname>
     descriptor for the tuple structure.  When working with Datums, you
     pass the <structname>TupleDesc</structname> to <function>BlessTupleDesc</function>,
     and then call <function>heap_form_tuple</function> for each row.  When working
     with C strings, you pass the <structname>TupleDesc</structname> to
     <function>TupleDescGetAttInMetadata</function>, and then call
     <function>BuildTupleFromCStrings</function> for each row.  In the case of a
     function returning a set of tuples, the setup steps can all be done
     once during the first call of the function.
    </para>

    <para>
     Several helper functions are available for setting up the needed
     <structname>TupleDesc</structname>.  The recommended way to do this in most
     functions returning composite values is to call:
<programlisting>
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
</programlisting>
     passing the same <literal>fcinfo</literal> struct passed to the calling function
     itself.  (This of course requires that you use the version-1
     calling conventions.)  <varname>resultTypeId</varname> can be specified
     as <literal>NULL</literal> or as the address of a local variable to receive the
     function's result type OID.  <varname>resultTupleDesc</varname> should be the
     address of a local <structname>TupleDesc</structname> variable.  Check that the
     result is <literal>TYPEFUNC_COMPOSITE</literal>; if so,
     <varname>resultTupleDesc</varname> has been filled with the needed
     <structname>TupleDesc</structname>.  (If it is not, you can report an error along
     the lines of <quote>function returning record called in context that
     cannot accept type record</quote>.)
    </para>

    <tip>
     <para>
      <function>get_call_result_type</function> can resolve the actual type of a
      polymorphic function result; so it is useful in functions that return
      scalar polymorphic results, not only functions that return composites.
      The <varname>resultTypeId</varname> output is primarily useful for functions
      returning polymorphic scalars.
     </para>
    </tip>

    <note>
     <para>
      <function>get_call_result_type</function> has a sibling
      <function>get_expr_result_type</function>, which can be used to resolve the
      expected output type for a function call represented by an expression
      tree.  This can be used when trying to determine the result type from
      outside the function itself.  There is also
      <function>get_func_result_type</function>, which can be used when only the
      function's OID is available.  However these functions are not able
      to deal with functions declared to return <structname>record</structname>, and
      <function>get_func_result_type</function> cannot resolve polymorphic types,
      so you should preferentially use <function>get_call_result_type</function>.
     </para>
    </note>

    <para>
     Older, now-deprecated functions for obtaining
     <structname>TupleDesc</structname>s are:
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
     to get a <structname>TupleDesc</structname> for the row type of a named relation,
     and:
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     to get a <structname>TupleDesc</structname> based on a type OID. This can
     be used to get a <structname>TupleDesc</structname> for a base or
     composite type.  It will not work for a function that returns
     <structname>record</structname>, however, and it cannot resolve polymorphic
     types.
    </para>

    <para>
     Once you have a <structname>TupleDesc</structname>, call:
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
     if you plan to work with Datums, or:
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     if you plan to work with C strings.  If you are writing a function
     returning set, you can save the results of these functions in the
     <structname>FuncCallContext</structname> structure &mdash; use the
     <structfield>tuple_desc</structfield> or <structfield>attinmeta</structfield> field
     respectively.
    </para>

    <para>
     When working with Datums, use:
<programlisting>
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
</programlisting>
     to build a <structname>HeapTuple</structname> given user data in Datum form.
    </para>

    <para>
     When working with C strings, use:
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
     to build a <structname>HeapTuple</structname> given user data
     in C string form.  <parameter>values</parameter> is an array of C strings,
     one for each attribute of the return row. Each C string should be in
     the form expected by the input function of the attribute data
     type. In order to return a null value for one of the attributes,
     the corresponding pointer in the <parameter>values</parameter> array
     should be set to <symbol>NULL</symbol>.  This function will need to
     be called again for each row you return.
    </para>

    <para>
     Once you have built a tuple to return from your function, it
     must be converted into a <type>Datum</type>. Use:
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
     to convert a <structname>HeapTuple</structname> into a valid Datum.  This
     <type>Datum</type> can be returned directly if you intend to return
     just a single row, or it can be used as the current return value
     in a set-returning function.
    </para>

    <para>
     An example appears in the next section.
    </para>

   </sect2>

   <sect2 id="xfunc-c-return-set">
    <title>Returning Sets</title>

    <para>
     C-language functions have two options for returning sets (multiple
     rows).  In one method, called <firstterm>ValuePerCall</firstterm>
     mode, a set-returning function is called repeatedly (passing the same
     arguments each time) and it returns one new row on each call, until
     it has no more rows to return and signals that by returning NULL.
     The set-returning function (<acronym>SRF</acronym>) must therefore
     save enough state across calls to remember what it was doing and
     return the correct next item on each call.
     In the other method, called <firstterm>Materialize</firstterm> mode,
     a SRF fills and returns a tuplestore object containing its
     entire result; then only one call occurs for the whole result, and
     no inter-call state is needed.
    </para>

    <para>
     When using ValuePerCall mode, it is important to remember that the
     query is not guaranteed to be run to completion; that is, due to
     options such as <literal>LIMIT</literal>, the executor might stop
     making calls to the set-returning function before all rows have been
     fetched.  This means it is not safe to perform cleanup activities in
     the last call, because that might not ever happen.  It's recommended
     to use Materialize mode for functions that need access to external
     resources, such as file descriptors.
    </para>

    <para>
     The remainder of this section documents a set of helper macros that
     are commonly used (though not required to be used) for SRFs using
     ValuePerCall mode.  Additional details about Materialize mode can be
     found in <filename>src/backend/utils/fmgr/README</filename>.  Also,
     the <filename>contrib</filename> modules in
     the <productname>PostgreSQL</productname> source distribution contain
     many examples of SRFs using both ValuePerCall and Materialize mode.
    </para>

    <para>
     To use the ValuePerCall support macros described here,
     include <filename>funcapi.h</filename>.  These macros work with a
     structure <structname>FuncCallContext</structname> that contains the
     state that needs to be saved across calls.  Within the calling
     SRF, <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal> is used to
     hold a pointer to <structname>FuncCallContext</structname> across
     calls.  The macros automatically fill that field on first use,
     and expect to find the same pointer there on subsequent uses.
<programlisting>
typedef struct FuncCallContext
{
    /*
     * Number of times we've been called before
     *
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint64 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint64 max_calls;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     *
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     *
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * OPTIONAL pointer to struct containing tuple description
     *
     * tuple_desc is for use when returning tuples (i.e., composite data types)
     * and is only needed if you are going to build the tuples with
     * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that
     * the TupleDesc pointer stored here should usually have been run through
     * BlessTupleDesc() first.
     */
    TupleDesc tuple_desc;

} FuncCallContext;
</programlisting>
    </para>

    <para>
     The macros to be used by an <acronym>SRF</acronym> using this
     infrastructure are:
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     Use this to determine if your function is being called for the first or a
     subsequent time. On the first call (only), call:
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
     to initialize the <structname>FuncCallContext</structname>. On every function call,
     including the first, call:
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     to set up for using the <structname>FuncCallContext</structname>.
    </para>

    <para>
     If your function has data to return in the current call, use:
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     to return it to the caller.  (<literal>result</literal> must be of type
     <type>Datum</type>, either a single value or a tuple prepared as
     described above.)  Finally, when your function is finished
     returning data, use:
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     to clean up and end the <acronym>SRF</acronym>.
    </para>

    <para>
     The memory context that is current when the <acronym>SRF</acronym> is called is
     a transient context that will be cleared between calls.  This means
     that you do not need to call <function>pfree</function> on everything
     you allocated using <function>palloc</function>; it will go away anyway.  However, if you want to allocate
     any data structures to live across calls, you need to put them somewhere
     else.  The memory context referenced by
     <structfield>multi_call_memory_ctx</structfield> is a suitable location for any
     data that needs to survive until the <acronym>SRF</acronym> is finished running.  In most
     cases, this means that you should switch into
     <structfield>multi_call_memory_ctx</structfield> while doing the
     first-call setup.
     Use <literal>funcctx-&gt;user_fctx</literal> to hold a pointer to
     any such cross-call data structures.
     (Data you allocate
     in <structfield>multi_call_memory_ctx</structfield> will go away
     automatically when the query ends, so it is not necessary to free
     that data manually, either.)
    </para>

    <warning>
     <para>
      While the actual arguments to the function remain unchanged between
      calls, if you detoast the argument values (which is normally done
      transparently by the
      <function>PG_GETARG_<replaceable>xxx</replaceable></function> macro)
      in the transient context then the detoasted copies will be freed on
      each cycle. Accordingly, if you keep references to such values in
      your <structfield>user_fctx</structfield>, you must either copy them into the
      <structfield>multi_call_memory_ctx</structfield> after detoasting, or ensure
      that you detoast the values only in that context.
     </para>
    </warning>

    <para>
     A complete pseudo-code example looks like the following:
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items, so just report that fact. */
        /* (Resist the temptation to put cleanup code here.) */
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>

    <para>
     A complete example of a simple <acronym>SRF</acronym> returning a composite type
     looks like:
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* stuff done only on the first call of the function */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx->max_calls = PG_GETARG_UINT32(0);

        /* Build a tuple descriptor for our result type */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

    if (call_cntr < max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = HeapTupleGetDatum(tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]>
</programlisting>

     One way to declare this function in SQL is:
<programlisting>
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     A different way is to use OUT parameters:
<programlisting>
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     Notice that in this method the output type of the function is formally
     an anonymous <structname>record</structname> type.
    </para>
   </sect2>

   <sect2>
    <title>Polymorphic Arguments and Return Types</title>

    <para>
     C-language functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.
     When a function's arguments or return types
     are defined as polymorphic types, the function author cannot know
     in advance what data type it will be called with, or
     need to return. There are two routines provided in <filename>fmgr.h</filename>
     to allow a version-1 C function to discover the actual data types
     of its arguments and the type it is expected to return. The routines are
     called <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal> and
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>.
     They return the result or argument type OID, or <symbol>InvalidOid</symbol> if the
     information is not available.
     The structure <literal>flinfo</literal> is normally accessed as
     <literal>fcinfo-&gt;flinfo</literal>. The parameter <literal>argnum</literal>
     is zero based.  <function>get_call_result_type</function> can also be used
     as an alternative to <function>get_fn_expr_rettype</function>.
     There is also <function>get_fn_expr_variadic</function>, which can be used to
     find out whether variadic arguments have been merged into an array.
     This is primarily useful for <literal>VARIADIC "any"</literal> functions,
     since such merging will always have occurred for variadic functions
     taking ordinary array types.
    </para>

    <para>
     For example, suppose we want to write a function to accept a single
     element of any type, and return a one-dimensional array of that type:

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element, being careful in case it's NULL */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>

    <para>
     The following command declares the function
     <function>make_array</function> in SQL:

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;
</programlisting>
    </para>

    <para>
     There is a variant of polymorphism that is only available to C-language
     functions: they can be declared to take parameters of type
     <literal>"any"</literal>.  (Note that this type name must be double-quoted,
     since it's also a SQL reserved word.)  This works like
     <type>anyelement</type> except that it does not constrain different
     <literal>"any"</literal> arguments to be the same type, nor do they help
     determine the function's result type.  A C-language function can also
     declare its final parameter to be <literal>VARIADIC "any"</literal>.  This will
     match one or more actual arguments of any type (not necessarily the same
     type).  These arguments will <emphasis>not</emphasis> be gathered into an array
     as happens with normal variadic functions; they will just be passed to
     the function separately.  The <function>PG_NARGS()</function> macro and the
     methods described above must be used to determine the number of actual
     arguments and their types when using this feature.  Also, users of such
     a function might wish to use the <literal>VARIADIC</literal> keyword in their
     function call, with the expectation that the function would treat the
     array elements as separate arguments.  The function itself must implement
     that behavior if wanted, after using <function>get_fn_expr_variadic</function> to
     detect that the actual argument was marked with <literal>VARIADIC</literal>.
    </para>
   </sect2>

   <sect2 id="xfunc-shared-addin">
    <title>Shared Memory and LWLocks</title>

    <para>
     Add-ins can reserve LWLocks and an allocation of shared memory on server
     startup.  The add-in's shared library must be preloaded by specifying
     it in
     <xref linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>.
     Shared memory is reserved by calling:
<programlisting>
void RequestAddinShmemSpace(int size)
</programlisting>
     from your <function>_PG_init</function> function.
    </para>
    <para>
     LWLocks are reserved by calling:
<programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
</programlisting>
     from <function>_PG_init</function>.  This will ensure that an array of
     <literal>num_lwlocks</literal> LWLocks is available under the name
     <literal>tranche_name</literal>.  Use <function>GetNamedLWLockTranche</function>
     to get a pointer to this array.
    </para>
    <para>
     To avoid possible race-conditions, each backend should use the LWLock
     <function>AddinShmemInitLock</function> when connecting to and initializing
     its allocation of shared memory, as shown here:
<programlisting>
static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr->locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}
</programlisting>
    </para>
   </sect2>

   <sect2 id="extend-cpp">
    <title>Using C++ for Extensibility</title>

    <indexterm zone="extend-cpp">
     <primary>C++</primary>
    </indexterm>

    <para>
     Although the <productname>PostgreSQL</productname> backend is written in
     C, it is possible to write extensions in C++ if these guidelines are
     followed:

     <itemizedlist>
      <listitem>
       <para>
         All functions accessed by the backend must present a C interface
         to the backend;  these C functions can then call C++ functions.
         For example, <literal>extern C</literal> linkage is required for
         backend-accessed functions.  This is also necessary for any
         functions that are passed as pointers between the backend and
         C++ code.
       </para>
      </listitem>
      <listitem>
       <para>
        Free memory using the appropriate deallocation method.  For example,
        most backend memory is allocated using <function>palloc()</function>, so use
        <function>pfree()</function> to free it.  Using C++
        <function>delete</function> in such cases will fail.
       </para>
      </listitem>
      <listitem>
       <para>
        Prevent exceptions from propagating into the C code (use a catch-all
        block at the top level of all <literal>extern C</literal> functions).  This
        is necessary even if the C++ code does not explicitly throw any
        exceptions, because events like out-of-memory can still throw
        exceptions.  Any exceptions must be caught and appropriate errors
        passed back to the C interface.  If possible, compile C++ with
        <option>-fno-exceptions</option> to eliminate exceptions entirely; in such
        cases, you must check for failures in your C++ code, e.g.,  check for
        NULL returned by <function>new()</function>.
       </para>
      </listitem>
      <listitem>
       <para>
        If calling backend functions from C++ code, be sure that the
        C++ call stack contains only plain old data structures
        (<acronym>POD</acronym>).  This is necessary because backend errors
        generate a distant <function>longjmp()</function> that does not properly
        unroll a C++ call stack with non-POD objects.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     In summary, it is best to place C++ code behind a wall of
     <literal>extern C</literal> functions that interface to the backend,
     and avoid exception, memory, and call stack leakage.
    </para>
   </sect2>

  </sect1>

  <sect1 id="xfunc-optimization">
   <title>Function Optimization Information</title>

  <indexterm zone="xfunc-optimization">
   <primary>optimization information</primary>
   <secondary>for functions</secondary>
  </indexterm>

   <para>
    By default, a function is just a <quote>black box</quote> that the
    database system knows very little about the behavior of.  However,
    that means that queries using the function may be executed much less
    efficiently than they could be.  It is possible to supply additional
    knowledge that helps the planner optimize function calls.
   </para>

   <para>
    Some basic facts can be supplied by declarative annotations provided in
    the <xref linkend="sql-createfunction"/> command.  Most important of
    these is the function's <link linkend="xfunc-volatility">volatility
    category</link> (<literal>IMMUTABLE</literal>, <literal>STABLE</literal>,
    or <literal>VOLATILE</literal>); one should always be careful to
    specify this correctly when defining a function.
    The parallel safety property (<literal>PARALLEL
    UNSAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, or
    <literal>PARALLEL SAFE</literal>) must also be specified if you hope
    to use the function in parallelized queries.
    It can also be useful to specify the function's estimated execution
    cost, and/or the number of rows a set-returning function is estimated
    to return.  However, the declarative way of specifying those two
    facts only allows specifying a constant value, which is often
    inadequate.
   </para>

   <para>
    It is also possible to attach a <firstterm>planner support
    function</firstterm> to a SQL-callable function (called
    its <firstterm>target function</firstterm>), and thereby provide
    knowledge about the target function that is too complex to be
    represented declaratively.  Planner support functions have to be
    written in C (although their target functions might not be), so this is
    an advanced feature that relatively few people will use.
   </para>

   <para>
    A planner support function must have the SQL signature
<programlisting>
supportfn(internal) returns internal
</programlisting>
    It is attached to its target function by specifying
    the <literal>SUPPORT</literal> clause when creating the target function.
   </para>

   <para>
    The details of the API for planner support functions can be found in
    file <filename>src/include/nodes/supportnodes.h</filename> in the
    <productname>PostgreSQL</productname> source code.  Here we provide
    just an overview of what planner support functions can do.
    The set of possible requests to a support function is extensible,
    so more things might be possible in future versions.
   </para>

   <para>
    Some function calls can be simplified during planning based on
    properties specific to the function.  For example,
    <literal>int4mul(n, 1)</literal> could be simplified to
    just <literal>n</literal>.  This type of transformation can be
    performed by a planner support function, by having it implement
    the <literal>SupportRequestSimplify</literal> request type.
    The support function will be called for each instance of its target
    function found in a query parse tree.  If it finds that the particular
    call can be simplified into some other form, it can build and return a
    parse tree representing that expression.  This will automatically work
    for operators based on the function, too &mdash; in the example just
    given, <literal>n * 1</literal> would also be simplified to
    <literal>n</literal>.
    (But note that this is just an example; this particular
    optimization is not actually performed by
    standard <productname>PostgreSQL</productname>.)
    We make no guarantee that <productname>PostgreSQL</productname> will
    never call the target function in cases that the support function could
    simplify.  Ensure rigorous equivalence between the simplified
    expression and an actual execution of the target function.
   </para>

   <para>
    For target functions that return <type>boolean</type>, it is often useful to estimate
    the fraction of rows that will be selected by a <literal>WHERE</literal> clause using that
    function.  This can be done by a support function that implements
    the <literal>SupportRequestSelectivity</literal> request type.
   </para>

   <para>
    If the target function's run time is highly dependent on its inputs,
    it may be useful to provide a non-constant cost estimate for it.
    This can be done by a support function that implements
    the <literal>SupportRequestCost</literal> request type.
   </para>

   <para>
    For target functions that return sets, it is often useful to provide
    a non-constant estimate for the number of rows that will be returned.
    This can be done by a support function that implements
    the <literal>SupportRequestRows</literal> request type.
   </para>

   <para>
    For target functions that return <type>boolean</type>, it may be possible to
    convert a function call appearing in <literal>WHERE</literal> into an indexable operator
    clause or clauses.  The converted clauses might be exactly equivalent
    to the function's condition, or they could be somewhat weaker (that is,
    they might accept some values that the function condition does not).
    In the latter case the index condition is said to
    be <firstterm>lossy</firstterm>; it can still be used to scan an index,
    but the function call will have to be executed for each row returned by
    the index to see if it really passes the <literal>WHERE</literal> condition or not.
    To create such conditions, the support function must implement
    the <literal>SupportRequestIndexCondition</literal> request type.
   </para>
  </sect1>
