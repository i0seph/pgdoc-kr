<!-- doc/src/sgml/runtime.sgml -->

<chapter id="runtime">
 <title>서버 설정 및 운용</title>

 <para>
이 장에서는 데이터베이스 서버를 설정하고 실행하는 방법과 운영 체제와 상호 작용하는 방법에 대해 다룬다.
 </para>

 <sect1 id="postgres-user">
<title><productname>PostgreSQL</productname> 사용자 계정</title>

<indexterm>
 <primary>postgres 사용자</primary>
</indexterm>

<para>
 외부에서 액세스 가능한 서버 데몬과 마찬가지로 <productname>PostgreSQL</productname>도 별도의 사용자 계정으로 실행하는 것이 좋다.
 이 사용자 계정은 서버에서 관리되는 데이터만 소유해야 하며, 다른 데몬과 공유해서는 안 된다(예를 들면, 사용자 <literal>nobody</literal>를 사용하는 것은 바람직하지 않음.).
 그럴 경우 손상된 시스템이 자체 바이너리를 변경할 수 있으므로 이 사용자가 소유한 실행 파일을 실행하는 것은 권장되지 않는다.
</para>

<para>
 Unix 사용자 계정을 시스템에 추가하려면 
 <command>useradd</command> 또는 <command>adduser</command> 명령을 찾아본다.
 이 설명서에 빈번하게 등장하는 사용자 이름 <systemitem>postgres</systemitem>는 설정된 것으로, 원하는 다른 이름을 대신 사용할 수 있다.
</para>
 </sect1>

 <sect1 id="creating-cluster">
<title>데이터베이스 클러스터 생성</title>

<indexterm>
 <primary>데이터베이스 클러스터</primary>
</indexterm>

<indexterm>
 <primary>데이터 영역</primary>
 <see>데이터베이스 클러스터</see>
</indexterm>

<para>
 작업을 하기 전에 디스크의 데이터베이스 저장소 영역을 초기화해야 한다.이것을 <firstterm>데이터베이스 클러스터</firstterm>라고 한다(표준 <acronym>SQL</acronym>에서는 카탈로그 클러스터라고 함.).
 데이터베이스 클러스터는 실행 중인 데이터베이스 서버의 단일 인스턴스에 의해 관리되는 데이터베이스 컬렉션이다.
 초기화 후 데이터베이스 클러스터에는 일명<literal>postgres</literal>라는 데이터베이스가 포함되는데, 이것은 유틸리티, 사용자 및 타사 어플리케이션이 사용하는 기본 데이터베이스이다.
 데이터베이스 서버 자체는 <literal>postgres</literal> 데이터베이스가 불필요하지만, 다수의 외부 유틸리티 프로그램은 이 데이터베이스가 존재한다는 것을 전제로 한다.
 초기화 중에 각 클러스터 내에 생성되는 또 다른 데이터베이스는 <literal>template1</literal>이라고 한다.
 이름에서 알 수 있듯이, 이것은 이후에 생성된 데이터베이스의 템플릿으로 사용되며, 실제 작업에 사용해서는 안 된다(클러스터 내에서 데이터베이스로 새로 생성하는 방법은 <xref linkend="managing-databases"/> 참조.).
</para>

<para>
 파일 시스템의 관점에서, 데이터베이스 클러스터는 모든 데이터가 저장되는 단일 디렉터리이다.
 이것을 <firstterm>데이터 디렉터리</firstterm> 또는 <firstterm>데이터 영역</firstterm>이라고 한다.
 데이터를 어디에 저장할 것인지는 전적으로 사용자의 선택에 달려 있다.
 <filename>/usr/local/pgsql/data</filename> 또는 <filename>/var/lib/pgsql/data</filename>가 일반적이지만, 필수는 아니다.
 데이터베이스 클러스터를 초기화하려면 <productname>PostgreSQL</productname>과 함께 설치된 <xref
 linkend="app-initdb"/><indexterm><primary>initdb</primary></indexterm> 명령을 사용한다.
 데이터베이스 클러스터의 원하는 파일 시스템 위치는 <option>-D</option> 옵션으로 나타낼 수 있다.
 예를 들면:
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
 앞에서 설명한 대로 <productname>PostgreSQL</productname> 사용자 계정으로
로그인한 상태에서 이 명령을 실행해야 한다.
optionally, group.
   Group access, when enabled, is read-only.  This allows an unprivileged
   user in the same group as the cluster owner to take a backup of the
   cluster data or perform other operations that only require read access.
  </para>

  <para>
   Note that enabling or disabling group access on an existing cluster requires
   the cluster to be shut down and the appropriate mode to be set on all
   directories and files before restarting
   <productname>PostgreSQL</productname>.  Otherwise, a mix of modes might
   exist in the data directory.  For clusters that allow access only by the
   owner, the appropriate modes are <literal>0700</literal> for directories
   and <literal>0600</literal> for files.  For clusters that also allow
   reads by the group, the appropriate modes are <literal>0750</literal>
   for directories and <literal>0640</literal> for files.
</para>

<tip>
 <para>
<option>-D</option> 옵션 대신 환경 변수 <envar>PGDATA</envar>를 설정할 수 있다.
<indexterm><primary><envar>PGDATA</envar></primary></indexterm>
 </para>
</tip>

<para>
 또는, 다음과 같이 <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm> 프로그램으로 <command>initdb</command>를 실행할 수 있다.
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
 좀 더 직관적으로, 서버를 시작하고 중지하는 데 <command>pg_ctl</command>을 사용하면(<xref linkend="server-start"/>참조), <command>pg_ctl</command>은 데이터베이스 서버 인스턴스를 관리하는 유일한 명령이 된다.
</para>

<para>
  <command>initdb</command> 명령은 지정한 디렉터리가 없으면, 직접 만든다.
  이 때 이 명령을 수행하는 운영체제 사용자가 그 디렉터리를 만들 권한이
  있어야 한다. 일반적으로 데이터 클러스터 디렉터리의 상위 디렉터리에
  그 사용자에 대한 쓰기 권한이 있어야 한다.
  그렇지 않고, 단순히 데이터 클러스터 디렉터리에 대해서만, 
  해당 소유권을 지정하고 싶다면, 먼저 root 권한으로 
  데이터 클러스터로 사용될 디렉터리를 만들고, 그 디렉터리의 소유주를 
  바꾸어 준다.
  통상 일반적인 데이터 클러스터 초기화 작업은 다음과 같은 형태로 진행된다:

<screen>
<prompt>root#</prompt> <userinput>mkdir /usr/local/pgsql</userinput>
<prompt>root#</prompt> <userinput>chown postgres /usr/local/pgsql</userinput>
<prompt>root#</prompt> <userinput>su postgres</userinput>
<prompt>postgres$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
</para>

<para>
 <command>initdb</command> 명령은 
 지정한 데이터 클러스터 디렉터리 안에 어떤 파일이 있으면, 
 이미 초기화 작업을 진행한 것으로 판단하고, 중지 된다.
</para>

<para>
 데이터 디렉터리에는 데이터베이스의 모든 데이터가 저장되어 있으므로 무단 액세스로부터 데이터 디렉터리를 보호하는 것이 중요하기 때문에 <command>initdb</command>는 <productname>PostgreSQL</productname> 사용자를 제외한 모든 사용자로부터 접근 권한을 해지한다.
</para>

<para>
 단, 디렉터리 내용이 보호 중인 경우 기본 클라이언트 인증 설정은 로컬 사용자의 데이터베이스 연결을 허용하고 로컬 사용자가 데이터베이스 수퍼유저가 되는 것을 허용하기도 한다.
 다른 로컬 사용자를 신뢰하지 않을 경우에는 <command>initdb</command>의 <option>-W</option>, <option>--pwprompt</option> 또는 <option>--pwfile</option> 옵션 중 하나를 사용하여 데이터베이스 수퍼유저에게 패스워드를 할당하는 것이 좋다.
 <indexterm>
 <primary>패스워드</primary>
 <secondary>슈퍼유저의</secondary>
 </indexterm>
 또한 <option>-A md5</option> 또는
 <option>-A password</option>를 지정하여 기본 <literal>trust</literal> 인증 모드가 사용되지 않게 하거나, 서버를 처음으로 시작하기 <emphasis>전에</emphasis> <command>initdb</command>를 실행한 후 생성된 <filename>pg_hba.conf</filename> 파일을 수정해야 한다. (기타 합리적 접근법에는 <literal>peer</literal> 인증 또는 파일 시스템 권한을 사용하여 연결을 제한하는 것이 있다.
 자세한 내용은 <xref linkend="client-authentication"/> 참조.)
</para>

<para>
 <command>initdb</command>에서 데이터베이스 클러스터의 기본 로케일(<indexterm><primary>locale</primary></indexterm>)을 초기화할 수도 있다.
 일반적으로는 환경의 로케일(locale) 설정을 가져와서, 이것을 초기화된 데이터베이스에 적용한다. 데이터베이스에 서로 다른 로케일(locale)을 지정할 수 있다.
 자세한 내용은 <xref linkend="locale"/>에 나와 있다.
 특정 데이터베이스 클러스터 내에서 사용되는 기본 정렬 순서는 <command>initdb</command>로 설정되며, 서로 다른 정렬 순서로 새로운 데이터베이스를 생성하는 경우 initdb로 생성된 템플릿 데이터베이스에 사용되는 정렬 순서는 삭제 및 재생성하지 않고는 변경할 수 없다.<literal>C</literal> 또는 <literal>POSIX</literal> 이외의 로케일(locale)을 사용하는 경우 성능에도 영향을 미칠 수 있다.
 따라서 처음부터 올바른 선택을 하는 것이 중요하다.
</para>

<para>
 <command>initdb</command>로 데이터베이스 클러스터용 기본 문자 집합 인코딩도 설정한다.
 일반적으로, 이것은 로케일(locale) 설정과 동일하게 선택해야 한다.
 자세한 내용은 <xref linkend="multibyte"/> 참조.
</para>

  <para>
   <literal>C</literal> 로케일이 아닌 경우나, <literal>POSIX</literal> 로케일이 아닌 경우
   해당 운영체제의 문자세트 정렬 라이브러리를 사용한다.
   이것은 인덱스에서 키의 정렬 순서를 관여한다.  이런 이유로,
   한 클러스터의 스냅샷 복원, 바이너리 스트리밍 복제 작업은
   이 정렬 라이브러리가 운영체제가 달라서, 또는 운영체제 업그레이드로
   달라질 경우 정상적으로 처리되지 않을 수 있다.
  </para>

 <note>
 <para>
 <command>initdb</command> 기본 동작 방식이 운영체제의 언어 환경에 따라 
 기본 로케일을 자동으로 판단한다.  즉, <command>initdb</command> 명령을 수행하는
 운영체제의 쉘 환경 설정이 한국어로 되어 있다면, 자동으로 로케일 설정이 한국어로 지정되어
 클러스터가 만들어진다.  이렇게 만들어지면, 한국어 자료에 대한 인덱스 사용에 따른
 쿼리 최적화가 의도된 대로 작동하지 않을 수 있다.
 </para>

 <para>
 그래서, 일반적으로 한국어 환경에서는 이 부분을 고려하여 다음과 같이 데이터 클러스터
 초기화 작업을 진행한다.
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data -E utf8 --no-locale</userinput>
</screen>
 </para>
 </note>

  <sect2 id="creating-cluster-mount-points">
   <title>Use of Secondary File Systems</title>

   <indexterm zone="creating-cluster-mount-points">
    <primary>file system mount points</primary>
   </indexterm>

   <para>
    Many installations create their database clusters on file systems
    (volumes) other than the machine's <quote>root</quote> volume.  If you
    choose to do this, it is not advisable to try to use the secondary
    volume's topmost directory (mount point) as the data directory.
    Best practice is to create a directory within the mount-point
    directory that is owned by the <productname>PostgreSQL</productname>
    user, and then create the data directory within that.  This avoids
    permissions problems, particularly for operations such
    as <application>pg_upgrade</application>, and it also ensures clean failures if
    the secondary volume is taken offline.
   </para>

  </sect2>

  <sect2 id="creating-cluster-filesystem">
   <title>File Systems</title>

   <para>
    일반적으로 POSIX 호환 파일 시스템이라면 어떤 것도 상관 없이 
    PostgreSQL에서는 사용할 수 있다.  사용자들은
    벤더 기술지원, 성능, 친숙함 등 다양한 이유로 여러 파일 시스템을
    각각 사용한다.  경험상, 다른 것들은 모두 동일한데, 
    파일 시스템의 종류를 바꾼다거나, 
    사소한 파일 시스템 환경 설정을 바꾼다고 해도, 성능이 크게 좋아진다거나,
    기능이 크게 바뀌지는 않는다.
   </para>

   <sect3 id="creating-cluster-nfs">
    <title>NFS</title>

    <indexterm zone="creating-cluster-nfs">
     <primary>NFS</primary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> 데이터 디렉터리로
     <acronym>NFS</acronym> 파일 시스템을 사용할 수 있다.
     <productname>PostgreSQL</productname>은 <acronym>NFS</acronym>
     파일 시스템도 그냥 로컬 드라이브와 같은 것으로 여긴다.
     데이터베이스 내부적으로 사용하는 파일 처리 작업은 똑같다.
     파일 잠금 처리가 한 예다.
    </para>

    <para>
     단, <acronym>NFS</acronym> 파일 시스템을 사용할 때는, 
     <productname>PostgreSQL</productname>에서는 그 파티션이
     <literal>hard</literal> 옵션을 지정해서 마운트한 것을 
     사용해야 한다.
     <literal>hard</literal> 옵션을 사용하면, 
     네트워크 통신 문제가 있을 경우, 서버가 <quote>멈출 수 있다.</quote>
     그래서, 세심한 모니터링이 필요하다.
     <literal>soft</literal> 옵션을 사용하면, 
     네트워크 통신 문제가 있을 경우, 파일 시스템이 시스템 콜을 무시할 수
     있는데, 이 경우, <productname>PostgreSQL</productname>은 
     이렇게 처리 안된 시스템 콜을 다시 처리하지 않아, 입출력 오류가
     생길 수도 있다.
    </para>

    <para>
     <literal>sync</literal> 옵션은 지정하지 않아도 된다. 
     <literal>async</literal> 옵션으로도 충분하다.  <productname>PostgreSQL</productname>
     내부적으로 필요한 경우는
     캐시를 디스크로 쓰는 플러시 작업을 하는 <literal>fsync</literal>
     호출을 충실히 한다.  (로컬 파일 시스템에서 작동하는 방식과 같다.)
     하지만, 대부분 NFS <emphasis>서버</emphasis>로 사용하는 
     시스템(일반적으로 리눅스)의 export 설정에서는 
     <literal>sync</literal> 옵션을 지정하는 것을 권장한다.
     한편, NFS 클라이언트가 호출하는 <literal>fsync</literal> 또는
     그 같은 역할을 하는 작업이 반드시 서버에 있는 스토리지에 
     완벽하게 썼다고 보장하지는 않는다. 이는 데이터베이스 서버가 
     비정상적으로 종료 되었을 때 커밋된 자료를 잃어버릴 수 있는
     <xref
     linkend="guc-fsync"/> off 상태와 같다고 간주 할 수 있다.
     NFS 파일 시스템의 마운트 옵션과 서버의 export 옵션의 기본값이 
     각 벤더사와 버전에 따라 다양하다. 그래서, 자신이 쓰는 환경에서
     앞에서 다룬 문제들을 최대한 피할 수 있는 설정은 스스로 
     확인하고 사용해야한다.
    </para>

    <para>
     한 경우로, NFS 파일 시스템이 아닌, 
     iSCSI 같은 저수준 프로토콜로 접근할 수 있는 외장 스토리지를 
     사용할 수 있는데, 이 경우는 OS 상에서는 블록 장치로 보이고, 
     이것을 원하는 파일 시스템으로 만들어서 사용할 수 있다.
     이런 경우는 NFS 사용할 때와 달리 DBA가 신경 쓸 부분이 줄지만,
     iSCSI 서버와 원격 스토리지 설정, 사용에 따른 또 다른 수준의
     작업이 필요하다.
    </para>
   </sect3>

  </sect2>

 </sect1>

 <sect1 id="server-start">
<title>데이터베이스 서버 시작</title>

<para>
 데이터베이스에 액세스하기 전에 데이터베이스 서버를 시작해야 한다.
 데이터베이스 서버 프로그램을 <command>postgres</command>라고 한다.
 <indexterm><primary>postgres</primary></indexterm>
 <command>postgres</command>프로그램은 사용하려는 데이터가 어디에 있는지 알고 있어야 한다.
 이것은 <option>-D</option> 옵션으로 가능하다.
 따라서 서버를 시작하는 가장 손쉬운 방법은 다음과 같이 하는 것이다.
<screen>
<prompt>$</prompt> <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
 이렇게 하면 서버가 포그라운드에서 실행된다.
 이것은 <productname>PostgreSQL</productname> 사용자 계정으로 로그인한 상태에서 해야 한다.
 <option>-D</option>가 없으면 이름이 환경 변수 <envar>PGDATA</envar>인 데이터 디렉터리를 서버가 사용하려고 한다.
 해당 변수가 제공되지 않으면 실패하게 된다.
</para>

<para>
 보통은 백그라운드에서 <command>postgres</command>를 시작하는 것이 좋다.
 이것의 경우 일반적인 Unix 쉘 구문을 사용한다.
<screen>
<prompt>$</prompt> <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
 위와 같이 서버의 <systemitem>stdout</systemitem> 및 <systemitem>stderr</systemitem> 출력을 어딘가에 저장해 놓는 것이 중요하다.
 그러면 감사 및 문제 진단 시 도움이 된다(로그 파일 처리에 대한 자세한 내용은 <xref linkend="logfile-maintenance"/> 참조).
</para>

<para>
 <command>postgres</command> 프로그램에는 다른 명령줄 옵션도 많이 있다.
 자세한 내용은 <xref linkend="app-postgres"/> 참조 페이지 및 아래의 <xref linkend="runtime-config"/>을 참조 바란다.
</para>

<para>
 쉘 구문은 지루하고 따분하다.
 따라서 일부 작업을 단순화할 수 있는 래퍼 프로그램 <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>이 제공된다.
 예:
<programlisting>
pg_ctl start -l logfile
</programlisting>
 이것은 서버를 백그라운드에서 시작하고 출력을 지명된 로그 파일로 출력한다.
 <option>-D</option> 옵션은 <command>postgres</command>에서 사용된 것과 의미가 동일하다.
 <command>pg_ctl</command>으로도 서버를 중지할 수 있다.
</para>

<para>
 보통은, 컴퓨터 부팅 시 데이터베이스 서버도 시작하는 것이 일반적이다.
 <indexterm>
 <primary>부팅</primary>
 <secondary>시 데이터베이스 서버 시작</secondary>
 </indexterm>
 자동 시작 스크립트는 운영 체제마다 다르다.
 <productname>PostgreSQL</productname>에서 배포되는 몇 가지 스크립트가 <filename>contrib/start-scripts</filename> 디렉터리에 있다.
 하나를 설치하려면 루트 권한이 필요하다.
</para>

<para>
 시스템이 다르면 부팅 시 데몬을 시작하기 위한 규칙(convention)도 달라진다.
 다수의 시스템에 <filename>/etc/rc.local</filename> 또는 <filename>/etc/rc.d/rc.local</filename> 파일이 있다.
 그 외에는 <filename>init.d</filename> 또는 <filename>rc.d</filename> 디렉터리를 사용한다.
 서버는 <emphasis>루트</emphasis> 또는 다른 사용자가 아닌 <productname>PostgreSQL</productname> 사용자 계정으로 실행해야 한다.
 그러므로 <literal>su postgres -c '...'</literal> 류의 명령을 사용해야 한다.
 예를 들면:
<programlisting>
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
</programlisting>
</para>

<para>
 운영 체제별로 특수한 몇 가지 예시는 다음과 같다(각각의 경우 적절한 설치 디렉터리와 사용자 이름을 사용해야 하며, 여기서는 일반적인 값을 사용한다.).
 <itemizedlist>
<listitem>
 <para>
<productname>FreeBSD</productname>의 경우 <productname>PostgreSQL</productname> 소스 배포에서 
<filename>contrib/start-scripts/freebsd</filename> 파일을 검토해야 한다.
<indexterm><primary>FreeBSD</primary><secondary>시작 스크립트</secondary></indexterm>
 </para>
</listitem>

<listitem>
 <para>
<productname>OpenBSD</productname>에서 다음 라인을 <filename>/etc/rc.local</filename> 파일에 추가해야 한다.
<indexterm><primary>OpenBSD</primary><secondary>시작 스크립트</secondary></indexterm>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/PostgreSQL/log -D /usr/local/pgsql/data'
echo -n ' PostgreSQL'
fi
</programlisting>
 </para>
</listitem>

<listitem>
 <para>
<productname>Linux</productname> 시스템에서는
<indexterm><primary>Linux</primary><secondary>시작 스크립트</secondary></indexterm>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
를 <filename>/etc/rc.d/rc.local</filename>
또는 <filename>/etc/rc.local</filename>에 추가하거나 <productname>PostgreSQL</productname> 소스 배포에서 
<filename>contrib/start-scripts/linux</filename> 파일을 검토해야 한다.
 </para>

     <para>
      <application>systemd</application> 데몬을 이용한 호스트를 관리한다면, 
      다음과 같은 서비스 설정 파일(예, <filename>/etc/systemd/system/postgresql.service</filename>)을
      만들어 사용한다:
      <indexterm><primary>systemd</primary></indexterm>
<programlisting>
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0

[Install]
WantedBy=multi-user.target
</programlisting>
      서버를 빌드할 때, <literal>configure --with-systemd</literal> 옵션을
      사용했다면, <literal>Type=notify</literal> 설정이 필요하다.
     </para>

     <para>
      <literal>TimeoutSec=0</literal> 설정도 고려해야 한다.
      <application>systemd</application> 데몬은 기본적으로 
      90초 이내 해당 작업에 대한 처리 완료 신호를 받지 못하면, 
      해당 프로세스를 종료해 버린다.  하지만, <productname>PostgreSQL</productname>
      서버는 비정상 종료 뒤 서버 복구 모드로 진행될 경우 
      트랜잭션 로그 재실행 작업으로 충분히 90초 이상이 될 수도 있다.
      이에, 이 설정은 0으로 설정해 시간 제한 기능을 끄는 것을 권고한다.
     </para>
</listitem>

<listitem>
 <para>
<productname>NetBSD</productname>에서는 기본 설정에 따라 
<productname>FreeBSD</productname> 또는
<productname>Linux</productname> 시작 스크립트를 사용해야 한다.
<indexterm><primary>NetBSD</primary><secondary>시작 스크립트</secondary></indexterm>
 </para>
</listitem>

<listitem>
 <para>
<productname>Solaris</productname>에서는 다음 라인이 포함된 
<filename>/etc/init.d/PostgreSQL</filename> 파일을 생성해야 한다.
<indexterm><primary>Solaris</primary><secondary>시작 스크립트</secondary></indexterm>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
그런 다음, <filename>S99PostgreSQL</filename>로써 <filename>/etc/rc3.d</filename>에 심볼릭 링크를 생성해야 한다.
 </para>
</listitem>
 </itemizedlist>

</para>

 <para>
서버 실행 중에 <acronym>PID</acronym>는 데이터 디렉터리의 
<filename>postmaster.pid</filename> 파일에 저장된다.
이것은 동일한 데이터 디렉터리에서 실행되는 다중 서버 인스턴스를 방지하는 데 사용되고, 서버를 셧다운하는 데에도 사용될 수 있다.
 </para>

 <sect2 id="server-start-failures">
<title>서버 시작 실패</title>

<para>
 서버 시작 실패에는 몇 가지 공통된 원인이 있다.
 서버의 로그 파일을 확인하거나 직접 시작해서(표준 출력 또는 표준 에러를 리다이렉트하지 않고) 에러 메시지를 확인해야 한다.
 아래는 몇 가지 공통된 에러 메시지를 자세히 설명한다.
</para>

<para>
<screen>
<computeroutput>
LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</computeroutput>
</screen>
 일반적으로 이것은 서버가 이미 실행되고 있는 포트에서 사용자가 다른 서버를 시작하려고 했음을 의미한다.
 단, 커널 에러 메시지가 <computeroutput>Address already in use</computeroutput>가 아니거나, 이것과 약간 다른 경우 다른 문제일 가능성이 있다.
 예를 들면, 예약된 포트 번호에서 서버를 시작하려고 하면 다음과 같이 할 것이다.
<screen>
<prompt>$</prompt> <userinput>postgres -p 666</userinput>
<computeroutput>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</computeroutput>
</screen>
</para>

<para>
메시지는 다음과 같이 나타난다.
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
 이것은 공유 메모리 크기에 대한 커널 제한이 <productname>PostgreSQL</productname>
 이 생성하려고 하는 작업 영역보다 작다는 것을 의미하는 것일 수 있다(이 예시에서 4011376640바이트).
 또는 커널에 환경 설정된 System-V-style 공유 메모리가 일절 지원되지 않는다는 것을 의미할 수도 있다.
 임시 해결책으로, 버퍼 수를 정상보다 작게 해서 서버 시작을 시도해볼 수 있다(<xref linkend="guc-shared-buffers"/>).
 결국에는 허용된 공유 메모리 크기를 늘리기 위해 사용자는 커널을 다시 환경 설정할 수 있다.
 또한 동일한 머신에서 다중 서버를 시작하려는 경우 총 요청 공간이 커널 제한을 초과하면 이 메시지가 나타날 수도 있다.

</para>

<para>
 에러가 다음과 같을 수 있다.
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
 이것은 사용자의 디스크 공간이 소진되었음을 의미하지 <emphasis>않는다</emphasis>.
 이것은 <systemitem class="osname">System V</systemitem> 세마포어에 대한 커널 수 제한이 생성하려는 
 <productname>PostgreSQL</productname>의 수보다 작다는 것을 의미한다.
 위와 마찬가지로, 허용된 연결 수(<xref linkend="guc-max-connections"/>)를 줄여서 서버를 시작함으로써 문제를 해결할 수 있지만, 결국에는 커널 제한을 늘리는 것이 좋다.
</para>

<para>
 <quote><errorname>Illegal system call</errorname></quote> 에러가 나타난 경우 공유 메모리 또는 세마포어가 사용자의 커널에서 일절 지원되지 않는 것일 수 있다. 이런 경우 유일한 방법은 이 기능이 가능하도록 커널을 다시 환경 설정하는 것뿐이다.
</para>

<para>
 <systemitem class="osname">System V</systemitem>
 <acronym>IPC</acronym> 기능 환경 설정에 대한 자세한 내용은 <xref linkend="sysvipc"/>에 나와 있다.
</para>
 </sect2>

 <sect2 id="client-connection-problems">
<title>클라이언트 연결 문제</title>

<para>
 클라이언트 측에서 가능한 에러 조건이 다양하고 애플리케이션에 의존적이지만, 그 중 몇 가지는 서버를 시작한 방법과 직접적인 관련이 있다.
 아래 표시된 조건 외에 다른 것은 각각의 클라이언트 어플리케이션을 사용하여 문서화되어야 한다.
</para>

<para>
<screen>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?
</screen>
 이것은 일반적인 <quote>I couldn't find a server to talk
 to</quote> 실패이다.
 TCP/IP 통신을 시도할 때 위와 같이 보인다.흔한 실수로 TCP/IP 연결이 가능하도록 서버를 환경 설정하는 것을 잊어버리는 것이다.
</para>

<para>
 그 대신, 로컬 서버에 대한 Unix 도메인 소켓 통신을 시도할 때 연결할 수도 있다.
<screen>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
</para>

<para>
 마지막 라인은 클라이언트가 올바른 곳으로 연결을 시도하고 있는지 확인할 때 유용하다.
 사실상, 실행 중인 서버가 없는 경우 커널 에러 메시지는 설명한 대로 보통 <computeroutput>Connection refused</computeroutput> 또는
 <computeroutput>No such file or directory</computeroutput> 중 하나이다(이 문맥의 
 <computeroutput>Connection refused</computeroutput>는 서버가 사용자의 연결 요청을 접수했고 거부했다는 것을 의미하지 
 <emphasis>않는다는</emphasis> 것을 알고 있는 것이 중요하다.해당 사례는 <xref
 linkend="client-authentication-problems"/>에 표시된 대로 다른 메시지가 나타난다.).
 <computeroutput>Connection timed out</computeroutput> 같은 다른 에러 메시지는 네트워크 연결성 부족 같은 좀 더 근본적인 문제를 나타내는 것일 수 있다.
</para>
 </sect2>
</sect1>

 <sect1 id="kernel-resources">
<title>커널 리소스 관리</title>

<para>
 <productname>PostgreSQL</productname>은 특히 서버의 복수 사본을 동일한 시스템에서 실행 중인 경우 또는 대규모 설치 중인 경우, 가끔씩 다양한 운영 체제 리소스 제한을 소진시킨다.
 이 절에서는 <productname>PostgreSQL</productname>가 사용하는 커널 리소스 및 커널 리소스 소비와 관련된 문제 해결 단계를 다룬다.
</para>

<sect2 id="sysvipc">
 <title>공유 메모리 및 세마포어</title>

 <indexterm zone="sysvipc">
<primary>공유 메모리</primary>
 </indexterm>

 <indexterm zone="sysvipc">
<primary>세마포어</primary>
 </indexterm>

 <para>
    <productname>PostgreSQL</productname> 서버는 내부-프로세스
    통신(inter-process communication, <acronym>IPC</acronym>) - 구체적으로
    공유 메모리와, 세마포어를 여러 프로세스가 함께 사용하는 것 - 을 제공하는 
    OS에서 실행된다. 유닉스 계열에서는 일반적으로
    <quote><systemitem class="osname">System V</systemitem></quote> <acronym>IPC</acronym>,
    <quote><systemitem class="osname">POSIX</systemitem></quote> <acronym>IPC</acronym>
    중 하나나, 둘 모두를 제공한다.  <systemitem class="osname">Windows</systemitem>에서는
    자체적인 방법으로 이 기능을 제공하며, 여기서는 언급하지 않는다.
 </para>

 <para>
이러한 기능을 제공하지 않는 OS에서 서버를 실행하면,
<quote><errorname>Illegal system call</errorname></quote> 오류를 내면서 실행되지 않는다.
커널이 이런 기능을 제공하지 않는다면, 커널을 다시 만들거나, OS 환경 설정을
다시 하거나 해야한다.
이러한 상황은 최신 운영 체제에서는 거의 일어나지 않는다.
 </para>

 <para>
    <productname>PostgreSQL</productname> 서버는 아주 적은 System V 공유 메모리와, 
    서버에서 사용할 공용 메모리로 anonymous <function>mmap</function>
    공유 메모리를 사용한다.
    다른 방식으로, 하나의 큰 System V 공유 메모리 영역을 
    사용할 수도 있다(<xref linkend="guc-shared-memory-type"/> 참조).
    또한 OS 세마포어도 필요한데, 이 수량도 서버가 실행될 때 확보한다.
    현재 리눅스나 FreeBSD 인 경우는 POSIX 세마포어를 사용하고, 
    나머지 OS에서는 System V 세마포어를 사용한다.
 </para>

 <note>
 <para>
 <productname>PostgreSQL</productname> 9.3 이전에는, 서버 시작에 훨씬 더 많은 System V 공유 메모리가 필요했다.
 버전이 오래된 서버를 실행 중인 경우 문서에서 서버 버전을 참고하기 바란다.
 </para>
 </note>

   <para>
    System V <acronym>IPC</acronym>를 사용하는 경우, 이들 자원(공유 메모리와 세마포어)은
    OS 전역에서 공용으로 사용된다.  <productname>PostgreSQL</productname> 서버를
    실행 할 때, 필요한 만큼의 자원을 확보할 수 없다면, 
    서버 오류 메시지를 보이며 서버는 중지된다.  (
    <xref linkend="server-start-failures"/> 참조). 
    이 OS 설정은 <xref
    linkend="sysvipc-parameters"/> 에서 대략적으로 설명한다.  
    하지만, 이들 설정은 OS 마다 서로 다르기 때문에, 
    사용하는 OS 설명서를 참조해야 한다.
    몇몇 OS에 대해서는 아래에서 설명하고 있다.
   </para>

 <table id="sysvipc-parameters">
<title><systemitem class="osname">System V</systemitem> <acronym>IPC</acronym> 파라미터</title>

<tgroup cols="3">
 <thead>
<row>
 <entry>이름</entry>
 <entry>설명</entry>
 <entry>하나의 <productname>PostgreSQL</productname> 서버 인스턴스가 실행 될 때 필요한 값</entry>
</row>
 </thead>

 <tbody>
<row>
 <entry><varname>SHMMAX</varname></entry>
 <entry>공유 메모리 세그먼트의 최대 크기(바이트)</entry>
 <entry>최소 1kB, 기본값은 더 크기 때문에 더 많이 필요하다.</entry>
</row>

<row>
 <entry><varname>SHMMIN</varname></entry>
 <entry>공유 메모리 세그먼트의 최소 크기(바이트)</entry>
 <entry>1</entry>
</row>

<row>
 <entry><varname>SHMALL</varname></entry>
 <entry>사용 가능한 공유 메모리의 총 양(바이트 또는 페이지)</entry>
 <entry>바이트인 경우 <varname>SHMMAX</varname>와 동일; 페이지인 경우 <literal>ceil(SHMMAX/PAGE_SIZE)</literal>, 다른 응용 프로그램에서도 쓴다면 더 많이.</entry>
</row>

<row>
 <entry><varname>SHMSEG</varname></entry>
 <entry>프로세스당 공유 메모리 세그먼트의 최대 수</entry>
 <entry>1개 세그먼트만 필요하지만 기본값이 훨씬 큼</entry>
</row>

 <row>
<entry><varname>SHMMNI</varname></entry>
<entry>시스템 차원(system-wide)의 공유 메모리 세그먼트의 최대 수</entry>
<entry><varname>SHMSEG</varname>와 동량 외 다른 애플리케이션의 여유분</entry>
 </row>

 <row>
<entry><varname>SEMMNI</varname></entry>
<entry>세마포어 식별자의 최대 수(예: 세트)</entry>
<entry>최소한 <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal>, 다른 응용 프로그램에서도 쓴다면 더 많이.</entry>
 </row>

 <row>
<entry><varname>SEMMNS</varname></entry>
<entry>시스템 차원(system-wide)의 세마포어 최대 수</entry>
<entry><literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17</literal> 그 외 다른 애플리케이션의 여유분</entry>
 </row>

 <row>
<entry><varname>SEMMSL</varname></entry>
<entry>세트별 세마포어 최대 수</entry>
<entry>최소한 17</entry>
 </row>

 <row>
<entry><varname>SEMMAP</varname></entry>
<entry>세마포어 맵에서 항목 수</entry>
<entry>텍스트 참조</entry>
 </row>

 <row>
<entry><varname>SEMVMX</varname></entry>
<entry>세마포어 최대 값</entry>
<entry>최소한 1000 (기본값은 대체로 32767; 필요한 경우 외에는 변경하지 말 것)</entry>
 </row>

 </tbody>
</tgroup>
 </table>

 <para>
<productname>PostgreSQL</productname>은 서버 인스턴스별로 System V 공유 메모리 수 바이트가 필요하다(64비트 플랫폼의 경우 보통 48바이트).
최신 운영 체제에서 이 정도 양은 손쉽게 할당 가능하다.
그러나, 서버 인스턴스를 다수 실행 중이거나 다른 어플리케이션도 System V 공유 메모리를 사용 중인 경우 
(<xref linkend="guc-shared-memory-type"/> 및 <xref
linkend="guc-dynamic-shared-memory-type"/> 참조)
시스템 차원(system-wide)의 System V 공유 메모리인 <varname>SHMALL</varname>를 늘려야 할 수 있다.
<varname>SHMALL</varname>는 여러 시스템에서 바이트 단위가 아니라 페이지 단위로 처리된다는 점에 유의하라.
 </para>

 <para>
<productname>PostgreSQL</productname>의 경우 많아야 약 32바이트에 불과하기 때문에(대개 1) 문제의 원인이 공유 메모리 세그먼트의 최소 크기(<varname>SHMMIN</varname>)일 가능성은 낮다.
시스템 차원(system-wide)의 세그먼트 최대 수(SHMMNI) 또는 프로세스당 최대 수(<varname>SHMMNI</varname>) 또는 프로세스당 최대 수(<varname>SHMSEG</varname>)는 시스템이 영(0)으로 설정되지 않는 한 문제의 원인이 될 가능성은 낮다.
 </para>

 <para>
<productname>PostgreSQL</productname>은 16개 한 세트로, 허용된 연결(<xref linkend="guc-max-connections"/>), 
autovacuum worker 프로세스(<xref linkend="guc-autovacuum-max-workers"/>),
그리고 허용된 백그라운드 프로세스 (<xref linkend="guc-max-worker-processes"/>) 각각
 1개의 세마포어를 사용한다.
각각의 세트마다 다른 어플리케이션에서 사용되는 세마포어 세트와의 충돌을 감지하기 위한 <quote>매직 넘버</quote>가 17번째 세마포어에 포함되어 있다.
시스템에서 세마포어 최대 수는 <varname>SEMMNS</varname>에 의해 설정되며, 따라서
최소한 <varname>max_connections</varname> + <varname>autovacuum_max_workers</varname> + 
<varname>max_wal_senders</varname> +
<varname>max_worker_processes</varname>
각각 허용된 16개 연결에 1 추가 + worker여야 한다(<xref
linkend="sysvipc-parameters"/> 공식 참조).
파라미터 <varname>SEMMNI</varname>는 시스템에 동시에 존재할 수 있는 세마포어 세트 수에 대한 제한을 결정한다.
그러므로, 이 파라미터는 최소한
<literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal>여야
한다.허용 연결 수를 줄이면 실패를 임시 방편으로 해결할 수 있으며, <function>semget</function> 함수로부터 <quote>No space
left on device</quote>라는 애매한 메시지를 받게 된다.
 </para>

 <para>
경우에 따라서는 <varname>SEMMAP</varname>를 적어도 
<varname>SEMMNS</varname>와 유사하게 늘릴 필요가 있을 수 있다.
시스템에서 이 매개 변수가 있다면, (없을 수도 있다)
이 파라미터는 세마포어 리소스 맵의 크기를 정의하며, 이 맵에서는 사용 가능한 세마포어의 연속 블록마다 항목을 필요로 한다.
세마포어 세트가 해제되면, 해제된 블록에 인접한 기존 항목에 추가되거나 새로운 맵 항목 아래에 등록된다.
맵이 꽉 차면 해제된 세마포어는 분실된다(리부팅될 때까지).
세마포어 공간의 조각화는 시간이 흐를수록 원래 있어야 할 것보다 사용 가능한 세마포어 수가 작아진다.
 </para>

 <para>
<varname>SEMMNU</varname> 및 <varname>SEMUME</varname> 같은 <quote>semaphore undo</quote>와 관련된 다양한 기타 설정은 
<productname>PostgreSQL</productname>에 영향을 미치지 않는다.
 </para>

 <para>
    POSIX 세마포어를 쓰는 경우는 System V 경우와 같다.
    that is one semaphore per allowed connection
    (<xref linkend="guc-max-connections"/>), allowed autovacuum worker process
    (<xref linkend="guc-autovacuum-max-workers"/>) and allowed background
    process (<xref linkend="guc-max-worker-processes"/>).
    On the platforms where this option is preferred, there is no specific
    kernel limit on the number of POSIX semaphores.
 </para>



<variablelist>
 <varlistentry>
<term><systemitem class="osname">AIX</systemitem>
<indexterm><primary>AIX</primary><secondary>IPC configuration</secondary></indexterm>
</term>
<listitem>
 <para>
모든 메모리가 공유 메모리로 사용되도록 설정되므로, 적어도 버전 5.1은 
<varname>SHMMAX</varname>같은 파라미터에 대해 특수한 설정을 할 필요가 없다.
이것은 <application>DB/2</application> 같은 다른 데이터베이스에서 일반적으로 사용된 설정의 한 종류이다.</para>

 <para>
그러나, 파일 크기(<varname>fsize</varname>)와 파일 수(<varname>nofiles</varname>)에 대한 기본 하드 제한이 너무 낮으므로 전역 
 <command>ulimit</command> 정보를 <filename>/etc/security/limits</filename>에서 변경해야 할 수 있다.
 </para>
</listitem>
 </varlistentry>


 <varlistentry>
<term><systemitem class="osname">FreeBSD</systemitem>
<indexterm><primary>FreeBSD</primary><secondary>IPC configuration</secondary></indexterm>
</term>
<listitem>
 <para>
기본 IPC 설정은 <command>sysctl</command> 또는 <command>loader</command> 인터페이스를 사용하여 변경할 수 있다.
다음 파라미터는 <command>sysctl</command>을 사용하여 설정할 수 있다.
<screen>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
</screen>
리부팅 시에 이 설정을 유지하려면 <filename>/etc/sysctl.conf</filename>를 수정해야 한다.
 </para>

 <para>
이러한 세마포어 관련 설정은 
<command>sysctl</command>에 관한 한 읽기 전용이지만 
<filename>/boot/loader.conf</filename>에서 설정 가능하다.
<programlisting>
kern.ipc.semmni=256
kern.ipc.semmns=512
</programlisting>
이 파일을 수정한 후에는 새 설정을 적용하려면 리부팅이 필요하다.
 </para>

 <para>
사용자는 커널을 환경 설정하여 System V 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 못하게 하기를 원할 수 있다.
이것은 <command>sysctl</command>
설정 <literal>kern.ipc.shm_use_phys</literal>를 사용하면 가능하다.
 </para>

 <para>
<application>sysctl</application>의 <literal>security.jail.sysvipc_allowed</literal>를 활성화하여 FreeBSD jail에서 실행 중인 경우 서로 다른 jail에서 실행 중인 <application>postmaster</application>들은 서로 다른 시스템 사용자에 의해 실행되어야 한다.
루트 사용자가 아닌 경우 서로 다른 jail에서 사용자가 공유 메모리 또는 세마포어를 간섭하지 못하게 하고 PostgreSQL IPC 클린업 코드가 올바로 작동되게 하기 때문에 이것은 보안을 개선시킨다
(FreeBSD 6.0 이상에서 IPC 클린업 코드는 서로 다른 jail에서 동일한 포트에 postmaster의 실행을 방지하기 때문에 다른 jail에서 프로세스를 올바로 감지하지 못한다.).
 </para>

 <para>
<systemitem class="osname">FreeBSD</systemitem> 4.0 이전 버전은 
옛 <systemitem class="osname">OpenBSD</systemitem>처럼 작동된다(아래 참조).
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term><systemitem class="osname">NetBSD</systemitem>
<indexterm><primary>NetBSD</primary><secondary>IPC 설정</secondary></indexterm>
</term>
<listitem>
 <para>
<systemitem class="osname">NetBSD</systemitem>5.0 이상에서, IPC 파라미터는 <command>sysctl</command>을 사용하여 조절 가능하다.예를 들면:
<screen>
<prompt>#</prompt> <userinput>sysctl -w kern.ipc.semmni=100</userinput>
</screen>
리부팅 시에 이 설정을 유지하려면 
<filename>/etc/sysctl.conf</filename>를 수정해야 한다.
 </para>

       <para>
        보통,
        <systemitem class="osname">NetBSD</systemitem> 기본 설정값이 충분하지
        않기에, <literal>kern.ipc.semmni</literal> 설정값과, 
        <literal>kern.ipc.semmns</literal> 설정값을 크게 설정해야할 것이다.
       </para>

 <para>
 사용자는 커널을 환경 설정하여 System V 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 못하게 하기를 원할 수 있다.이것은 <command>sysctl</command>
설정 <literal>kern.ipc.shm_use_phys</literal>를 사용하면 가능하다.
 </para>

 <para>
<systemitem class="osname">NetBSD</systemitem> 5.0 이전 버전은
키워드 <literal>option</literal>이 아니라 <literal>options</literal>로
설정되어야만 하는 파라미터인 경우 외에는
옛 <systemitem class="osname">OpenBSD</systemitem> (아래 참조)처럼 작동된다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term><systemitem class="osname">OpenBSD</systemitem>
<indexterm><primary>OpenBSD</primary><secondary>IPC 설정</secondary></indexterm>
</term>
<listitem>
 <para>
        In <systemitem class="osname">OpenBSD</systemitem> 3.3 and later,
        IPC parameters can be adjusted using <command>sysctl</command>,
        for example:
<screen>
<prompt>#</prompt> <userinput>sysctl kern.seminfo.semmni=100</userinput>
</screen>
        To make these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>.
       </para>

       <para>
        You will usually want to
        increase <literal>kern.seminfo.semmni</literal>
        and <literal>kern.seminfo.semmns</literal>,
        as <systemitem class="osname">OpenBSD</systemitem>'s default settings
        for these are uncomfortably small.
       </para>

       <para>
        In older <systemitem class="osname">OpenBSD</systemitem> versions,
        you will need to build a custom kernel to change the IPC parameters.
        Make sure that the options <varname>SYSVSHM</varname>
        and <varname>SYSVSEM</varname> are enabled, too.  (They are by
        default.)  The following shows an example of how to set the various
        parameters in the kernel configuration file:
<programlisting>
optionSYSVSHM
optionSHMMAXPGS=4096
optionSHMSEG=256

optionSYSVSEM
optionSEMMNI=256
optionSEMMNS=512
optionSEMMNU=256
</programlisting>
 </para>

</listitem>
 </varlistentry>

 <varlistentry>
<term><systemitem class="osname">HP-UX</systemitem>
<indexterm><primary>HP-UX</primary><secondary>IPC 설정</secondary></indexterm>
</term>
<listitem>
 <para>
기본 설정은 보편적으로 정상적인 설치에 충분하다.<productname>HP-UX</productname> 10에서 
<varname>SEMMNS</varname>의 출고시 기본 설정은 128이며, 이것은 거대 데이터베이스 사이트에는 너무 적을 수 있다.
 </para>
 <para>
<acronym>IPC</acronym> 파라미터는 <menuchoice><guimenu>Kernel
Configuration</guimenu><guimenuitem>Configurable Parameters</guimenuitem></menuchoice> 아래의 <application>System
Administration Manager</application> (<acronym>SAM</acronym>)에서 설정할 수 있다. 완료 시 
<guibutton>Create A New Kernel</guibutton>을 선택해야 한다.
 </para>
</listitem>
 </varlistentry>


 <varlistentry>
<term><systemitem class="osname">Linux</systemitem>
<indexterm><primary>Linux</primary><secondary>IPC 설정</secondary></indexterm>
</term>
<listitem>
 <para>
최대 세그먼트 크기 기본값은 32 MB이며, 최대 총 크기 기본값은 2097152페이지이다.<quote>huge pages</quote>를 이용한 특수한 커널 환경 설정일 때 외에는 페이지는 거의 항상 4096바이트이다(확인하려면 <literal>getconf PAGE_SIZE</literal> 사용).
 </para>

 <para>
공유 메모리 크기 설정은 <command>sysctl</command> 인터페이스를 통해 변경 가능하다.예를 들어, 16 GB를 허용하려면:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
또한, <filename>/etc/sysctl.conf</filename> 파일에서 리부팅 사이에서도 이 설정을 보존할 수 있다.이렇게 하는 것이 매우 바람직하다.
 </para>

 <para>
오래된 배포에는 <command>sysctl</command> 프로그램이 없을 수도 있지만 <filename>/proc</filename> 파일 시스템을 처리하여 동일하게 변경할 수 있다.
<screen>
<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
</screen>
 </para>

 <para>
나머지 기본 설정은 아주 넉넉한 크기로, 일반적으로 변경이 불필요하다.
 </para>
</listitem>
 </varlistentry>


 <varlistentry>
<term><systemitem class="osname">macOS</systemitem>
<indexterm><primary>macOS</primary><secondary>IPC 설정</secondary></indexterm>
</term>
<listitem>
 <para>
macOS에서 공유 메모리를 환경 설정하는 권장 방법은 다음과 같은 변수 할당이 포함된 <filename>/etc/sysctl.conf</filename> 파일을 생성하는 것이다.
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
일부 macOS 버전에서, 
<emphasis>모두 5개</emphasis>의 공유 메모리 파라미터를 
<filename>/etc/sysctl.conf</filename>에 설정해야 하며, 그렇지 않으면 값이 무시된다는 점에 유의해야 한다.
 </para>

 <para>
macOS 최근 릴리스는 설정된 <varname>SHMMAX</varname>가 정확히 4096의 배수가 아니면 이 값을 무시한다.
 </para>

 <para>
<varname>SHMALL</varname>는 이 플랫폼에서 4 kB로 평가된다.
 </para>

 <para>
macOS 구 버전에서는 공유 메모리 파라미터에 대한 변경 내용이 적용되려면 리부팅 해야 한다.
10.5는 현재, <application>sysctl</application>을 사용하여 <varname>SHMMNI</varname>를 제외한 모두를 상황에 따라 변경 가능하다.
그러나 리부팅 사이에 값이 유지될 수 있도록 <filename>/etc/sysctl.conf</filename>를 통해 원하는 값을 설정하는 것이 최선이다.
 </para>

 <para>
<filename>/etc/sysctl.conf</filename> 파일은 macOS 10.3.9 이상에서만 유효하다.
이전 10.3.x 릴리스를 실행 중인 경우 <filename>/etc/rc</filename>
파일을 편집하여 다음 명령으로 값을 변경해야 한다.
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
Note that
<filename>/etc/rc</filename>는 일반적으로 macOS 시스템 업데이트 시 덮어쓰기 되므로 업데이트가 있을 때마다 사용자는 이러한 편집을 반복해야 한다.
 </para>

 <para>
macOS 10.2 이전 버전에서는 <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</filename> 파일에서 이 명령을 편집해야 한다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term><systemitem class="osname">Solaris</systemitem> 2.6 to 2.9 (Solaris
6 ~ Solaris 9)
<indexterm><primary>Solaris</primary><secondary>IPC 설정</secondary></indexterm>
</term>
<listitem>
 <para>
해당 설정은 
<filename>/etc/system</filename>에서 변경 가능하다.예를 들면:
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
변경한 내용을 적용하려면 사용자의 리부팅이 필요하다.이전 Solaris 버전에서 공유 메모리에 대한 내용은 
<ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
을 참조 바란다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term><systemitem class="osname">Solaris</systemitem> 2.10 (Solaris
10) 이상</term>
<term><systemitem class="osname">OpenSolaris</systemitem></term>
<listitem>
 <para>
Solaris 10 이상 및 OpenSolaris에서 기본 공유 메모리 및 세마포어 설정은 대부분의 
<productname>PostgreSQL</productname> 애플리케이션에서 충분하다.이제 Solaris는 시스템 <acronym>RAM</acronym>의 1/4을 <varname>SHMMAX</varname> 기본값으로 설정한다.
이 설정을 좀 더 조정하려면 <literal>postgres</literal> 사용자에 대한 프로젝트 설정을 사용해야 한다. 예를 들면, <literal>root</literal>로 다음을 실행한다.
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
 </para>

 <para>
이 명령은 <literal>user.postgres</literal> 프로젝트를 추가하고 <literal>postgres</literal>
사용자에 대한 공유 메모리 최대값을 8GB로 설정하고, 다음에 사용자 로그인 시 적용되거나 <productname>PostgreSQL</productname> 재시작 시 적용된다(리로드 아님).위의 것은 <productname>PostgreSQL</productname>이 <literal>postgres</literal> 그룹의 <literal>postgres</literal> 사용자로 실행되는 것으로 간주한다.서버 리부팅은 불필요하다.
 </para>

 <para>
연결이 다수 있는 데이터베이스 서버에 대한 다른 권장 커널 설정 변경은 다음과 같다.
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>
 </para>

 <para>
또한 zone 내에서 <productname>PostgreSQL</productname>을 실행 중인 경우 zone 리소스 사용 제한도 올려야 할 필요가 있다.<literal>projects</literal> 및 <command>prctl</command>에 대한 자세한 내용은 <citetitle>System Administrator's Guide</citetitle>의 "Chapter2:Projects and Tasks"를 참조 바란다.
 </para>
</listitem>
 </varlistentry>

</variablelist>

</sect2>

  <sect2 id="systemd-removeipc">
   <title>systemd RemoveIPC</title>

   <indexterm>
    <primary>systemd</primary>
    <secondary>RemoveIPC</secondary>
   </indexterm>

   <para>
    If <productname>systemd</productname> is in use, some care must be taken
    that IPC resources (including shared memory) are not prematurely
    removed by the operating system.  This is especially of concern when
    installing PostgreSQL from source.  Users of distribution packages of
    PostgreSQL are less likely to be affected, as
    the <literal>postgres</literal> user is then normally created as a system
    user.
   </para>

   <para>
    The setting <literal>RemoveIPC</literal>
    in <filename>logind.conf</filename> controls whether IPC objects are
    removed when a user fully logs out.  System users are exempt.  This
    setting defaults to on in stock <productname>systemd</productname>, but
    some operating system distributions default it to off.
   </para>

   <para>
    A typical observed effect when this setting is on is that shared memory
    objects used for parallel query execution are removed at apparently random
    times, leading to errors and warnings while attempting to open and remove
    them, like
<screen>
WARNING:  could not remove shared memory segment "/PostgreSQL.1450751626": No such file or directory
</screen>
    Different types of IPC objects (shared memory vs. semaphores, System V
    vs. POSIX) are treated slightly differently
    by <productname>systemd</productname>, so one might observe that some IPC
    resources are not removed in the same way as others.  But it is not
    advisable to rely on these subtle differences.
   </para>

   <para>
    A <quote>user logging out</quote> might happen as part of a maintenance
    job or manually when an administrator logs in as
    the <literal>postgres</literal> user or something similar, so it is hard
    to prevent in general.
   </para>

   <para>
    What is a <quote>system user</quote> is determined
    at <productname>systemd</productname> compile time from
    the <symbol>SYS_UID_MAX</symbol> setting
    in <filename>/etc/login.defs</filename>.
   </para>

   <para>
    Packaging and deployment scripts should be careful to create
    the <literal>postgres</literal> user as a system user by
    using <literal>useradd -r</literal>, <literal>adduser --system</literal>,
    or equivalent.
   </para>

   <para>
    Alternatively, if the user account was created incorrectly or cannot be
    changed, it is recommended to set
<programlisting>
RemoveIPC=no
</programlisting>
    in <filename>/etc/systemd/logind.conf</filename> or another appropriate
    configuration file.
   </para>

   <caution>
    <para>
     At least one of these two things has to be ensured, or the PostgreSQL
     server will be very unreliable.
    </para>
   </caution>
  </sect2>

<sect2>
 <title>리소스 제한</title>

 <para>
Unix계열의 운영 체제는 사용자의 <productname>PostgreSQL</productname> 서버에도 영향을 미칠 수 있는 리소스 제한 형태가 다양하다.
그 중에 사용자별 프로세스 수, 프로세스당 개방 파일 수, 각 프로세스에서 사용 가능한 메모리 양에 대한 제한이 특히 중요하다.
이러한 제한은 각각 <quote>하드</quote> 및 <quote>소프트</quote> 제한이 있다. 소프트 제한은 실제로 계산하는 것이지만, 사용자가 하드 제한까지 증가 시킬 수 있다.
하드 제한은 root 사용자만이 변경 가능하다.시스템 호출 <function>setrlimit</function>는 이러한 파라미터의 설정을 담당한다.
쉘의 빌트인 명령어 <command>ulimit</command>(Bourne 쉘) 또는 <command>limit</command> (<application>csh</application>)는 커맨드 라인에서 리소스 제한을 제어하는 데 사용된다.
BSD 파생 시스템에서<filename>/etc/login.conf</filename> 파일은 로그인 동안 다양한 리소스 제한 설정을 제어한다.
자세한 내용은 운영 체제 문서를 참조 바란다.
관련 파라미터는 <varname>maxproc</varname>, <varname>openfiles</varname> 및 <varname>datasize</varname>들이 있다.예제는 아래와 같다.
<programlisting>
default:\
...
:datasize-cur=256M:\
:maxproc-cur=256:\
:openfiles-cur=256:\
...
</programlisting>
(<literal>-cur</literal>는 소프트 제한이다.하드 제한을 설정하려면 
<literal>-max</literal>를 덧붙인다.)
 </para>

 <para>
커널은 일부 리소스에 대해 시스템 차원(system-wide)의 제한을 가질 수 있다.
<itemizedlist>
 <listitem>
<para>
<productname>Linux</productname>에서 
<filename>/proc/sys/fs/file-max</filename>는 커널이 지원하는 개방 파일의 최대 수를 결정한다.
파일 내에 다른 수를 적거나 <filename>/etc/sysctl.conf</filename>에 할당을 추가하면 변경이 가능하다.
프로세스당 파일의 최대 제한은 커널이 컴파일되는 시점에 수정된다.자세한 내용은 
<filename>/usr/src/linux/Documentation/proc.txt</filename>를 참조 바란다.
</para>
 </listitem>
</itemizedlist>
 </para>

 <para>
<productname>PostgreSQL</productname> 서버는 연결당 프로세스 1개를 사용하므로 허용된 연결 수에 해당되는 프로세스는 최소한 제공한 다음에 사용자는 시스템에서 필요로 하는 나머지를 제공해야 한다.
이것은 일반적으로 문제가 되지 않지만 머신 1대에 몇 개의 서버를 실행하는 경우에는 쉽지 않을 수 있다.
 </para>

 <para>
개방 파일에 대한 기본 제한은 시스템 리소스를 부적절하게 분할하지 않고도 여러 사용자가 머신에 공존할 수 있는 값인 
<quote>사회적으로 용인되는</quote> 값으로 설정된다.
사용자가 필요에 따라 머신 1대에서 여러 개의 서버를 실행하지만, 특정한 전용 서버의 제한만 올리고자 할 수도 있다.
 </para>

 <para>
다른 한편으로, 일부 시스템에서는 독립된 프로세스들이 많은 수의 파일들을 열 수 있게 한다.그러면 몇 개의 프로세스만 실행되더라도 시스템 차원(system-wide)의 제한이 손쉽게 초과된다.
이러한 상황이 발생되었지만 시스템 차원(system-wide)의 제한을 변경하고 싶지 않을 경우에는 <productname>PostgreSQL</productname>의 <xref linkend="guc-max-files-per-process"/> 환경 설정 파라미터를 설정하여 개방 파일의 소비를 제한할 수 있다.
 </para>
</sect2>

<sect2 id="linux-memory-overcommit">
 <title>Linux 메모리 Overcommit</title>

   <indexterm>
    <primary>memory overcommit</primary>
   </indexterm>

   <indexterm>
    <primary>OOM</primary>
   </indexterm>

   <indexterm>
    <primary>overcommit</primary>
   </indexterm>

 <para>
Linux 2.4 이상에서 기본 가상 메모리 동작은 <productname>PostgreSQL</productname>의 경우 최적화 되어 있지 않다.
커널이 메모리 오버커밋을 이행하는 방식 때문에 <productname>PostgreSQL</productname> 또는 다른 프로세스의 메모리 수요가 시스템의 가상 메모리가 소진되는 원인이 되는 경우 커널은 
<productname>PostgreSQL</productname> postmaster(마스터 서버 프로세스)를 종료해야 한다.
 </para>

 <para>
이런 경우가 발생하면 이와 같은 커널 메시지가 나타난다(해당 메시지를 찾아 보려면 시스템 문서 및 환경 설정 참조).
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
이것은 <filename>postgres</filename> 프로세스가 메모리 압박 때문에 종료되었음을 나타낸다.기존 데이터베이스 연결이 정상 작동되더라도 새로운 연결은 수락되지 않는다.
복구하려면 <productname>PostgreSQL</productname>을 재시작해야 한다.
 </para>

 <para>
이 문제를 방지하는 방법 중 하나는 다른 프로세스 때문에 머신의 메모리가 소진되지 않을 것이 확실한 머신에서 
<productname>PostgreSQL</productname>을 실행하는 것이다.실제 메모리와 swap 공간이 소진된 경우에만 메모리 부족(OOM) 킬러가 호출되기 때문에 메모리에 여유가 없는 경우에는 운영 체제의 swap 공간을 늘리면 문제를 방지하는 데 도움이 된다.
 </para>

 <para>
<productname>PostgreSQL</productname> 자체가 메모리 부족의 원인인 경우 환경 설정을 변경하면 문제를 방지할 수 있다.경우에 따라 메모리 관련 환경 설정 파라미터, 특히 
<link linkend="guc-shared-buffers"><varname>shared_buffers</varname></link>
및 <link linkend="guc-work-mem"><varname>work_mem</varname></link>을 줄이는 것이 도움이 된다.그 외에는 데이터베이스 서버 자체로의 연결을 너무 많이 허용하는 것이 문제의 원인일 수 있다.대체로, 
<link linkend="guc-max-connections"><varname>max_connections</varname></link>를 줄이는 대신 외부 연결 풀링 소프트웨어를 이용하는 것이 좋다.
 </para>

 <para>
Linux 2.6 이상에서 커널의 동작을 수정해서 메모리 <quote>오버커밋</quote>을 방지할 수 있다.
이 설정으로 <ulink
url="https://lwn.net/Articles/104179/">OOM killer</ulink>의 호출이 전적으로 방지되는 않지만 가능성은 확연히 줄어들며, 따라서 시스템 동작이 좀 더 견고해진다.<command>sysctl</command>을 통해 엄격한 오버커밋 모드를 선택함으로써 이것이 가능해진다.
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
또는 동일한 항목을 <filename>/etc/sysctl.conf</filename>에 입력해도 된다.
사용자는 이와 관련된 설정인 <varname>vm.overcommit_ratio</varname>의 수정을 원할 수도 있다.  자세한
내용은 커널 문서 파일
<ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting"></ulink>
을 참조 바란다.
 </para>

   <para>
    Another approach, which can be used with or without altering
    <varname>vm.overcommit_memory</varname>, is to set the process-specific
    <firstterm>OOM score adjustment</firstterm> value for the postmaster process to
    <literal>-1000</literal>, thereby guaranteeing it will not be targeted by the OOM
    killer.  The simplest way to do this is to execute
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
    in the postmaster's startup script just before invoking the postmaster.
    Note that this action must be done as root, or it will have no effect;
    so a root-owned startup script is the easiest place to do it.  If you
    do this, you should also set these environment variables in the startup
    script before invoking the postmaster:
<programlisting>
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
</programlisting>
    These settings will cause postmaster child processes to run with the
    normal OOM score adjustment of zero, so that the OOM killer can still
    target them at need.  You could use some other value for
    <envar>PG_OOM_ADJUST_VALUE</envar> if you want the child processes to run
    with some other OOM score adjustment.  (<envar>PG_OOM_ADJUST_VALUE</envar>
    can also be omitted, in which case it defaults to zero.)  If you do not
    set <envar>PG_OOM_ADJUST_FILE</envar>, the child processes will run with the
    same OOM score adjustment as the postmaster, which is unwise since the
    whole point is to ensure that the postmaster has a preferential setting.
   </para>

   <para>
    Older Linux kernels do not offer <filename>/proc/self/oom_score_adj</filename>,
    but may have a previous version of the same functionality called
    <filename>/proc/self/oom_adj</filename>.  This works the same except the disable
    value is <literal>-17</literal> not <literal>-1000</literal>.
   </para>


 <note>
 <para>
일부 공급업체의 Linux 2.4 커널은 2.6 오버커밋 <command>sysctl</command> 파라미터의 초기 버전을 가지고 있는 것으로 알려져 있다.그러나, 관련 코드가 없는 2.4 커널에서 <literal>vm.overcommit_memory</literal>가 2로 설정되는 것은 상황을 더 나쁘게 만든다. 실제 커널 소스 코드를 확인하여( <filename>mm/mmap.c</filename> 파일에서 <function>vm_enough_memory</function> 참조) 2.4 설치에서 이것을 시도하기 전에 사용자의 커널에서 무엇이 지원되는지 확인하는 것이 좋다. <filename>overcommit-accounting</filename> 문서 파일이 존재한다고 해서 기능이 지원된다는 증거로 생각해서는 <emphasis>안</emphasis> 된다.의심스러울 경우는 커널 전문가 또는 커널 공급업체에게 문의 바란다.
 </para>
 </note>
</sect2>

<sect2 id="linux-huge-pages">
 <title>Linux Huge pages</title>

 <para>
huge pages를 사용하면 <productname>PostgreSQL</productname> 같이 
<xref linkend="guc-shared-buffers"/> 값이 크게 지정해 많은 메모리를 
사용할 경우, 한번에 큰 메모리 영역을 작업 단위로 지정해, 
메모리 읽기 쓰기 작업 비용을 줄일 수 있다.
<productname>PostgreSQL</productname>에서 이 기능을
활성화하려면 
커널 환경 설정값이 <varname>CONFIG_HUGETLB_PAGE=y</varname> 및
<varname>CONFIG_HUGETLBFS=y</varname>로 되어있어야 한다.
    또한 <varname>vm.nr_hugepages</varname> 값도 
    적당히 조절되어야 한다.  필요한 huge page 수를 계산하는 방법은,
    huge page 설정을 끄고, <productname>PostgreSQL</productname>
    서버를 실행한 뒤, 
    <filename>/proc</filename> 파일 시스템을 이용하며
    postmaster 프로세스의 익명 공유 메모리 크기
    값을 보고, 그 값 정도를 huge page 크기로 산정하면 된다.
    이 작업은 다음과 같다:
<programlisting>
$ <userinput>head -1 $PGDATA/postmaster.pid</userinput>
4170
$ <userinput>pmap 4170 | awk '/rw-s/ &amp;&amp; /zero/ {print $2}'</userinput>
6490428K
$ <userinput>grep ^Hugepagesize /proc/meminfo</userinput>
Hugepagesize:       2048 kB
</programlisting>
<literal>6490428</literal> / <literal>2048</literal>는 대략
<literal>3169.154</literal> huge pages이므로 
최소 <literal>3170</literal> huge pages가 필요해서,
다음과 같이 지정한다:
<programlisting>
$ <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
</programlisting>
이 설정값은 다른 응용 프로그램에서도 huge page를 사용하다면,
이 보다 더 크게 잡을 필요도 있다.
리부팅 시에 이 설정을 유지하려면
<filename>/etc/sysctl.conf</filename>에 항목을 추가하는 것을 잊으면 안 된다.
 </para>

 <para>
    가끔 커널이 원하는 만큼의 huge page 설정을 즉시 하지 못해
    윗 명령을 여러번 해야할 경우도 있으며, 리부팅을 해야하는 경우도 있다.
    (리부팅 다음 즉시, 머신 메모리의 대부분은 huge page로 변환할 수 
    있기 때문에, 리부팅을 시도한다.)  시스템의 huge page 할당량은 
    다음 명령으로 확인한다:
<programlisting>
$ <userinput>grep Huge /proc/meminfo</userinput>
</programlisting>
 </para>

 <para>
   이런 작업은 <application>sysctl</application> 명령으로  알 수 있는
   <varname>vm.hugetlb_shm_group</varname> 설정값에 의한 
   huge page 설정 변경 권한을 가진 데이터베이스 서버가 운영되고 있는
   운영체제 사용자가 필요하며, <command>ulimit -l</command> 명령으로
   확인 하는 잠금 메모리 설정을 할 수 있는 사용자여야 한다.
 </para>

 <para>
<productname>PostgreSQL</productname>에서 huge pages의 기본 동작은 가능할 경우 사용하는
것이고 실패할 경우 일반 메모리 관리 방식으로 진행 된다.
<link linkend="guc-huge-pages"><varname>huge_pages</varname></link>를
<literal>on</literal>으로 설정하면 huge pages를 강제로 사용할 수
있다.  이 경우 사용 가능한 huge pages가
부족하면 <productname>PostgreSQL</productname> 서버가 실행되지 않는다.
 </para>

 <para>
<productname>Linux</productname> huge pages 기능에 대한 자세한
설명은 <ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"></ulink>
페이지를 읽어 보기 바란다.
 </para>

</sect2>
 </sect1>


 <sect1 id="server-shutdown">
<title>서버 셧다운</title>

<indexterm zone="server-shutdown">
 <primary>셧다운</primary>
</indexterm>

<para>
 데이터베이스 서버를 셧다운 하는 방법에는 몇 가지가 있다.사용자는 마스터 
 <command>postgres</command> 프로세스에 서로 다른 신호를 전송하여 셧다운 유형을 제어한다.

 <variablelist>
<varlistentry>
 <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</primary></indexterm></term>
 <listitem>
<para>
 이것은 <firstterm>스마트 셧다운</firstterm> 모드이다.
 <systemitem>SIGTERM</systemitem>을 수신한 후, 서버는 새로운 연결을 불허하지만 기존 세션은 정상적인 종료를 허용한다.모든 세션이 종료된 후에만 셧다운된다.서버가 온라인 백업 모드인 경우 온라인 백업 모드가 더 이상 작동하지 않을 때까지 조금 더 대기한다. 백업 모드가 작동되는 중에는 새로운 연결이 수퍼유저에게만 계속 허용된다(이러한 예외는 온라인 백업 모드를 종료하기 위해 수퍼유저가 연결하는 것을 허용). 서버가 복구 중인 상태에서 스마트 셧다운이 요청되면, 모든 정규 세션이 종료된 후에만 복구 및 streaming replication이 중단된다.
</para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</primary></indexterm></term>
 <listitem>
<para>
 이것은 <firstterm>빠른 셧다운</firstterm> 모드이다.
 서버는 새로운 연결을 불허하고 모든 기존 서버 프로세스 <systemitem>SIGTERM</systemitem>을 전송하는데, 이로써 현재 트랜잭션이 중단되고 즉시 종료된다.그런 다음, 모든 서버 프로세스가 종료되도록 기다렸다가 최종적으로 셧다운된다.서버가 온라인 백업 모드인 경우 백업이 무용지물임이 표시되면서 백업 모드가 종료된다.
</para>
 </listitem>
</varlistentry>

<varlistentry>
 <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</primary></indexterm></term>
 <listitem>
<para>
이것은 <firstterm>즉시 셧다운 모드</firstterm>이다.  서버는 <systemitem>SIGQUIT</systemitem>를
모든 자식 프로세스에 전송하고 자식 프로세스가 종료될 때까지 대기한다.  5초 이내에 
종료되지 않는 프로세스에는 마스터 <command>postgres</command> 프로세스가 다시
<systemitem>SIGKILL</systemitem>을 보내 즉시 종료하고,
자신도 정상적인 중지 절차 없이 중지한다.  이렇게 되면 
다음 서버 시작 시 복구 작업을 진행한다(WAL 로그 리플레이에 의해). 이것은 비상 시에만 권장된다.
</para>
 </listitem>
</varlistentry>
 </variablelist>
</para>

<para>
pg_ctl 프로그램은 이러한 서버 셧다운 신호를 전송하기 위한 편리한 인터페이스를 제공한다.
또는 Windows가 아닌 시스템에서 <command>kill</command>을 사용하여 직접 신호를 전송할 수 있다.
<command>postgres</command> 프로세스의 <acronym>PID</acronym>는
<command>ps</command> 프로그램을 사용하여 찾을 수 있거나 데이터
디렉터리에서 <filename>postmaster.pid</filename> 파일에서 찾을 수 있다.
예를 들어, 빠른 셧다운을 하려면 아래와 같은 명령어로 가능하다.
<screen>
<prompt>$</prompt> <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
</para>

<important>
 <para>
서버 셧다운 시 <systemitem>SIGKILL</systemitem>은 사용하지 않는 것이 최선이다.
그럴 경우 서버에서 공유 메모리 및 세마포어가 해제되지 않는다.
또한 <systemitem>SIGKILL</systemitem>은 하위 프로세스로 신호를
전달하지 않고 <command>postgres</command>를 kill하므로 각각의 하위 프로세스 역시 직접 kill해야 한다.
 </para>
</important>

<para>
다른 세션은 계속하면서 개별 세션을 종료하려면 <function>pg_terminate_backend()</function>를 사용하거나(<xref
 linkend="functions-admin-signal-table"/> 참조) 세션과 관련된 자식 프로세스에 <systemitem>SIGTERM</systemitem> 신호를 전송해야 한다.
</para>
 </sect1>

 <sect1 id="upgrading">
<title><productname>PostgreSQL</productname> 클러스터 업그레이드</title>

<indexterm zone="upgrading">
 <primary>업그레이드</primary>
</indexterm>

<indexterm zone="upgrading">
 <primary>버전</primary>
 <secondary>호환성</secondary>
</indexterm>

<para>
이 절에서는 <productname>PostgreSQL</productname> 릴리스의 데이터베이스 데이터를 새로운 것으로 업그레이드하는 방법을 다룬다.
</para>

  <para>
   현재 <productname>PostgreSQL</productname> 버전 번호는 메이저 버전과
   마이너 버전 번호로 구성된다.  예를 들어 10.1 이라면 10이 메이저 버전이고, 
   1이 마이너 버전이다. 마이너 버전 1 이라 함은 10 버전 가운데 첫번째 
   패치 버전을 의미한다.  <productname>PostgreSQL</productname> 10.0 버전부터
   이렇게 하기로 했으며, 그 이전 버전에서는 메이저 버전이 앞 부분 두 영역이다.
   예를 들어, 9.5.3 이라면, 메이저 버전이 9.5 이며, 3이 마이너 버전이며, 
   9.5 버전 가운데 세번째 패치 버전임을 뜻한다.
  </para>

  <para>
   메이저 버전은 그대로이고, 마이너 버전만 바뀌는 경우는
   내부 저장 형식이 바뀌지 않는 경우이다.  즉, 10.1 버전이나, 
   10.6 버전은 호환되며, 9.5.3과는 호환되지 않는다. 9.5.3은
   9.5.0, 9.5.1, 9.5.6 버전과 호환된다.  호환되는 버전간의 업그레이드는
   자료 구조가 바뀌지 않기 때문에, 
   단순하게, 서버를 중지하고, 실행 파일을 바꾸기만 하면 된다. &mdash; 쉽다.
  </para>

<para>
<productname>PostgreSQL</productname>의 <emphasis>메이저</emphasis>
릴리스의 경우, 내부 데이터 스토리지 형식이 변경되므로 업그레이드가
복잡하다.  데이터를 새로운 메이저 버전으로 옮기는 전형적인
방법은 느릴 수 있지만 데이터베이스를 덤프하고 다시 불러오는
것이다.  더 빠른 방법은 <xref linkend="pgupgrade"/>이다. 복제
방법도 아래에 언급된 바와 같이 사용 가능하다.
</para>

<para>
일반적으로 새 메이저 버전에서도 사용자 가시(user-visible) 비호환성이
도입되므로 어플리케이션 프로그래밍 변경이 요구되곤 한다.  모든
사용자 가시(user-visible) 변경은 릴리스 노트(<xref
 linkend="release"/>)에 나와 있다. "마이그레이션" 절을 특히 주의 깊게
보아야 한다. Though you can upgrade from one major version
   to another without upgrading to intervening versions, you should read
   the major release notes of all intervening versions.
</para>

<para>
세심한 사용자라면 새 버전으로 완전히 넘어가기 전에 클라이언트 어플리케이션을 새 버전에서 테스트해보고 싶을 것이다. 그러므로, 이전 버전과 새 버전의 동시 설치를 설정하는 것이 좋은 아이디어이다. <productname>PostgreSQL</productname> 메이저 업그레이드를 테스트할 때 다음과 같이 변경 가능성이 있는 카테고리를 고려해야 한다.
</para>

<variablelist>

 <varlistentry>
<term>관리</term>
<listitem>
 <para>
서버를 모니터링 및 관리하기 위해 관리자가 사용할 수 있는 기능이 메이저 릴리스에서 주로 변경 및 개선된다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term>SQL</term>
<listitem>
 <para>
일반적으로 새 SQL 명령이 여기에 포함되고, 특별한 언급이 릴리스 노트에 없으면 동작하지 않는 변경은 없다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term>라이브러리 API</term>
<listitem>
 <para>
릴리스 노트에 특별한 언급이 없으면, <application>libpq</application> 같은 전형적인 라이브러리만 새로운 기능을 추가한다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term>시스템 카탈로그</term>
<listitem>
 <para>
시스템 카탈로그 변경은 보통 데이터베이스 관리 도구에만 영향을 미친다.
 </para>
</listitem>
 </varlistentry>

 <varlistentry>
<term>서버 C 언어 API</term>
<listitem>
 <para>
이것은 C 프로그래밍 언어로 작성된 백엔드 함수 API의 변경과 관련이 있다. 해당 변경은 서버 내 백엔드 함수를 참조하는 코드에 영향을 미친다.
 </para>
</listitem>
 </varlistentry>

</variablelist>

<sect2 id="upgrading-via-pgdumpall">
 <title><application>pg_dumpall</application>을 통한 데이터 업그레이드</title>

 <para>
업그레이드 방법 중 하나는 <productname>PostgreSQL</productname>의 메이저 버전에서 데이터를 덤프하고 다른 버전에서 다시 불러오는 것이다. 이렇게 하려면 <application>pg_dumpall</application> 같은 <emphasis>논리적</emphasis> 백업 툴을 사용해야 한다. 파일 시스템 레벨 백업 방법은 작동되지 않는다. (호환되지 않는 <productname>PostgreSQL</productname> 버전으로는 데이터 디렉터리를 사용하지 못하도록 하는 검사가 존재하며,그래서 데이터 디렉터리에서 잘못된 서버 버전을 시작하려는 시도가 있더라도 큰 위험은 방지된다.)
 </para>

 <para>
이 프로그램에서 개선 기능의 장점을 활용하려면 <emphasis>새</emphasis> 버전의 <productname>PostgreSQL</productname>에서 <application>pg_dump</application> 및 <application>pg_dumpall</application> 프로그램을 사용하는 것이 바람직하다. 덤프 프로그램의 현재 릴리스는 과거의 모든 서버 버전부터 7.0까지의 데이터를 읽을 수 있다.
 </para>

 <para>
이 지침은 기존 설치가 <filename>/usr/local/pgsql</filename> 디렉터리이고, 데이터 영역이 <filename>/usr/local/pgsql/data</filename>인 것으로 간주한다. 사용자 경로에 맞게 적절한 대체가 필요하다.
 </para>

 <procedure>
<step>
 <para>
백업 시 데이터베이스가 업데이트 중이 아닌지 확인해야 한다. 이것이 백업의 무결성에는 영향을 미치지 않지만 변경된 데이터는 당연히 포함되지 않는다. 필요 시 <filename>/usr/local/pgsql/data/pg_hba.conf</filename> 파일(또는 동등한 파일)에서 권한을 편집하여 사용자 본인을 제외한 모든 사람의 액세스를 불허해야 한다. 액세스 제어에 대한 자세한 내용은 <xref linkend="client-authentication"/>을 참조 바란다.
 </para>

 <para>
<indexterm>
 <primary>pg_dumpall</primary>
 <secondary>use during upgrade</secondary>
</indexterm>

데이터베이스 설치를 백업하려면 다음을 입력한다.
<screen>
<userinput>pg_dumpall &gt; <replaceable>outputfile</replaceable></userinput>
</screen>
 </para>

 <para>
백업을 하기 위해 현재 실행 중인 버전에서 <application>pg_dumpall</application> 명령을 선택할 수 있다. 자세한 내용은 <xref
linkend="backup-dump-all"/>을 참조 바란다. 최고의 결과를 내려면 버그 수정 기능이 있고 이전 버전보다 개선된 <productname>PostgreSQL</productname> 9.4.1에서 <application>pg_dumpall</application> 명령의 사용을 시도해야 한다. 새 버전을 아직 설치하지 않았기 때문에 이 권고가 이상해 보일 수 있지만 새 버전을 이전 버전과 병행 설치할 생각이면 이것을 따르는 것이 좋다. 이런 경우 설치를 정상적으로 완료하고 데이터는 나중에 전송할 수 있다. 이렇게 하면 다운타임도 줄어든다.
 </para>
</step>

<step>
 <para>
이전 서버 셧다운:
<screen>
<userinput>pg_ctl stop</userinput>
</screen>
부팅 시에 <productname>PostgreSQL</productname>이 시작되는 시스템에서 같은 작업을 수행하는 파일이 있을 수 있다. 예를 들면, <systemitem class="osname">Red Hat Linux</systemitem> 시스템에서도 이러한 동작을 찾아볼 수 있다.
<screen>
<userinput>/etc/rc.d/init.d/PostgreSQL stop</userinput>
</screen>
서버 시작 및 중단에 대한 내용은 <xref linkend="runtime"/>을 참조 바란다.
 </para>
</step>

<step>
 <para>
백업으로부터 복구하는 경우 버전이 명시된 것이 아니라면 이전 설치 디렉터리의 이름을 변경하거나 디렉터리를 삭제해야 한다. 문제가 발생해서 되돌아 가야 할 때를 대비해서 디렉터리를 삭제하는 것보다는 이름을 변경하는 것이 낫다. 디렉터리는 디스크 공간을 상당량 차지한다는 사실을 잊으면 안 된다. 디렉터리 이름을 변경하려면 다음과 같은 명령을 사용한다.
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</userinput>
</screen>
 (디렉터리를 단일 유닛으로 이동하여 관련 경로가 바뀌지 않게 해야 한다.)
 </para>
</step>

<step>
 <para>
<productname>PostgreSQL</productname> 새 버전은
<xref linkend="install-procedure"/>에 요약된 대로 설치한다.
 </para>
</step>

<step>
 <para>
필요 시 데이터베이스 클러스터를 새로 생성한다. 특수한 데이터베이스 사용자 계정(업그레이드 중 이미 보유하고 있는)으로 로그인한 상태에서 이 명령을 실행해야 한다는 것을 잊으면 안 된다.

<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</userinput>
</programlisting>
 </para>
</step>

<step>
 <para>
이전 <filename>pg_hba.conf</filename> 및 모든 <filename>postgresql.conf</filename> 수정 내용을 복원한다.
 </para>
</step>

<step>
 <para>
특수 데이터베이스 사용자 계정을 사용하여 데이터베이스 서버를 다시 시작한다.
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</userinput>
</programlisting>
 </para>
</step>

<step>
 <para>
마지막으로 다음 명령으로 데이터를 복원한다.
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</replaceable></userinput>
</screen>
이때 <emphasis>새</emphasis> <application>psql</application>을 사용한다.
 </para>
</step>
 </procedure>

 <para>
새 서버를 다른 디렉터리에 설치하고 이전 및 새 서버를 서로 다른 포트에서 병렬 실행하면 다운타임을 최소화할 수 있다. 그런 다음, 사용자는 데이터를 전송하기 위해 다음과 같은 명령어를 사용할 수 있다.

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
이 명령으로 데이터가 전송된다.
 </para>

</sect2>

<sect2 id="upgrading-via-pg-upgrade">
 <title><application>pg_upgrade</application>를 통한 데이터 업그레이드</title>

 <para>
<xref linkend="pgupgrade"/> 모듈은 메이저 <productname>PostgreSQL</productname> 버전에서 다른 버전으로 현재 위치에 마이그레이션되는 설치를 허용한다. 특별히 <option>--link</option> 모드를 사용하면 수 분 이내에 업그레이드가 가능하다. 이것은 위의 <application>pg_dumpall</application>과 유사한 단계가 필요하다(예: 서버 시작/중지, <application>initdb</application> 실행). <application>pg_upgrade</application>문서에는 필수 단계가 간략하게 나와 있다.
 </para>

</sect2>

<sect2 id="upgrading-via-replication">
 <title>복제를 통한 데이터 업그레이드</title>

 <para>
    It is also possible to use logical replication methods to create a standby
    server with the updated version of <productname>PostgreSQL</productname>.
    This is possible because logical replication supports
스탠바이는 동일한 컴퓨터 또는 다른 컴퓨터에 있는 것일 수 있다. 일단 마스터 서버(<productname>PostgreSQL</productname>의 이전 버전 실행 중)와 동기화되면, 마스터 서버를 전환하고 마스터 서버를 스탠바이한 상태에서 이전 데이터베이스 인스턴스를 셧다운할 수 있다. 따라서 이러한 전환 방식에 의하면, 업그레이드 다운타임이 수 초에 불과하게 된다.
 </para>
  <para>
    This method of upgrading can be performed using the built-in logical
    replication facilities as well as using external logical replication
    systems such as <productname>pglogical</productname>,
    <productname>Slony</productname>, <productname>Londiste</productname>, and
    <productname>Bucardo</productname>.
  </para>
</sect2>
 </sect1>

 <sect1 id="preventing-server-spoofing">
<title>서버 스푸핑 방지</title>

<indexterm zone="preventing-server-spoofing">
 <primary>서버 스푸핑</primary>
</indexterm>

<para>
   서버 실행 중에 악의적 사용자가 정상적인 데이터베이스 서버를 차지하는 것은
   불가능하다.  단, 서버 다운 시 로컬 사용자가 자신의 서버를 시작함으로써
   정상적인 서버를 스푸핑하는 것은 가능하다.  스푸핑 서버는 클라이언트가
   보낸 패스워드와 쿼리를 읽을 수 있지만 디렉터리 권한 때문에
   <varname>PGDATA</varname> 디렉터리는 보호되므로 데이터를 리턴할 수는 없다.  어떤
   사용자든 데이터베이스 서버를 시작할 수 있으므로 스푸핑이 가능하다.  특수하게
   환경 설정되지 않은 경우 클라이언트가 잘못된 서버를 식별해낼 수는 없다.
</para>

<para>
   <literal>local</literal> 연결에 대한 스푸핑을 방지하는 한 방법은
   신뢰된 로컬 사용자에 대해서만 쓰기 권한이 있는 Unix 도메인 소켓 디렉터리(<xref
   linkend="guc-unix-socket-directories"/>)를 사용하는 것이다. 이로써
   악의적 사용자가 자체 소켓 파일을 해당 디렉터리에 생성하는 것이 방지된다. 일부
   어플리케이션이 소켓 파일로 <filename>/tmp</filename>를 계속 참조해야 해서 스푸핑에
   취약한 경우라면 운영 체제 시작 시에 위치 변경된 소켓 파일을 가리키는 심볼릭
   링크 <filename>/tmp/.s.PGSQL.5432</filename>를 생성해야 한다. 또한 사용자의 
   <filename>/tmp</filename> 클린업 스크립트를 수정해서 심볼릭 링크가 삭제되지 않게 해야 한다.
</para>

<para>
   <literal>local</literal> 연결에 대한 스푸핑을 방지하는 다른 한 방법은 
   <link linkend="libpq-connect-requirepeer"><literal>requirepeer</literal></link>
   옵션을 사용하는 방법이다.
</para>

<para>
   To prevent spoofing on TCP connections, either use
   SSL certificates and make sure that clients check the server's certificate,
   or use GSSAPI encryption (or both, if they're on separate connections).
  </para>

  <para>
   SSL 인증으로 스푸핑을 방지하려면,
   <literal>hostssl</literal> 연결만 수락하고(<xref
   linkend="auth-pg-hba-conf"/>) ssl 키와 인증서 파일(<xref linkend="ssl-tcp"/>)을
   갖도록 서버를 환경 설정해야 한다.  TCP 클라이언트는 <literal>sslmode=verify-ca</literal>
   또는 <literal>verify-full</literal>을 사용하여 연결해야 하며,  적절한 루트 인증서
   파일이 설치되어야 한다(<xref linkend="libq-ssl-certificates"/> 참조).
  </para>

  <para>
    To prevent spoofing with GSSAPI, the server must be configured to accept
    only <literal>hostgssenc</literal> connections
    (<xref linkend="auth-pg-hba-conf"/>) and use <literal>gss</literal>
    authentication with them.  The TCP client must connect
    using <literal>gssencmode=require</literal>.
  </para>
 </sect1>

 <sect1 id="encryption-options">
<title>암호화 옵션</title>

<indexterm zone="encryption-options">
 <primary>암호화</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname>은 데이터베이스 서버 도난, 비양심적인 관리자 및 불안정한 네트워크로 인해 데이터가 공개되지 않도록 보호하는 데 있어 몇 가지 단계의 암호화와 유연성을 제공한다. 또한 암호화는 의료 기록 또는 금융 트랜잭션 같은 중요 데이터의 보호를 위해서도 필요하다.
</para>

<variablelist>

<varlistentry>
 <term>패스워드 암호화</term>
 <listitem>

<para>
     Database user passwords are stored as hashes (determined by the setting
     <xref linkend="guc-password-encryption"/>), so the administrator cannot
     determine the actual password assigned to the user. If SCRAM or MD5
     encryption is used for client authentication, the unencrypted password is
     never even temporarily present on the server because the client encrypts
     it before being sent across the network. SCRAM is preferred, because it
     is an Internet standard and is more secure than the PostgreSQL-specific
     MD5 authentication protocol.
</para>
 </listitem>
</varlistentry>

<varlistentry>
 <term>특정 칼럼에 대한 암호화</term>

 <listitem>
<para>
<xref linkend="pgcrypto"/> 모듈은 특정 필드를 암호화해서 저장하는 것을 허용한다. 일부 데이터만 중요한 경우에 이것이 유용하다. 클라이언트가 암호 해독 키를 제공하고 데이터가 서버에서 암호 해독된 다음, 클라이언트로 전송된다.
</para>

<para>
암호 해독된 데이터 및 암호 해독 키는 암호가 해독되고 클라이언트와 서버 간에 통신이 일어나는 짧은 시간 동안 서버에 제공된다. 여기에는 시스템 관리자처럼 데이터베이스 서버에 대한 전체 액세스 권한이 있는 누군가가 데이터와 키를 가로챌 수 있는 짧은 순간이 존재한다.
</para>
 </listitem>
</varlistentry>

<varlistentry>
 <term>데이터 파티션 암호화</term>

 <listitem>
<para>
스토리지 암호화는 파일 시스템 레벨 또는 블록 레벨에서 수행된다. Linux 파일 시스템 암호화 옵션에는 eCryptfs 및 EncFS가 포함되는 반면, FreeBSD는 PEFS를 사용한다. 블록 레벨 또는 풀 디스크 암호화 옵션에는, Linux에서는 dm-crypt + LUKS가 포함되고 FreeBSD에서는 GEOM 모듈 geli 및 gbde가 포함된다. Windows를 비롯한 여러 가지 다른 운영 체제에서 이 기능이 지원된다.
</para>

<para>
드라이브 또는 전제 컴퓨터가 도난 당한 경우 이 메커니즘은 암호화되지 않은 데이터를 드라이브에서 읽지 못하게 한다. 파일 시스템이 마운트될 때 운영 체제가 암호화되지 않은 데이터 뷰를 제공하므로 파일 시스템이 마운트된 상태에서는 공격으로부터 데이터를 보호하지 못한다. 그러나, 파일 시스템을 마운트하려면 암호화 키를 운영 체제에 전달하는 방법이 필요하며, 디스크를 마운트하는 호스트 어딘가에 키를 저장해야 할 때도 있다.
</para>
 </listitem>
</varlistentry>

<varlistentry>
 <term>네트워크에서 데이터 암호화</term>

<listitem>
 <para>
SSL 연결은 네트워크로 전송된 모든 데이터(패스워드, 쿼리 및 리턴 데이터)를
암호화한다. <filename>pg_hba.conf</filename> 파일은 어떤 호스트가
암호화되지 않은 연결을 사용할 수 있는지(<literal>host</literal>) 및
어떤 것이 SSL-암호화된 연결을 요구하는지(<literal>hostssl</literal>)를
관리자가 지정할 수 있게 한다.  또한 클라이언트는 SSL을
통해서만 서버에 연결하도록 지정 가능하다.
     </para>

     <para>
      GSSAPI-encrypted connections encrypt all data sent across the network,
      including queries and data returned.  (No password is sent across the
      network.)  The <filename>pg_hba.conf</filename> file allows
      administrators to specify which hosts can use non-encrypted connections
      (<literal>host</literal>) and which require GSSAPI-encrypted connections
      (<literal>hostgssenc</literal>).  Also, clients can specify that they
      connect to servers only on GSSAPI-encrypted connections
      (<literal>gssencmode=require</literal>).
     </para>

     <para>
      <application>Stunnel</application> or
      <application>SSH</application> can also be used to encrypt
      transmissions.
 </para>
</listitem>
</varlistentry>

<varlistentry>
 <term>SSL 호스트 인증</term>

 <listitem>
<para>
이것은 클라이언트 및 서버 양쪽에서 서로 간에 SSL 인증서를 제공하는 것이 가능하다. 양쪽에서 추가적인 설정이 일부 필요하지만 이로써 단순히 패스워드만 사용하는 것보다 훨씬 강력한 ID 검증이 가능하다. 이것은 클라이언트가 보낸 패스워드를 읽는 데 필요한 시간만큼 컴퓨터가 서버인 척하는 것을 방지한다. 또한 클라이언트와 서버 사이에 있는 컴퓨터가 서버인 척 해서 클라이언트와 서버 사이의 모든 데이터를 읽고 전달하는 <quote>중간자(man in the middle)</quote> 공격을 방지하는 데에도 효과가 있다.
</para>
 </listitem>
</varlistentry>

<varlistentry>
 <term>클라이언트 측 암호화</term>

 <listitem>
<para>
서버 머신의 시스템 관리자를 신뢰할 수 없는 경우 클라이언트가 데이터를 암호화해야 한다. 이러한 방식으로 암호화되지 않은 데이터를 데이터베이스 서버에 절대 나타나지 않는다. 데이터는 서버로 전송되기 전에 클라이언트에서 암호화되고 데이터베이스 결과는 사용 전에 클라이언트에서 암호가 해독되어야 한다.
</para>
 </listitem>
</varlistentry>

</variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
<title>SSL을 사용한 TCP/IP 연결 보호</title>

<indexterm zone="ssl-tcp">
 <primary>SSL</primary>
</indexterm>

<para>
<productname>PostgreSQL</productname>은 <acronym>SSL</acronym> 연결을 사용하여 보안 강화를 위한 클라이언트/서버 통신을 암호화하는 기본적인 지원이 있다. 이것은 클라이언트와 서버 시스템에 <productname>OpenSSL</productname>을 설치해야 하고 <productname>PostgreSQL</productname>에서의 지원이 빌드 시 활성화되어야 한다(<xref linkend="installation"/> 참조). 
</para>

 <sect2 id="ssl-setup">
   <title>Basic Setup</title>

<para>
컴파일된 <acronym>SSL</acronym> 지원을 사용함으로써
<filename>postgresql.conf</filename>에서 파라미터 <xref linkend="guc-ssl"/>을 <literal>on</literal>으로 설정하면 <acronym>SSL</acronym>를 활성화한 상태로 <productname>PostgreSQL</productname> 서버를 시작할 수 있다. 서버는 동일한 TCP 포트에서 일반 및 <acronym>SSL</acronym> 연결을 listen하고 <acronym>SSL</acronym> 연결 여부에 대해 클라이언트 연결을 성사시킨다. 기본적으로 이것은 클라이언트의 옵션이다. 일부 또는 모든 연결에 대해 <acronym>SSL</acronym>의 사용을 요구하도록 서버를 설정하는 방법은 <xref
 linkend="auth-pg-hba-conf"/>을 참조 바란다.
</para>

<para>
<acronym>SSL</acronym> 모드에서 시작하려면 서버 인증서가 포함된 파일과 개인 키가 존재해야 한다. 기본적으로, 이러한 파일은 각각 서버의 데이터 디렉터리에서 이름이 <filename>server.crt</filename> 및 <filename>server.key</filename>일 것으로 예상되지만, 환경 설정 파라미터<xref linkend="guc-ssl-cert-file"/> 및 <xref linkend="guc-ssl-key-file"/>을 사용하여 다른 이름과 위치를 지정할 수 있다. Unix 시스템에서 <filename>server.key</filename>에 대한 권한은 월드 또는 그룹에 대한 액세스를 불허해야 한다. 이것은 <command>chmod 0600 server.key</command> 명령에 의해 수행된다.
   Alternatively, the file can be
   owned by root and have group read access (that is, <literal>0640</literal>
   permissions).  That setup is intended for installations where certificate
   and key files are managed by the operating system.  The user under which
   the <productname>PostgreSQL</productname> server runs should then be made a
   member of the group that has access to those certificate and key files.
</para>

  <para>
    If the data directory allows group read access then certificate files may
    need to be located outside of the data directory in order to conform to the
    security requirements outlined above.  Generally, group access is enabled
    to allow an unprivileged user to backup the database, and in that case the
    backup software will not be able to read the certificate files and will
    likely error.
  </para>

  <para>
   If the private key is protected with a passphrase, the
   server will prompt for the passphrase and will not start until it has
   been entered.
   Using a passphrase by default disables the ability to change the server's
   SSL configuration without a server restart, but see <xref
   linkend="guc-ssl-passphrase-command-supports-reload"/>.
   Furthermore, passphrase-protected private keys cannot be used at all
   on Windows.
  </para>

<!-- para>
개인 키가 암호로 보호되는 경우 서버는 암호를 묻는 메시지를 표시하고 암호가 입력되기 전에는 서버가 시작되지 않는다.
물론 이 암호 묻는 작업을 생략하도록 SSL 설정을 바꿀 수도 있으며, 
추가적으로 Windows 환경에서는 반대로 암호를 묻는 개인키를 사용할 수 없다.
</para -->

  <para>
   The first certificate in <filename>server.crt</filename> must be the
   server's certificate because it must match the server's private key.
   The certificates of <quote>intermediate</quote> certificate authorities
   can also be appended to the file.  Doing this avoids the necessity of
   storing intermediate certificates on clients, assuming the root and
   intermediate certificates were created with <literal>v3_ca </literal>
   extensions.  (This sets the certificate's basic constraint of
   <literal>CA</literal> to <literal>true</literal>.)
   This allows easier expiration of intermediate certificates.
  </para>

  <para>
   It is not necessary to add the root certificate to
   <filename>server.crt</filename>.  Instead, clients must have the root
   certificate of the server's certificate chain.
  </para>
   </sect2>

  <sect2 id="ssl-openssl-config">
   <title>OpenSSL Configuration</title>

  <para>
   <productname>PostgreSQL</productname> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</literal>.
   This default can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration file.
  </para>

  <para>
   <productname>OpenSSL</productname> supports a wide range of ciphers
   and authentication algorithms, of varying strength.  While a list of
   ciphers can be specified in the <productname>OpenSSL</productname>
   configuration file, you can specify ciphers specifically for use by
   the database server by modifying <xref linkend="guc-ssl-ciphers"/> in
   <filename>postgresql.conf</filename>.
  </para>

  <note>
   <para>
    It is possible to have authentication without encryption overhead by
    using <literal>NULL-SHA</literal> or <literal>NULL-MD5</literal> ciphers.  However,
    a man-in-the-middle could read and pass communications between client
    and server.  Also, encryption overhead is minimal compared to the
    overhead of authentication.  For these reasons NULL ciphers are not
    recommended.
   </para>
  </note>

<para>
경우에 따라 서버 인증서를 클라이언트가 직접 신뢰하지 않고 <quote>중간</quote> 인증 기관에서 서명할 수 있다. 해당 인증서를 사용하려면 <filename>server.crt</filename> 파일에 서명 기관의 인증서를 첨부한 다음, 해당 상급 기관의 인증서를 첨부하는 순으로 클라이언트에 의해 신뢰된 인증 기관, <quote>root</quote> 또는 <quote>중간</quote>까지 첨부한다(예를 들면 클라이언트의 <filename>root.crt</filename> 파일에서 인증서로 서명된).
</para>

  <para>
   The first certificate in <filename>server.crt</filename> must be the
   server's certificate because it must match the server's private key.
   The certificates of <quote>intermediate</quote> certificate authorities
   can also be appended to the file.  Doing this avoids the necessity of
   storing intermediate certificates on clients, assuming the root and
   intermediate certificates were created with <literal>v3_ca</literal>
   extensions.  This allows easier expiration of intermediate certificates.
  </para>

  <para>
   It is not necessary to add the root certificate to
   <filename>server.crt</filename>.  Instead, clients must have the root
   certificate of the server's certificate chain.
  </para>
  </sect2>

  <sect2 id="ssl-client-certificates">
   <title>Using Client Certificates</title>

  <para>
   To require the client to supply a trusted certificate,
   place certificates of the root certificate authorities
   (<acronym>CA</acronym>s) you trust in a file in the data
   directory, set the parameter <xref linkend="guc-ssl-ca-file"/> in
   <filename>postgresql.conf</filename> to the new file name, and add the
   authentication option <literal>clientcert=verify-ca</literal> or
   <literal>clientcert=verify-full</literal> to the appropriate
   <literal>hostssl</literal> line(s) in <filename>pg_hba.conf</filename>.
   A certificate will then be requested from the client during SSL
   connection startup.  (See <xref linkend="libpq-ssl"/> for a description
   of how to set up certificates on the client.)
  </para>

  <para>
   For a <literal>hostssl</literal> entry with
   <literal>clientcert=verify-ca</literal>, the server will verify
   that the client's certificate is signed by one of the trusted
   certificate authorities. If <literal>clientcert=verify-full</literal>
   is specified, the server will not only verify the certificate
   chain, but it will also check whether the username or its mapping
   matches the <literal>cn</literal> (Common Name) of the provided certificate.
   Note that certificate chain validation is always ensured when the
   <literal>cert</literal> authentication method is used
   (see <xref linkend="auth-cert"/>).
  </para>

  <para>
   Intermediate certificates that chain up to existing root certificates
   can also appear in the <xref linkend="guc-ssl-ca-file"/> file if
   you wish to avoid storing them on clients (assuming the root and
   intermediate certificates were created with <literal>v3_ca </literal>
   extensions.  (This sets the certificate's basic constraint of
   <literal>CA</literal> to <literal>true</literal>.)
   This allows easier expiration of intermediate certificates.
   checked if the parameter <xref linkend="guc-ssl-crl-file"/> is set.
  </para>

  <para>
   The <literal>clientcert</literal> authentication option is available for
   all authentication methods, but only in <filename>pg_hba.conf</filename> lines
   specified as <literal>hostssl</literal>.  When <literal>clientcert</literal> is
   not specified or is set to <literal>no-verify</literal>, the server will still
   verify any presented client certificates against its CA file, if one is
   configured &mdash; but it will not insist that a client certificate be presented.
  </para>

  <para>
   There are two approaches to enforce that users provide a certificate during login.
  </para>

  <para>
   The first approach makes use of the <literal>cert</literal> authentication
   method for <literal>hostssl</literal> entries in <filename>pg_hba.conf</filename>,
   such that the certificate itself is used for authentication while also
   providing ssl connection security. See <xref linkend="auth-cert"/> for details.
   (It is not necessary to specify any <literal>clientcert</literal> options
   explicitly when using the <literal>cert</literal> authentication method.)
   In this case, the <literal>cn</literal> (Common Name) provided in
   the certificate is checked against the user name or an applicable mapping.
  </para>

  <para>
   The second approach combines any authentication method for <literal>hostssl</literal>
   entries with the verification of client certificates by setting the
   <literal>clientcert</literal> authentication option to <literal>verify-ca</literal>
   or <literal>verify-full</literal>. The former option only enforces that
   the certificate is valid, while the latter also ensures that the
   <literal>cn</literal> (Common Name) in the certificate matches
   the user name or an applicable mapping.
  </para>
  </sect2>

<sect2 id="ssl-server-files">
 <title>SSL 서버 파일 사용</title>

 <para>
<xref linkend="ssl-file-usage"/>는 서버에서 SSL 설정과 관련된 파일들을 요약한 것이다. (표시된 파일 이름은 기본값 또는 일반적인 이름이다. 로컬로 환경 설정된 이름은 다를 수 있다.)
 </para>

<table id="ssl-file-usage">
 <title>SSL 서버 파일 사용</title>
 <tgroup cols="3">
<thead>
 <row>
<entry>파일</entry>
<entry>내용</entry>
<entry>효과</entry>
 </row>
</thead>

<tbody>

 <row>
<entry><xref linkend="guc-ssl-cert-file"/> (<filename>$PGDATA/server.crt</filename>)</entry>
<entry>서버 인증서</entry>
<entry>클라이언트로 전송되어 서버 ID 표시</entry>
 </row>

 <row>
<entry><xref linkend="guc-ssl-key-file"/> (<filename>$PGDATA/server.key</filename>)</entry>
<entry>서버 개인 키</entry>
<entry>소유자가 보낸 서버 인증서 검증; 인증서 소유자가 믿을만하다는 것을 나타내지는 않음</entry>
 </row>

 <row>
<entry><xref linkend="guc-ssl-ca-file"/></entry>
<entry>신뢰된 인증서 기관</entry>
<entry>클라이언트 인증서가 신뢰된 인증 기관에 의해 서명되었는지 확인</entry>
 </row>

 <row>
<entry><xref linkend="guc-ssl-crl-file"/></entry>
<entry>인증 기관에서 취소된 인증서</entry>
<entry>클라이언트가 인증서가 이 목록에 있으면 안 됨</entry>
 </row>

</tbody>
 </tgroup>
</table>

 <para>
<filename>server.key</filename>, <filename>server.crt</filename>,
<filename>root.crt</filename> 및 <filename>root.crl</filename>
파일(또는 환경 설정된 다른 이름)은 서버 시작 중에만 검사되므로 변경 내용을 적용하려면 서버를 재시작해야 한다.
 </para>
</sect2>

  <sect2 id="ssl-certificate-creation">
   <title>Creating Certificates</title>

   <para>
     To create a simple self-signed certificate for the server, valid for 365
     days, use the following <productname>OpenSSL</productname> command,
     replacing <replaceable>dbhost.yourdomain.com</replaceable> with the
     server's host name:
<programlisting>
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
</programlisting>
    Then do:
<programlisting>
chmod og-rwx server.key
</programlisting>
    because the server will reject the file if its permissions are more
    liberal than this.
    For more details on how to create your server private key and
    certificate, refer to the <productname>OpenSSL</productname> documentation.
   </para>

   <para>
    While a self-signed certificate can be used for testing, a certificate
    signed by a certificate authority (<acronym>CA</acronym>) (usually an
    enterprise-wide root <acronym>CA</acronym>) should be used in production.
   </para>

   <para>
    To create a server certificate whose identity can be validated
    by clients, first create a certificate signing request
    (<acronym>CSR</acronym>) and a public/private key file:
<programlisting>
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
</programlisting>
    Then, sign the request with the key to create a root certificate
    authority (using the default <productname>OpenSSL</productname>
    configuration file location on <productname>Linux</productname>):
<programlisting>
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt
</programlisting>
    Finally, create a server certificate signed by the new root certificate
    authority:
<programlisting>
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</filename> and <filename>server.key</filename>
    should be stored on the server, and <filename>root.crt</filename> should
    be stored on the client so the client can verify that the server's leaf
    certificate was signed by its trusted root certificate. 
    <filename>root.key</filename> should be stored offline for use in
    creating future certificates.
   </para>

   <para>
    It is also possible to create a chain of trust that includes
    intermediate certificates:
<programlisting>
# root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<replaceable>intermediate.yourdomain.com</replaceable>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</filename> and
    <filename>intermediate.crt</filename> should be concatenated
    into a certificate file bundle and stored on the server.
    <filename>server.key</filename> should also be stored on the server.
    <filename>root.crt</filename> should be stored on the client so
    the client can verify that the server's leaf certificate was signed
    by a chain of certificates linked to its trusted root certificate.
    <filename>root.key</filename> and <filename>intermediate.key</filename>
    should be stored offline for use in creating future certificates.
   </para>
  </sect2>
 </sect1>

 <sect1 id="gssapi-enc">
  <title>Secure TCP/IP Connections with GSSAPI Encryption</title>

  <indexterm zone="gssapi-enc">
   <primary>gssapi</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> also has native support for
   using <acronym>GSSAPI</acronym> to encrypt client/server communications for
   increased security.  Support requires that a <acronym>GSSAPI</acronym>
   implementation (such as MIT Kerberos) is installed on both client and server
   systems, and that support in <productname>PostgreSQL</productname> is
   enabled at build time (see <xref linkend="installation"/>).
  </para>

  <sect2 id="gssapi-setup">
   <title>Basic Setup</title>

   <para>
    The <productname>PostgreSQL</productname> server will listen for both
    normal and <acronym>GSSAPI</acronym>-encrypted connections on the same TCP
    port, and will negotiate with any connecting client on whether to
    use <acronym>GSSAPI</acronym> for encryption (and for authentication).  By
    default, this decision is up to the client (which means it can be
    downgraded by an attacker); see <xref linkend="auth-pg-hba-conf"/> about
    setting up the server to require the use of <acronym>GSSAPI</acronym> for
    some or all connections.
   </para>

   <para>
    When using <acronym>GSSAPI</acronym> for encryption, it is common to
    use <acronym>GSSAPI</acronym> for authentication as well, since the
    underlying mechanism will determine both client and server identities
    (according to the <acronym>GSSAPI</acronym> implementation) in any
    case.  But this is not required;
    another <productname>PostgreSQL</productname> authentication method
    can be chosen to perform additional verification.
   </para>

   <para>
    Other than configuration of the negotiation
    behavior, <acronym>GSSAPI</acronym> encryption requires no setup beyond
    that which is necessary for GSSAPI authentication.  (For more information
    on configuring that, see <xref linkend="gssapi-auth"/>.)
   </para>
  </sect2>
 </sect1>

 <sect1 id="ssh-tunnels">
<title><application>SSH</application> 터널을 사용하여 TCP/IP 연결 보호</title>

<indexterm zone="ssh-tunnels">
 <primary>ssh</primary>
</indexterm>

<para>
클라이언트와 <productname>PostgreSQL</productname> 서버 간 네트워크 연결을 암호화하기 위해 <application>SSH</application>를 사용할 수 있다. 제대로 된 경우 이것은 SSL이 불가능한 클라이언트에 대해서도 적절한 네트워크 연결 보호를 제공한다.
</para>

<para>
먼저 <application>SSH</application> 서버가 <productname>PostgreSQL</productname> 서버와
동일한 머신에서 올바로 실행 중인지 확인하고 <command>ssh</command>를 사용하여
일부 사용자로 로그인할 수 있는지 확인한다.  you then can establish a
   secure tunnel to the remote server.  A secure tunnel listens on a
   local port and forwards all traffic to a port on the remote machine.
   Traffic sent to the remote port can arrive on its
   <literal>localhost</literal> address, or different bind
   address if desired;  it does not appear as coming from your
   local machine.  This command creates a secure tunnel from the client
   machine to the remote machine <literal>foo.com</literal>:
<programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
<option>-L</option> 의 첫 번째 인수 63333은 터널 종단의
로컬 포트 번호이며, 미사용 포트는 무엇이든 가능하다.
(IANA는 개인용으로 포트 49152 ~ 65535를 제공한다.)
The name or IP
   address after this is the remote bind address you are connecting to,
   i.e., <literal>localhost</literal>, which is the default.  The second
   number, 5432, is the remote end of the tunnel, e.g., the port number
   your database server is using.
이 터널을 사용하여 데이터베이스 서버에 연결하기 위해 사용자는 로컬 머신의 포트 63333에 연결한다.

<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
   To the database server it will then look as though you are
   user <literal>joe</literal> on host <literal>foo.com</literal>
   connecting to the <literal>localhost</literal> bind address, and it
   will use whatever authentication procedure was configured for
   connections by that user to that bind address.  Note that the server will not
   think the connection is SSL-encrypted, since in fact it is not
   encrypted between the
   <application>SSH</application> server and the
   <productname>PostgreSQL</productname> server.  This should not pose any
   extra security risk because they are on the same machine.
</para>

<para>
터널 설정이 성공하려면 사용자가 <command>ssh</command>를 사용하여 터미널 세션을 생성하려고 하는 것처럼 <literal>joe@foo.com</literal>로써 <command>ssh</command>를 통한 연결이 허용되어야 한다
</para>

<para>
 사용자는 다음과 같이 포트 포워딩을 설정할 수도 있다.
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
그러나 데이터베이스 서버가 <literal>foo.com</literal> 바인드 주소에서 들어오는 연결을 보게 되는데, 이것은 기본 설정 <literal>listen_addresses =
 'localhost'</literal>에 의해서는 개방되지 않는다. 보통 이것은 사용자가 원하는 바가 아니다.
</para>

<para>
일부 로그인 호스트를 통해 데이터베이스 서버에 <quote>hop</quote>해야 한다면 가능한 설정 중 하나는 다음과 같을 것이다.
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
<literal>shell.foo.com</literal>에서 <literal>db.foo.com</literal>으로의 이러한 연결 방법은 SSH 터널에서 암호화되지 않는다는 점에 유의해야 한다. 다양한 방법으로 네트워크가 제한되는 경우에 SSH는 가능한 환경 설정을 다수 제공한다. 자세한 내용은 SSH 문서를 참조 바란다.
</para>

<tip>
 <para>
방금 설명한 개념과 유사한 절차를 사용하여 보안 터널을 제공할 수 있는 몇 가지 다른 어플리케이션이 존재한다.
 </para>
</tip>

 </sect1>

 <sect1 id="event-log-registration">
<title><systemitem class="osname">Windows</systemitem>에 <application>이벤트 로그</application> 등록</title>

<indexterm zone="event-log-registration">
 <primary>이벤트 로그</primary>
 <secondary>이벤트 로그</secondary>
</indexterm>

<para>
<systemitem class="osname">Windows</systemitem> <application>이벤트 로그</application> 라이브러리를 운영 체제에 등록하려면 다음 명령을 실행해야 한다.
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
이것은 <literal>PostgreSQL</literal>이라는 기본 이벤트 소스 하에서, 이벤트 뷰어가 사용하는 레지스트리 항목을 생성한다.
</para>

<para>
이벤트 소스 이름을 다르게 지정하려면(<xref linkend="guc-event-source"/> 참조), <literal>/n</literal> 및 <literal>/i</literal> 옵션을 사용해야 한다.
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</replaceable> <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
</para>

<para>
운영 체제에서 <application>이벤트 로그</application> 라이브러리를 등록 취소하려면 아래 명령을 실행해야 한다.
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</replaceable>] <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
</para>

<note>
 <para>
데이터베이스 서버에서 이벤트 로깅을 활성화하려면 <xref linkend="guc-log-destination"/>을 수정하여 <filename>postgresql.conf</filename>에서 <literal>eventlog</literal>를 포함해야 한다.
 </para>
</note>
 </sect1>

</chapter>


