<!-- doc/src/sgml/charset.sgml -->

<chapter id="charset">
 <title>로컬라이제이션</title>

 <para>
  이 장에서는 관리자의 관점에서 사용 가능한 로컬라이제이션 기능을 설명한다. 
  <productname>PostgreSQL</productname>은 두 가지 로컬라이제이션 기능을 지원한다.
   <itemizedlist>
    <listitem>
     <para>
      운영 체제의 로케일(locale) 기능을 사용하여 로케일별(locale-specific) 콜레이션 순서, 숫자 형식 설정, 
      메시지 번역 및 기타 이것은 <xref linkend="locale"/> 및 <xref linkend="collation"/>에서 다룬다.
     </para>
    </listitem>

    <listitem>
     <para>
      텍스트를 모든 종류의 언어로 저장하는 것을 지원하는 각종 문자 집합 및 클라이언트와 서버 간 문자 집합 번역. 
      이것은 <xref linkend="multibyte"/>에서 다룬다.
     </para>
    </listitem>
   </itemizedlist>
  </para>


 <sect1 id="locale">
  <title>로케일(Locale) 지원</title>

  <indexterm zone="locale"><primary>로케일</primary></indexterm>

  <para>
   로케일(<firstterm>Locale</firstterm>) 지원이란 영문자, 정렬, 숫자 형식 등 문화적인 기본 설정과 관련된 지원을 의미한다. 
   <productname>PostgreSQL</productname>는 서버 운영 체제에서 제공되는 표준 ISO C 및 <acronym>POSIX</acronym> 로케일(locale) 기능을 사용한다. 
   부가적인 정보에 대해서는 시스템 문서를 참조 바란다.
  </para>

  <sect2>
   <title>개요</title>

   <para>
    로케일(locale) 지원은 <command>initdb</command>를 사용하여 데이터베이스 클러스터가 생성되면 자동으로 초기화된다. 
    <command>initdb</command>은 기본적으로 실행 환경의 로케일(locale) 설정을 사용하여 데이터베이스 클러스터를 초기화하므로, 
    데이터베이스 클러스터에서 시스템이 이미 원하는 로케일(locale)을 사용하는 것으로 설정된 경우 사용자가 특별히 할 일은 없다. 
    다른 로케일(locale)을 사용하려면(또는 시스템에 어떤 로케일(locale)이 설정되었는지 모를 경우) 
    <option>--locale</option> 옵션으로 <command>initdb</command> 명령을 실행하여 어떤 로케일(locale)이 사용되는지 정확히 알 수 있다. 
    예를 들면:
<screen>
initdb --locale=sv_SE
</screen>
   </para>

   <para>
    Unix 시스템에 대한 이 예시에서, 스웨덴(<literal>SE</literal>)에서 사용되는 스웨덴어(<literal>sv</literal>)가 로케일로 설정된다. 
    다른 것으로는, <literal>en_US</literal>(U.S. English) 및 <literal>fr_CA</literal> (French Canadian)가 있을 수 있다. 
    로케일(locale)에 두 가지 이상의 문자 세트를 사용하는 경우 <replaceable>language_territory.codeset</replaceable> 규격의 양식을 따를 수 있다. 
    예를 들면, <literal>fr_BE.UTF-8</literal>는 <acronym>UTF-8</acronym> 문자 집합 인코딩을 사용하여 벨기에(BE)의 프랑스어(fr)를 나타낸다.
   </para>

   <para>
    시스템에서 사용할 수 있는 로케일(locale)의 이름은 운영 체제 벤더에 따라, 설치된 것에 따라 다르다. 
    대부분의 Unix 시스템에서 <literal>locale -a</literal> 명령은 사용 가능한 로케일(locale) 목록을 보여준다. 
    Windows는 <literal>German_Germany</literal> 또는 <literal>Swedish_Sweden.1252</literal>같이 로케일(locale) 이름을 더 자세하게 사용하지만 원리는 동일하다.
   </para>

   <para>
    경우에 따라 몇 가지 로케일(locale) 규칙을 혼용하는 것이 유용하다. 
    예를 들면, English 콜레이션 규칙은 사용하되, Spanish 메시지는 사용하지 않을 수 있다. 
    이것을 지원하기 위해 로컬라이제이션 규칙의 특정 측면만 제어하는 로케일(locale) 보조 카테고리 집합이 존재한다.
    <informaltable>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry><envar>LC_COLLATE</envar></entry>
        <entry>String 정렬 순서</entry>
       </row>
       <row>
        <entry><envar>LC_CTYPE</envar></entry>
        <entry>문자 분류(어떤 글자인지, 대문자도 동일한지)</entry>
       </row>
       <row>
        <entry><envar>LC_MESSAGES</envar></entry>
        <entry>메시지 언어</entry>
       </row>
       <row>
        <entry><envar>LC_MONETARY</envar></entry>
        <entry>통화 형식</entry>
       </row>
       <row>
        <entry><envar>LC_NUMERIC</envar></entry>
        <entry>숫자 형식</entry>
       </row>
       <row>
        <entry><envar>LC_TIME</envar></entry>
        <entry>날짜 및 시간 형식</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    카테고리 이름은 <command>initdb</command> 옵션 이름으로 번역되어 특정 카테고리의 로케일(locale) 선택을 오버라이드한다. 
    예를 들면, 로케일(locale)을 Canadian으로 설정하되, 통화 형식은 U.S. 규칙을 사용하려면 
    <literal>initdb --locale=fr_CA --lc-monetary=en_US</literal>를 사용해야 한다.
   </para>

   <para>
    시스템에 로케일(locale) 지원이 안 되는 것처럼 하고 싶으면 
    특수한 로케일(locale) 이름 <literal>C</literal> 또는 동등하게 <literal>POSIX</literal>를 사용해야 한다.
   </para>

   <para>
    일부 로케일(locale) 카테고리는 데이터베이스가 생성될 때 고정된 값이어야 한다. 
    서로 다른 데이터베이스에 대해 서로 다른 설정을 사용할 수 있지만 데이터베이스가 생성된 다음에는 해당 데이터베이스에 대한 설정을 변경할 수 없다. 
    <literal>LC_COLLATE</literal> 및 <literal>LC_CTYPE</literal>이 이러한 카테고리이다. 이것은 인덱스 정렬 순서에 영향을 미치므로 고정된 상태로 유지되어야 하며, 
    그렇지 않을 경우 텍스트 칼럼의 인덱스가 손상을 입게 된다. 
    (그러나 <xref linkend="collation"/>에 나오는 콜레이션을 사용하면 이 제한을 완화할 수 있다.) 
    이 카테고리의 기본값은 <command>initdb</command>가 실행 중에 결정되고 이 값은 <command>CREATE DATABASE</command> 명령에서 지정되지 않았을 경우 새 데이터베이스를 생성할 때 사용된다.
   </para>

   <para>
    다른 로케일 카테고리는 로케일(locale) 카테고리와 이름이 동일한 서버 환경 설정 매개 변수를 설정함으로써 필요할 때마다 변경 가능하다(자세한 내용은 <xref
    linkend="runtime-config-client-format"/> 참조). 
    <command>initdb</command>에서 선택된 값은 실제로 환경 설정 파일 <filename>postgresql.conf</filename>에 작성되어 서버 시작 시에 기본값으로 사용된다. 
    이 할당을 <filename>postgresql.conf</filename>에서 제거하면 서버가 실행 환경에서 설정을 상속 받는다.
   </para>

   <para>
    서버의 로케일(locale) 동작은 클라이언트 환경이 아니라 서버에서 표시되는 환경 변수에서 결정된다는 점에 유의해야 한다. 
    따라서 서버를 시작하기 전에 올바른 로케일(locale) 설정을 환경 설정하는 것에 주의해야 한다. 
    이것의 결과는, 클라이언트와 서버가 서로 다른 로케일(locale)로 설정된 경우 출처에 따라 메시지가 다른 언어로 나타날 수 있다.
   </para>

   <note>
    <para>
     실행 환경에서 로케일(locale) 상속에 대해 언급할 때 이것은 대부분의 운영 체제에서 다음을 의미한다: 
     콜레이션이라는 지정된 로케일(locale) 카테고리의 경우 설정할 것을 찾을 때까지 
     이 순서로 <envar>LC_ALL</envar>, <envar>LC_COLLATE</envar>(또는 각 카테고리에 해당되는 변수), <envar>LANG</envar> 환경 변수가 검색된다. 
     이러한 환경 변수 중 어느 것도 설정되지 않은 경우 로케일(locale) 기본값은 <literal>C</literal>이다.
    </para>

    <para>
     메시지 언어 설정을 위해 일부 메시지 로컬라이제이션 라이브러리도 다른 모든 로케일(locale) 설정을 오버라이드하는 환경 변수 <envar>LANGUAGE</envar>를 살펴본다. 
     의심스러운 경우 운영 체제 문서, 특히 <application>gettext</application>에 대한 문서를 참조하기 바란다.
    </para>
   </note>

   <para>
    사용자가 원하는 언어로 메시지가 번역되게 하려면 빌드 시에 <acronym>NLS</acronym>를 선택해야 한다(<literal>configure --enable-nls</literal>). 
    다른 모든 로케일(locale) 지원은 자동으로 내장된다.
   </para>
  </sect2>

  <sect2>
   <title>동작</title>

   <para>
    로케일(locale) 설정은 다음과 같은 SQL 기능에 영향을 준다.
    <itemizedlist>
     <listitem>
      <para>
       <literal>ORDER BY</literal>를 사용한 쿼리에서 정렬 순서 또는 텍스트 데이터에서 표준 비교 연산자
       <indexterm><primary>ORDER BY</primary><secondary>및 로케일</secondary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       <function>upper</function> 및 <function>lower</function>, <function>initcap</function> 함수
       <indexterm><primary>upper</primary><secondary>및 로케일</secondary></indexterm>
       <indexterm><primary>lower</primary><secondary>및 로케일</secondary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       패턴 일치 연산자(<literal>LIKE</literal>, <literal>SIMILAR TO</literal> 및 POSIX 스타일 정규식). 
       대소문자 비 구분 일치 및 문자 클래스 정규식에 의한 문자 분류에 모두 영향을 미치는 로케일(locale)
       <indexterm><primary>LIKE</primary><secondary>및 로케일</secondary></indexterm>
       <indexterm><primary>정규식 표현</primary><secondary>및 로케일</secondary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_char</function> 계열 함수
       <indexterm><primary>to_char</primary><secondary>및 로케일</secondary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>LIKE</literal> 절을 사용한 인덱스 사용 능력
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    <productname>PostgreSQL</productname>에서 <literal>C</literal> 또는 <literal>POSIX</literal>이 아닌 다른 로케일(locale)을 사용할 때의 단점은 성능이다. 
    문자 처리가 느려지고 <literal>LIKE</literal>에서 사용되는 일반 인덱스가 방지된다. 
    이러한 이유로, 실제로 필요한 경우에만 로케일(locale)을 사용해야 한다.
   </para>

   <para>
    C가 아닌 로케일(locale) 하에서 <literal>LIKE</literal> 절을 사용한 인덱스를 <productname>PostgreSQL</productname>이 이용하게 하려면 몇 가지 커스텀 연산자 클래스가 존재해야 한다. 
    이것은 로케일(locale) 비교 규칙은 무시하면서 엄격한 문자별 비교를 수행하는 인덱스의 생성을 허용한다. 
    자세한 내용은 <xref linkend="indexes-opclass"/>을 참조 바란다. 
    다른 방법은 <xref linkend="collation"/>에 설명된 대로 <literal>C</literal> 콜레이션을 사용하여 인덱스를 생성하는 것이다.
   </para>
  </sect2>

  <sect2>
   <title>문제</title>

   <para>
    위의 설명대로 로케일(locale)이 지원되지 않으면 운영 체제의 로케일(locale) 지원이 바르게 환경 설정되었는지 확인해야 한다. 
    운영 체제에서 제공되는 경우 로케일(locale)이 시스템에 설치되었는지 확인하기 위해 <literal>locale -a</literal> 명령을 사용할 수 있다.
   </para>

   <para>
    사용자가 생각하는 로케일(locale)을 <productname>PostgreSQL</productname>이 실제로 사용 중인지 확인하라. 
    <envar>LC_COLLATE</envar> 및 <envar>LC_CTYPE</envar> 설정은 데이터베이스가 생성될 때 결정되고, 새 데이터베이스를 생성할 때 외에는 변경할 수 없다. 
    <envar>LC_MESSAGES</envar> 및 <envar>LC_MONETARY</envar>를 비롯한 다른 로케일(locale) 설정은 서버가 시작된 환경에 의해 처음 결정되고, 상황에 따라 바뀔 수 있다. 
    <command>SHOW</command> 명령을 사용하면 활성화된 로케일(locale) 설정을 확인할 수 있다.
   </para>

   <para>
    소스 배포에서 <filename>src/test/locale</filename> 디렉터리에는 <productname>PostgreSQL</productname>의 로케일(locale) 지원에 대한 테스트 세트가 포함되어 있다.
   </para>

   <para>
    에러 메시지 텍스트를 파싱하여 서버 측 에러를 처리하는 클라이언트 애플리케이션은 서버의 메시지 언어가 다르면 명백하게 문제가 된다. 
    해당 애플리케이션의 작성자는 에러 코드 스키마를 대신 활용하는 것이 좋다.
   </para>

   <para>
    메시지 번역 카탈로그를 유지하려면 <productname>PostgreSQL</productname>이 선호된 언어로 표시되도록 개발하는 자원 봉사자들의 노력이 필요하다. 
    원하는 언어로 된 메시지가 현재 없거나 번역이 완전하지 않을 수 있기 때문에 사용자들의 개발 협조를 구하고 있다. 
    도움이 필요하면 <xref linkend="nls"/>을 참조하거나 개발자의 메일링 리스트에 기록 바란다.
   </para>
  </sect2>
 </sect1>


 <sect1 id="collation">
  <title>콜레이션 지원</title>

  <para>
   콜레이션 기능으로 칼럼별 및 연산별 데이터의 정렬 순서 및 문자 분류 동작을 지정할 수 있다. 
   이것은 데이터베이스 생성 후 <symbol>LC_COLLATE</symbol> 및 <symbol>LC_CTYPE</symbol> 설정을 변경하지 못하도록 하는 제한을 완화한다.
  </para>

  <sect2>
   <title>개념</title>

   <para>
    개념적으로 콜레이션 가능한 데이터 타입의 모든 표현식은 콜레이션을 갖고 있다. 
    (콜레이션 가능한 내장된 데이터 타입은 <type>text</type> 및 <type>varchar</type>, <type>char</type>이다. 
    사용자 정의된 베이스 타입은 콜레이션 가능으로 표시될 수 있으며, 콜레이션 가능한 데이터 타입의 도메인도 콜레이션이 가능하다.) 
    표현식이 칼럼 참조인 경우 표현식의 콜레이션은 칼럼이 정의한 콜레이션이다. 표현식이 상수인 경우 콜레이션은 상수 데이터 타입의 기본 콜레이션이다. 
    좀 더 복잡한 표현식의 콜레이션은 아래 설명대로 입력 콜레이션으로부터 결정된다.
   </para>

   <para>
    표현식의 콜레이션은 데이터베이스에 대해 정의된 로케일(locale) 설정을 의미하는 <quote>기본</quote> 콜레이션이 될 수 있다. 
    표현식의 콜레이션을 결정되지 않은 상태로 하는 것도 가능하다. 
    이런 경우 콜레이션을 알아야 하는 정렬 명령 및 기타 명령은 실패한다.
   </para>

   <para>
    데이터베이스 시스템이 정렬 또는 문자 분류를 수행해야 하는 경우 입력 표현식의 콜레이션이 사용된다. 
    이것은, 예를 들면 <literal>ORDER BY</literal> 절 및 함수 또는  <literal>&lt;</literal> 같은 연산자 호출을 사용할 때 결정된다. 
    <literal>ORDER BY</literal> 절에 적용되는 콜레이션은 단순히 정렬 키의 콜레이션이다. 함수 또는 연산자 호출에 적용되는 콜레이션은 아래 설명된 인자로부터 결정된다. 
    비교 연산자 외에, 콜레이션은 <function>lower</function> 및 <function>upper</function>, <function>initcap</function> 같이 대소문자 사이를 변환하는 함수와 
    그리고 패턴 일치 및 <function>to_char</function>와 관련 함수를 사용할 때 결정된다.
   </para>

   <para>
    함수 또는 연산자 호출의 경우 인자 콜레이션 검사로 결정된 콜레이션이 작업 성능을 위해 런타임에 사용된다. 
    함수나 연산자 호출의 결과가 콜레이션 가능한 데이터 타입인 경우, 
    콜레이션에 대한 정보가 필요한 주변 표현식이 있을 때 콜레이션도 파싱 시 함수 또는 연산자 표현식의 정의된 콜레이션으로 사용된다.
   </para>

   <para>
    표현식의 <firstterm>콜레이션 결정</firstterm>은 암시적 또는 명시적일 수 있다. 
    이 차이는 복수의 서로 다른 콜레이션이 표현식에 나타나는 경우 콜레이션이 결합되는 방식에 영향을 준다. 
    <literal>COLLATE</literal> 절을 사용하면 명시적 콜레이션이 결정되고, 그 외 모든 콜레이션 파생은 암시적이다. 
    예를 들면, 함수 호출에서 복수의 콜레이션을 결합해야 하는 경우 다음과 같은 규칙이 사용된다.
    <orderedlist>
     <listitem>
      <para>
       입력 표현식이 명시적 콜레이션을 결정하는 경우 입력 표현식에서 명시적으로 파생된 모든 콜레이션은 동일해야 한다. 
       그렇지 않으면 에러가 발생한다. 명시적으로 결정된 콜레이션은 콜레이션 결합의 결과물이다.
      </para>
     </listitem>

     <listitem>
      <para>
       그 외에는, 모든 입력 표현식은 동일한 암시적 콜레이션을 결정하거나 기본 콜레이션을 사용해야 한다. 
       기본값이 아닌 콜레이션은 콜레이션 결합의 결과물이다. 그 외에는 기본 콜레이션이다.
      </para>
     </listitem>

     <listitem>
      <para>
       입력 표현식 사이에 기본이 아닌 임시적 콜레이션의 충돌이 있을 경우 결합은 불확정적인 콜레이션을 쓰는 것으로 간주된다. 
       호출하려는 특수한 함수가 적용해야 할 콜레이션에 대한 지식을 필요로 하지 않는 경우에 한하여 이것은 에러 조건이 아니다. 
       그 외에는 런타임 시 에러가 발생된다.
      </para>
     </listitem>
    </orderedlist>
예를 들어, 다음과 같은 테이블 정의를 생각해 보자.
<programlisting>
CREATE TABLE test1 (
    a text COLLATE "de_DE",
    b text COLLATE "es_ES",
    ...
);
</programlisting>
그러면,
<programlisting>
SELECT a &lt; 'foo' FROM test1;
</programlisting>
    이 구문에서 <literal>&lt;</literal> 비교는, 표현식이 명시적으로 결정된 콜레이션을 기본 콜레이션과 결합하기 때문에 <literal>de_DE</literal> 규칙에 따라 수행된다. 
    그러나,
<programlisting>
SELECT a &lt; ('foo' COLLATE "fr_FR") FROM test1;
</programlisting>
    이 구문에서는 명시적 콜레이션이 암시적 콜레이션을 오버라이드하므로 <literal>fr_FR</literal> 규칙으로 비교가 수행된다. 
    게다가,
<programlisting>
SELECT a &lt; b FROM test1;
</programlisting>
    이 구문에서는 <structfield>a</structfield> 및 <structfield>b</structfield> 칼럼의 암시적 콜레이션이 충돌하므로 어떤 콜레이션을 적용할 것인지 파서로 결정할 수 없다. 
    <literal>&lt;</literal> 연산자는 어떤 콜레이션을 사용할 것인지 알 필요가 없으므로, 결과적으로 에러가 발생한다. 
    시적 콜레이션 지정자를 입력 표현식에 추가하면 이 에러가 해결된다. 따라서,
<programlisting>
SELECT a &lt; b COLLATE "de_DE" FROM test1;
</programlisting>
    또는 동일하게, 다음과 같이 할 수 있다.
<programlisting>
SELECT a COLLATE "de_DE" &lt; b FROM test1;
</programlisting>
    즉, 구조상 동일한,
<programlisting>
SELECT a || b FROM test1;
</programlisting>
    이 구문은 <literal>||</literal> 연산자가 콜레이션에 대해 무심하므로 결과적으로 에러가 발생한다. 
    이 결과는 콜레이션과 무관하게 동일하다.
   </para>

   <para>
    또한 함수 또는 연산자의 결합된 입력 표현식에 할당된 콜레이션은 함수 또는 연산자가 콜레이션 가능한 데이터 타입의 결과를 전달하는 경우, 
    함수 또는 연산자의 결과에 적용되는 것으로 간주된다. 
    따라서,
<programlisting>
SELECT * FROM test1 ORDER BY a || 'foo';
</programlisting>
    이 구문은 <literal>de_DE</literal> 규칙에 따라 정렬된다. 그러나 이 쿼리는,
<programlisting>
SELECT * FROM test1 ORDER BY a || b;
</programlisting>
    <literal>||</literal> 연산자는 콜레이션에 대해 알고 있을 필요가 없지만 <literal>ORDER BY</literal> 절은 그렇게 하므로 결과적으로 에러가 발생한다. 
    이전과 같이, 명시적 콜레이션 지정자를 사용하면 충돌을 해결할 수 있다.
<programlisting>
SELECT * FROM test1 ORDER BY a || b COLLATE "fr_FR";
</programlisting>
   </para>
  </sect2>

  <sect2 id="collation-managing">
   <title>콜레이션 관리</title>

   <para>
    A collation is an SQL schema object that maps an SQL name to locales
    provided by libraries installed in the operating system.  A collation
    definition has a <firstterm>provider</firstterm> that specifies which
    library supplies the locale data.  One standard provider name
    is <literal>libc</literal>, which uses the locales provided by the
    operating system C library.  These are the locales that most tools
    provided by the operating system use.  Another provider
    is <literal>icu</literal>, which uses the external
    ICU<indexterm><primary>ICU</primary></indexterm> library.  ICU locales can only be
    used if support for ICU was configured when PostgreSQL was built.
   </para>

   <para>
    A collation object provided by <literal>libc</literal> maps to a
    combination of <symbol>LC_COLLATE</symbol> and <symbol>LC_CTYPE</symbol>
    settings, as accepted by the <literal>setlocale()</literal> system library call.  (As
    the name would suggest, the main purpose of a collation is to set
    <symbol>LC_COLLATE</symbol>, which controls the sort order.  But
    it is rarely necessary in practice to have an
    <symbol>LC_CTYPE</symbol> setting that is different from
    <symbol>LC_COLLATE</symbol>, so it is more convenient to collect
    these under one concept than to create another infrastructure for
    setting <symbol>LC_CTYPE</symbol> per expression.)  Also,
    a <literal>libc</literal> collation
    is tied to a character set encoding (see <xref linkend="multibyte"/>).
    다른 인코딩으로 동일한 콜레이션 이름이 존재할 수도 있다.
   </para>

   <para>
    A collation object provided by <literal>icu</literal> maps to a named
    collator provided by the ICU library.  ICU does not support
    separate <quote>collate</quote> and <quote>ctype</quote> settings, so
    they are always the same.  Also, ICU collations are independent of the
    encoding, so there is always only one ICU collation of a given name in
    a database.
   </para>

  <sect3>
    <title>표준 콜레이션</title>

   <para>
    모든 플랫폼에서 이름이 <literal>default</literal> 및 <literal>C</literal>, <literal>POSIX</literal>인 콜레이션을 사용할 수 있다. 
    추가 콜레이션은 운영 체제 지원에 따라 사용할 수 있다. 
    <literal>default</literal> 콜레이션은 데이터베이스 생성 시에 지정된 <symbol>LC_COLLATE</symbol> 및 <symbol>LC_CTYPE</symbol> 값을 선택한다. 
    <literal>C</literal> 및 <literal>POSIX</literal> 콜레이션 둘 다 ASCII 문자 <quote><literal>A</literal></quote> ~ <quote><literal>Z</literal></quote>만 글자로 처리되고 
    문자 코드 바이트 값으로 엄격하게 정렬이 되는 <quote>전형적인 C</quote> 동작을 지정한다.
   </para>

  <para>
    덧붙여, <literal>UTF8</literal> 인코딩인 경우, 
    SQL 표준 콜레이션 이름은 <literal>ucs_basic</literal>이다.  이것은
    다른 이름으로 <literal>C</literal> 이며, 유니코드 문자 정렬과 같다.
   </para>
  </sect3>

  <sect3>
   <title>미리 정의된 콜레이션</title>

   <para>
    하나의 프로그램에서 (<function>newlocale</function> 관련 함수를 이용해서) 여러 로케일을 
    사용할 수 있는 운영 체제인 경우나, ICU 라이브러리를 이용할 수 있는 환경이라면,
    <command>initdb</command> 명령을 이용해 데이터베이스 클러스터가
    초기화되면, 당시에 운영 체제에서 찾은 모든 로케일에
    따라 콜레이션으로 시스템 카탈로그 <literal>pg_collation</literal>을 채운다.
   </para>

   <para>
    To inspect the currently available locales, use the query <literal>SELECT
    * FROM pg_collation</literal>, or the command <command>\dOS+</command>
    in <application>psql</application>.
   </para>

  <sect4>
   <title>libc Collations</title>

   <para>예를
    들면, 운영 체제는 <literal>de_DE.utf8</literal>이라는 이름의 로케일(locale)을 제공할 수도 있다. 
    그러면 <command>initdb</command>는 <symbol>LC_COLLATE</symbol> 및 <symbol>LC_CTYPE</symbol>가 둘 다 <literal>de_DE.utf8</literal>로 설정된 
    <literal>UTF8</literal> 인코딩에 대해 <literal>de_DE.utf8</literal>이라는 콜레이션을 생성한다. 
    또한 이것은 이름 일부만 추려낸 <literal>.utf8</literal> 태그를 사용하여 콜레이션을 생성한다. 
    따라서 작성이 간편하고 인코딩에 대한 이름 의존도가 낮은 <literal>de_DE</literal>라는 이름으로 콜레이션을 사용할 수도 있다. 
    그래도 콜레이션 이름의 초기 설정은 플랫폼에 따라 달라진다.
   </para>

   <para>
    The default set of collations provided by <literal>libc</literal> map
    directly to the locales installed in the operating system, which can be
    listed using the command <literal>locale -a</literal>.  In case
    a <literal>libc</literal> collation is needed that has different values
    for <symbol>LC_COLLATE</symbol> and <symbol>LC_CTYPE</symbol>, or if new
    locales are installed in the operating system after the database system
    was initialized, then a new collation may be created using
    the <xref linkend="sql-createcollation"/> command.
    New operating system locales can also be imported en masse using
    the <link linkend="functions-admin-collation"><function>pg_import_system_collations()</function></link> function.
   </para>

   <para>
    특정한 데이터베이스 내에서 데이터베이스의 인코딩을 사용하는 콜레이션만 중요하다. 
    <literal>pg_collation</literal>의 다른 항목은 무시된다. 
    따라서 <literal>de_DE</literal> 같이 일부만 추려낸 콜레이션 이름은 전역적으로는 고유하지 않더라도 지정된 데이터베이스 내에서는 고유한 것으로 간주될 수 있다. 
    데이터베이스 인코딩을 다른 것으로 변경하기로 결정한 경우 변경 사항이 적은 추려낸 콜레이션 이름을 사용하는 것이 권장한다. 
    그러나 <literal>default</literal> 및 <literal>C</literal>, <literal>POSIX</literal> 콜레이션은 데이터베이스 인코딩과 무관하게 사용할 수 있다.
   </para>

   <para>
    <productname>PostgreSQL</productname>은 속성이 동일한 경우에도 별개의 콜레이션 개체는 호환되지 않는 것으로 간주한다. 
    따라서 예를 들면,
<programlisting>
SELECT a COLLATE "C" &lt; b COLLATE "POSIX" FROM test1;
</programlisting>
    이 구문은 <literal>C</literal> 및 <literal>POSIX</literal> 콜레이션의 동작이 동일하더라도 에러가 발생된다. 
    따라서 추려낸 콜레이션 이름과 추려내지 않은 콜레이션 이름의 혼용은 권장하지 않는다.
   </para>
  </sect4>

  <sect4>
   <title>ICU Collations</title>

   <para>
    With ICU, it is not sensible to enumerate all possible locale names.  ICU
    uses a particular naming system for locales, but there are many more ways
    to name a locale than there are actually distinct locales.
    <command>initdb</command> uses the ICU APIs to extract a set of distinct
    locales to populate the initial set of collations.  Collations provided by
    ICU are created in the SQL environment with names in BCP 47 language tag
    format, with a <quote>private use</quote>
    extension <literal>-x-icu</literal> appended, to distinguish them from
    libc locales.
   </para>

   <para>
    Here are some example collations that might be created:

    <variablelist>
     <varlistentry>
      <term><literal>de-x-icu</literal></term>
      <listitem>
       <para>German collation, default variant</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>de-AT-x-icu</literal></term>
      <listitem>
       <para>German collation for Austria, default variant</para>
       <para>
        (There are also, say, <literal>de-DE-x-icu</literal>
        or <literal>de-CH-x-icu</literal>, but as of this writing, they are
        equivalent to <literal>de-x-icu</literal>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>und-x-icu</literal> (for <quote>undefined</quote>)</term>
      <listitem>
       <para>
        ICU <quote>root</quote> collation.  Use this to get a reasonable
        language-agnostic sort order.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Some (less frequently used) encodings are not supported by ICU.  When the
    database encoding is one of these, ICU collation entries
    in <literal>pg_collation</literal> are ignored.  Attempting to use one
    will draw an error along the lines of <quote>collation "de-x-icu" for
    encoding "WIN874" does not exist</quote>.
   </para>
  </sect4>
  </sect3>

  <sect3 id="collation-create">
   <title>Creating New Collation Objects</title>

   <para>
    If the standard and predefined collations are not sufficient, users can
    create their own collation objects using the SQL
    command <xref linkend="sql-createcollation"/>.
   </para>

   <para>
    The standard and predefined collations are in the
    schema <literal>pg_catalog</literal>, like all predefined objects.
    User-defined collations should be created in user schemas.  This also
    ensures that they are saved by <command>pg_dump</command>.
   </para>

   <sect4>
    <title>libc Collations</title>

    <para>
     New libc collations can be created like this:
<programlisting>
CREATE COLLATION german (provider = libc, locale = 'de_DE');
</programlisting>
     The exact values that are acceptable for the <literal>locale</literal>
     clause in this command depend on the operating system.  On Unix-like
     systems, the command <literal>locale -a</literal> will show a list.
    </para>

    <para>
     Since the predefined libc collations already include all collations
     defined in the operating system when the database instance is
     initialized, it is not often necessary to manually create new ones.
     Reasons might be if a different naming system is desired (in which case
     see also <xref linkend="collation-copy"/>) or if the operating system has
     been upgraded to provide new locale definitions (in which case see
     also <link linkend="functions-admin-collation"><function>pg_import_system_collations()</function></link>).
    </para>
   </sect4>

   <sect4>
    <title>ICU Collations</title>

   <para>
    ICU allows collations to be customized beyond the basic language+country
    set that is preloaded by <command>initdb</command>.  Users are encouraged
    to define their own collation objects that make use of these facilities to
    suit the sorting behavior to their requirements.
    See <ulink url="http://userguide.icu-project.org/locale"></ulink>
    and <ulink url="http://userguide.icu-project.org/collation/api"></ulink> for
    information on ICU locale naming.  The set of acceptable names and
    attributes depends on the particular ICU version.
   </para>

   <para>
    Here are some examples:

    <variablelist>
     <varlistentry>
      <term><literal>CREATE COLLATION "de-u-co-phonebk-x-icu" (provider = icu, locale = 'de-u-co-phonebk');</literal></term>
      <term><literal>CREATE COLLATION "de-u-co-phonebk-x-icu" (provider = icu, locale = 'de@collation=phonebook');</literal></term>
      <listitem>
       <para>German collation with phone book collation type</para>
       <para>
        The first example selects the ICU locale using a <quote>language
        tag</quote> per BCP 47.  The second example uses the traditional
        ICU-specific locale syntax.  The first style is preferred going
        forward, but it is not supported by older ICU versions.
       </para>
       <para>
        Note that you can name the collation objects in the SQL environment
        anything you want.  In this example, we follow the naming style that
        the predefined collations use, which in turn also follow BCP 47, but
        that is not required for user-defined collations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATE COLLATION "und-u-co-emoji-x-icu" (provider = icu, locale = 'und-u-co-emoji');</literal></term>
      <term><literal>CREATE COLLATION "und-u-co-emoji-x-icu" (provider = icu, locale = '@collation=emoji');</literal></term>
      <listitem>
       <para>
        Root collation with Emoji collation type, per Unicode Technical Standard #51
       </para>
       <para>
        Observe how in the traditional ICU locale naming system, the root
        locale is selected by an empty string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATE COLLATION latinlast (provider = icu, locale = 'en-u-kr-grek-latn');</literal></term>
      <term><literal>CREATE COLLATION latinlast (provider = icu, locale = 'en@colReorder=grek-latn');</literal></term>
      <listitem>
       <para>
        Sort Greek letters before Latin ones.  (The default is Latin before Greek.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATE COLLATION upperfirst (provider = icu, locale = 'en-u-kf-upper');</literal></term>
      <term><literal>CREATE COLLATION upperfirst (provider = icu, locale = 'en@colCaseFirst=upper');</literal></term>
      <listitem>
       <para>
        Sort upper-case letters before lower-case letters.  (The default is
        lower-case letters first.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATE COLLATION special (provider = icu, locale = 'en-u-kf-upper-kr-grek-latn');</literal></term>
      <term><literal>CREATE COLLATION special (provider = icu, locale = 'en@colCaseFirst=upper;colReorder=grek-latn');</literal></term>
      <listitem>
       <para>
        Combines both of the above options.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATE COLLATION numeric (provider = icu, locale = 'en-u-kn-true');</literal></term>
      <term><literal>CREATE COLLATION numeric (provider = icu, locale = 'en@colNumeric=yes');</literal></term>
      <listitem>
       <para>
        Numeric ordering, sorts sequences of digits by their numeric value,
        for example: <literal>A-21</literal> &lt; <literal>A-123</literal>
        (also known as natural sort).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    See <ulink url="http://unicode.org/reports/tr35/tr35-collation.html">Unicode
    Technical Standard #35</ulink>
    and <ulink url="https://tools.ietf.org/html/bcp47">BCP 47</ulink> for
    details.  The list of possible collation types (<literal>co</literal>
    subtag) can be found in
    the <ulink url="http://www.unicode.org/repos/cldr/trunk/common/bcp47/collation.xml">CLDR
    repository</ulink>.
    The <ulink url="https://ssl.icu-project.org/icu-bin/locexp">ICU Locale
    Explorer</ulink> can be used to check the details of a particular locale
    definition.  The examples using the <literal>k*</literal> subtags require
    at least ICU version 54.
   </para>

   <para>
    Note that while this system allows creating collations that <quote>ignore
    case</quote> or <quote>ignore accents</quote> or similar (using the
    <literal>ks</literal> key), in order for such collations to act in a
    truly case- or accent-insensitive manner, they also need to be declared as not
    <firstterm>deterministic</firstterm> in <command>CREATE COLLATION</command>;
    see <xref linkend="collation-nondeterministic"/>.
    Otherwise, any strings that compare equal according to the collation but
    are not byte-wise equal will be sorted according to their byte values.
   </para>

   <note>
    <para>
     By design, ICU will accept almost any string as a locale name and match
     it to the closest locale it can provide, using the fallback procedure
     described in its documentation.  Thus, there will be no direct feedback
     if a collation specification is composed using features that the given
     ICU installation does not actually support.  It is therefore recommended
     to create application-level test cases to check that the collation
     definitions satisfy one's requirements.
    </para>
   </note>
   </sect4>

   <sect4 id="collation-copy">
   <title>Copying Collations</title>

   <para>
    The command <xref linkend="sql-createcollation"/> can also be used to
    create a new collation from an existing collation, which can be useful to
    be able to use operating-system-independent collation names in
    applications, create compatibility names, or use an ICU-provided collation
    under a more readable name.  For example:
<programlisting>
CREATE COLLATION german FROM "de_DE";
CREATE COLLATION french FROM "fr-x-icu";
</programlisting>
   </para>
   </sect4>
   </sect3>

   <sect3 id="collation-nondeterministic">
    <title>Nondeterministic Collations</title>

    <para>
     A collation is either <firstterm>deterministic</firstterm> or
     <firstterm>nondeterministic</firstterm>.  A deterministic collation uses
     deterministic comparisons, which means that it considers strings to be
     equal only if they consist of the same byte sequence.  Nondeterministic
     comparison may determine strings to be equal even if they consist of
     different bytes.  Typical situations include case-insensitive comparison,
     accent-insensitive comparison, as well as comparison of strings in
     different Unicode normal forms.  It is up to the collation provider to
     actually implement such insensitive comparisons; the deterministic flag
     only determines whether ties are to be broken using bytewise comparison.
     See also <ulink url="https://unicode.org/reports/tr10">Unicode Technical
     Standard 10</ulink> for more information on the terminology.
    </para>

    <para>
     To create a nondeterministic collation, specify the property
     <literal>deterministic = false</literal> to <command>CREATE
     COLLATION</command>, for example:
<programlisting>
CREATE COLLATION ndcoll (provider = icu, locale = 'und', deterministic = false);
</programlisting>
     This example would use the standard Unicode collation in a
     nondeterministic way.  In particular, this would allow strings in
     different normal forms to be compared correctly.  More interesting
     examples make use of the ICU customization facilities explained above.
     For example:
<programlisting>
CREATE COLLATION case_insensitive (provider = icu, locale = 'und-u-ks-level2', deterministic = false);
CREATE COLLATION ignore_accents (provider = icu, locale = 'und-u-ks-level1-kc-true', deterministic = false);
</programlisting>
    </para>

    <para>
     All standard and predefined collations are deterministic, all
     user-defined collations are deterministic by default.  While
     nondeterministic collations give a more <quote>correct</quote> behavior,
     especially when considering the full power of Unicode and its many
     special cases, they also have some drawbacks.  Foremost, their use leads
     to a performance penalty.  Also, certain operations are not possible with
     nondeterministic collations, such as pattern matching operations.
     Therefore, they should be used only in cases where they are specifically
     wanted.
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="multibyte">
  <title>문자 집합 지원</title>

  <indexterm zone="multibyte"><primary>문자 집합</primary></indexterm>

  <para>
   <productname>PostgreSQL</productname>에서 지원하는 문자 집합을 사용하면 ISO 8859 같은 싱글바이트 문자 집합 및 <acronym>EUC</acronym>(Extended Unix Code), UTF-8, 뮬 내부코드 같은 
   멀티바이트 문자 집합을 비롯한 다양한 문자 집합으로 텍스트를 저장할 수 있다. 
   지원되는 모든 문자 집합은 클라이언트에서 사용 가능한 것이 확실하지만, 
   몇 가지는 서버 내에서의 사용이 지원되지 않는다(즉, 서버 측 인코딩). 
   기본 문자 집합은 <command>initdb</command>를 사용하여 <productname>PostgreSQL</productname> 데이터베이스 클러스터를 초기화하면서 선택된다. 
   오버라이드는 데이터베이스를 생성할 때 가능하므로 복수의 데이터베이스 각각 문자 집합이 서로 다를 수 있다.
  </para>

  <para>
   하지만, 각 데이터베이스 문자 집합은 데이터베이스의 <envar>LC_CTYPE</envar>(문자 분류) 및 <envar>LC_COLLATE</envar>(string 정렬 순서) 로케일(locale) 설정과 호환되어야 한다는 중요한 제약이 있다. 
   <literal>C</literal> 또는 <literal>POSIX</literal> 로케일(locale)의 경우 멀티바이트 문자 집합이 허용되지만, libc 라이브러리에 기반한 다른 로케일(locale)의 경우 싱글바이트 문자 집합에 대해서만 정상 작동한다.
   (그러나 Windows의 경우 UTF-8 인코딩은 모든 로케일(locale)에서 사용할 수 있다.)
   If you have ICU support configured, ICU-provided locales can be used
   with most but not all server-side encodings.

  </para>

   <sect2 id="multibyte-charset-supported">
    <title>지원되는 문자 집합</title>

    <para>
     <xref linkend="charset-table"/>은 <productname>PostgreSQL</productname>에서 사용할 수 있는 문자 집합을 보여준다.
    </para>

     <table id="charset-table">
      <title><productname>PostgreSQL</productname> 문자 집합</title>
      <tgroup cols="7">
       <thead>
        <row>
         <entry>이름</entry>
         <entry>설명</entry>
         <entry>언어</entry>
         <entry>서버?</entry>
         <entry>ICU?</entry>
         <!--
          The Bytes/Char field is populated by looking at the values returned
          by pg_wchar_table.mblen function for each encoding.
         -->
         <entry>바이트/문자</entry>
         <entry>별칭</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>BIG5</literal></entry>
         <entry>Big Five</entry>
         <entry>중국어 번체</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-2</entry>
         <entry><literal>WIN950</literal>, <literal>Windows950</literal></entry>
        </row>
        <row>
         <entry><literal>EUC_CN</literal></entry>
         <entry>Extended UNIX Code-CN</entry>
         <entry>중국어 간체</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_JP</literal></entry>
         <entry>Extended UNIX Code-JP</entry>
         <entry>일본어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_JIS_2004</literal></entry>
         <entry>Extended UNIX Code-JP, JIS X 0213</entry>
         <entry>일본어</entry>
         <entry>예</entry>
         <entry>아니요</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_KR</literal></entry>
         <entry>Extended UNIX Code-KR</entry>
         <entry>한국어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_TW</literal></entry>
         <entry>Extended UNIX Code-TW</entry>
         <entry>중국어 번체, 대만</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>GB18030</literal></entry>
         <entry>National Standard</entry>
         <entry>중국어</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-4</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>GBK</literal></entry>
         <entry>Extended National Standard</entry>
         <entry>중국어 간체</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-2</entry>
         <entry><literal>WIN936</literal>, <literal>Windows936</literal></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_5</literal></entry>
         <entry>ISO 8859-5, <acronym>ECMA</acronym> 113</entry>
         <entry>라틴어/키릴어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_6</literal></entry>
         <entry>ISO 8859-6, <acronym>ECMA</acronym> 114</entry>
         <entry>라틴어/아랍어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_7</literal></entry>
         <entry>ISO 8859-7, <acronym>ECMA</acronym> 118</entry>
         <entry>라틴어/그리스어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_8</literal></entry>
         <entry>ISO 8859-8, <acronym>ECMA</acronym> 121</entry>
         <entry>라틴어/히브리어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>JOHAB</literal></entry>
         <entry><acronym>JOHAB</acronym></entry>
         <entry>한국어 (한글)</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>KOI8R</literal></entry>
         <entry><acronym>KOI</acronym>8-R</entry>
         <entry>키릴어 (러시아어)</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>KOI8</literal></entry>
        </row>
        <row>
         <entry><literal>KOI8U</literal></entry>
         <entry><acronym>KOI</acronym>8-U</entry>
         <entry>키릴어 (우크라이나어)</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>LATIN1</literal></entry>
         <entry>ISO 8859-1, <acronym>ECMA</acronym> 94</entry>
         <entry>서유럽어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO88591</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN2</literal></entry>
         <entry>ISO 8859-2, <acronym>ECMA</acronym> 94</entry>
         <entry>중유럽어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO88592</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN3</literal></entry>
         <entry>ISO 8859-3, <acronym>ECMA</acronym> 94</entry>
         <entry>남유럽어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO88593</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN4</literal></entry>
         <entry>ISO 8859-4, <acronym>ECMA</acronym> 94</entry>
         <entry>북유럽어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO88594</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN5</literal></entry>
         <entry>ISO 8859-9, <acronym>ECMA</acronym> 128</entry>
         <entry>터키어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO88599</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN6</literal></entry>
         <entry>ISO 8859-10, <acronym>ECMA</acronym> 144</entry>
         <entry>스칸디나비아어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO885910</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN7</literal></entry>
         <entry>ISO 8859-13</entry>
         <entry>발트어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO885913</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN8</literal></entry>
         <entry>ISO 8859-14</entry>
         <entry>켈트어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO885914</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN9</literal></entry>
         <entry>ISO 8859-15</entry>
         <entry>유로 및 액센트 사용 LATIN1</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ISO885915</literal></entry>
        </row>
        <row>
         <entry><literal>LATIN10</literal></entry>
         <entry>ISO 8859-16, <acronym>ASRO</acronym> SR 14111</entry>
         <entry>루마니아어</entry>
         <entry>예</entry>
         <entry>아니요</entry>
         <entry>1</entry>
         <entry><literal>ISO885916</literal></entry>
        </row>
        <row>
         <entry><literal>MULE_INTERNAL</literal></entry>
         <entry>Mule 내부 코드</entry>
         <entry>Multilingual Emacs</entry>
         <entry>예</entry>
         <entry>아니요</entry>
         <entry>1-4</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>SJIS</literal></entry>
         <entry>Shift JIS</entry>
         <entry>일본어</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-2</entry>
         <entry><literal>Mskanji</literal>, <literal>ShiftJIS</literal>, <literal>WIN932</literal>, <literal>Windows932</literal></entry>
        </row>
        <row>
         <entry><literal>SHIFT_JIS_2004</literal></entry>
         <entry>Shift JIS, JIS X 0213</entry>
         <entry>일본어</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-2</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>SQL_ASCII</literal></entry>
         <entry>미지정 (텍스트 참조)</entry>
         <entry><emphasis>아무거나</emphasis></entry>
         <entry>예</entry>
         <entry>아니요</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>UHC</literal></entry>
         <entry>Unified Hangul Code</entry>
         <entry>한국어</entry>
         <entry>아니요</entry>
         <entry>아니요</entry>
         <entry>1-2</entry>
         <entry><literal>WIN949</literal>, <literal>Windows949</literal></entry>
        </row>
        <row>
         <entry><literal>UTF8</literal></entry>
         <entry>유니코드, 8비트</entry>
         <entry><emphasis>모두</emphasis></entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1-4</entry>
         <entry><literal>Unicode</literal></entry>
        </row>
        <row>
         <entry><literal>WIN866</literal></entry>
         <entry>Windows CP866</entry>
         <entry>키릴어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ALT</literal></entry>
        </row>
        <row>
         <entry><literal>WIN874</literal></entry>
         <entry>Windows CP874</entry>
         <entry>태국어</entry>
         <entry>예</entry>
         <entry>아니요</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1250</literal></entry>
         <entry>Windows CP1250</entry>
         <entry>중유럽어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1251</literal></entry>
         <entry>Windows CP1251</entry>
         <entry>키릴어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>WIN</literal></entry>
        </row>
        <row>
         <entry><literal>WIN1252</literal></entry>
         <entry>Windows CP1252</entry>
         <entry>서유럽어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1253</literal></entry>
         <entry>Windows CP1253</entry>
         <entry>그리스어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1254</literal></entry>
         <entry>Windows CP1254</entry>
         <entry>터키어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1255</literal></entry>
         <entry>Windows CP1255</entry>
         <entry>히브리어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1256</literal></entry>
         <entry>Windows CP1256</entry>
         <entry>아랍어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1257</literal></entry>
         <entry>Windows CP1257</entry>
         <entry>발트어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1258</literal></entry>
         <entry>Windows CP1258</entry>
         <entry>베트남어</entry>
         <entry>예</entry>
         <entry>예</entry>
         <entry>1</entry>
         <entry><literal>ABC</literal>, <literal>TCVN</literal>, <literal>TCVN5712</literal>, <literal>VSCII</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <para>
      모든 클라이언트 <acronym>API</acronym>가 나열된 모든 문자 집합을 지원하는 것은 아니다. 
      예를 들면, <productname>PostgreSQL</productname> JDBC 드라이버는 <literal>MULE_INTERNAL</literal> 및 <literal>LATIN6</literal>, <literal>LATIN8</literal>, <literal>LATIN10</literal>을 지원하지 않는다.
     </para>

     <para>
      <literal>SQL_ASCII</literal> 설정은 다른 설정과 상당히 다르게 동작한다. 
      서버 문자 집합이 <literal>SQL_ASCII</literal>인 경우 서버는 ASCII 표준에 따라 바이트 값 0-127을 해석하고, 
      바이트 값 128-255은 해석 불가 문자로 처리한다. 
      설정이 <literal>SQL_ASCII</literal>인 경우 인코딩 변환이 완료되지 않는다. 
      따라서 이 설정은 사용 중인 특정 인코딩에 대한 선언이라기 보다는 인코딩에 대한 무시 선언이다. 
      대부분의 경우에, ASCII가 아닌 데이터를 사용하는 경우 <productname>PostgreSQL</productname>은 비 ASCII 문자를 변환하거나 
      검증할 수 없기 때문에 <literal>SQL_ASCII</literal> 설정을 사용하는 것은 현명하지 않다.
     </para>
    </sect2>

   <sect2>
    <title>문자 집합 설정</title>

    <para>
     <command>initdb</command>는 <productname>PostgreSQL</productname> 클러스터에 대한 기본 문자 집합(인코딩)을 정의한다. 
     예를 들면,
<screen>
initdb -E EUC_JP
</screen>
이것은 기본 문자 집합을 <literal>EUC_JP</literal> (Extended Unix Code for Japanese)로 설정한다. 
옵션 string이 긴 것을 선호하는 경우 <option>--encoding</option>을 <option>-E</option> 대신 사용할 수 있다. 
<option>-E</option> 또는 <option>--encoding</option> 옵션을 지정하지 않으면 <command>initdb</command>는 지정되었거나 기본 로케일(locale)을 기반으로 사용할 적정 인코딩을 결정하려고 한다.
    </para>

    <para>
     인코딩이 선택한 로케일(locale)과 호환되는 경우 사용자는 기본값이 아닌 인코딩을 데이터베이스 생성 시에 지정할 수 있다.
<screen>
createdb -E EUC_KR -T template0 --lc-collate=ko_KR.euckr --lc-ctype=ko_KR.euckr korean
</screen>

     이것은 문자 집합 <literal>EUC_KR</literal> 및 로케일(locale) <literal>ko_KR</literal>을 사용하는 <literal>korean</literal>이라는 데이터베이스를 생성한다. 
     다른 방법으로 아래와 같은 SQL 명령을 사용할 수 있다.
<programlisting>
CREATE DATABASE korean WITH ENCODING 'EUC_KR' LC_COLLATE='ko_KR.euckr' LC_CTYPE='ko_KR.euckr' TEMPLATE=template0;
</programlisting>

     위의 명령은 <literal>template0</literal> 데이터베이스 복사를 지정한다는 점에 유의하라. 
     다른 데이터베이스를 복사할 때 데이터 손상의 우려 때문에 원본 데이터베이스로부터 인코딩과 로케일(locale) 설정은 변경할 수 없다. 
     자세한 내용은 <xref linkend="manage-ag-templatedbs"/>을 참조 바란다.
    </para>

    <para>
     데이터베이스의 인코딩은 시스템 카탈로그 <literal>pg_database</literal>에 저장되어 있다. 
     <command>psql</command> <option>-l</option> 옵션 또는 <command>\l</command> 명령을 사용하면 이것을 확인할 수 있다.
<screen>
$ <userinput>psql -l</userinput>
                                         List of databases
   Name    |  Owner   | Encoding  |  Collation  |    Ctype    |          Access Privileges          
-----------+----------+-----------+-------------+-------------+-------------------------------------
 clocaledb | hlinnaka | SQL_ASCII | C           | C           | 
 englishdb | hlinnaka | UTF8      | en_GB.UTF8  | en_GB.UTF8  | 
 japanese  | hlinnaka | UTF8      | ja_JP.UTF8  | ja_JP.UTF8  | 
 korean    | hlinnaka | EUC_KR    | ko_KR.euckr | ko_KR.euckr | 
 postgres  | hlinnaka | UTF8      | fi_FI.UTF8  | fi_FI.UTF8  | 
 template0 | hlinnaka | UTF8      | fi_FI.UTF8  | fi_FI.UTF8  | {=c/hlinnaka,hlinnaka=CTc/hlinnaka}
 template1 | hlinnaka | UTF8      | fi_FI.UTF8  | fi_FI.UTF8  | {=c/hlinnaka,hlinnaka=CTc/hlinnaka}
(7 rows)
</screen>
    </para>

    <important>
     <para>
      대부분의 최신 운영 체제에서 <productname>PostgreSQL</productname>은 <envar>LC_CTYPE</envar> 설정에 의해 어떤 문자 집합이 암시되는지를 판단하며, 
      강제로 일치되는 데이터베이스 인코딩만 사용되도록 한다. 
      예전 시스템에서는 선택한 로케일(locale)에서 예상되는 올바른 인코딩을 사용하는 것이 사용자의 책임이었다. 
      여기서 실수를 했을 경우 정렬 같이 로케일(locale)에 의존적인 작업은 이상하게 동작한다.
     </para>

     <para>
      <productname>PostgreSQL</productname>은 <envar>LC_CTYPE</envar>이 <literal>C</literal>또는 <literal>POSIX</literal>가 아니더라도 수퍼유저가 <literal>SQL_ASCII</literal> 인코딩을 사용하여 
      데이터베이스를 생성하는 것을 가능하게 한다. 
      위에서 명시한 대로, SQL_ASCII는 데이터베이스에 저장된 데이터가 특정한 인코딩을 강제로 갖게 하지 않으므로 
      <literal>SQL_ASCII</literal>을 선택하면 로케일(locale)에 의존적인 동작은 잘못될 가능성이 있다. 
      이러한 설정 조합은 사용할 수 없으며 언젠가는 전면적으로 금지될 수 있다.
     </para>
    </important>
   </sect2>

   <sect2>
    <title>서버와 클라이언트 간 자동 문자 집합 변환</title>

    <para>
     <productname>PostgreSQL</productname>은 서버와 클라이언트 간 특정 문자 집합 조합에 대해 자동 문자 집합 변환을 지원한다. 
     변환 정보는 <literal>pg_conversion</literal> 시스템 카탈로그에 저장된다. <productname>PostgreSQL</productname>은 <xref
     linkend="multibyte-translation-table"/>에 나오는 사전 정의된 변환 몇 가지를 제공한다. 
     SQL 명령 <command>CREATE CONVERSION</command>을 사용하면 새로운 변환을 생성할 수 있다.
    </para>

     <table id="multibyte-translation-table">
      <title>클라이언트/서버 문자 집합 변환</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>서버 문자 집합</entry>
         <entry>사용 가능한 클라이언트 문자 집합</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>BIG5</literal></entry>
         <entry><emphasis>서버 인코딩으로 지원되지 않음</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_CN</literal></entry>
         <entry><emphasis>EUC_CN</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_JP</literal></entry>
         <entry><emphasis>EUC_JP</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>SJIS</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_JIS_2004</literal></entry>
         <entry><emphasis>EUC_JIS_2004</emphasis>,
         <literal>SHIFT_JIS_2004</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_KR</literal></entry>
         <entry><emphasis>EUC_KR</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_TW</literal></entry>
         <entry><emphasis>EUC_TW</emphasis>,
         <literal>BIG5</literal>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>GB18030</literal></entry>
         <entry><emphasis>서버 인코딩으로 지원되지 않음</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>GBK</literal></entry>
         <entry><emphasis>서버 인코딩으로 지원되지 않음</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_5</literal></entry>
         <entry><emphasis>ISO_8859_5</emphasis>,
         <literal>KOI8R</literal>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>,
         <literal>WIN866</literal>,
         <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_6</literal></entry>
         <entry><emphasis>ISO_8859_6</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_7</literal></entry>
         <entry><emphasis>ISO_8859_7</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_8</literal></entry>
         <entry><emphasis>ISO_8859_8</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>JOHAB</literal></entry>
         <entry><emphasis>not supported as a server encoding</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>KOI8R</literal></entry>
         <entry><emphasis>KOI8R</emphasis>,
         <literal>ISO_8859_5</literal>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>,
         <literal>WIN866</literal>,
         <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>KOI8U</literal></entry>
         <entry><emphasis>KOI8U</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN1</literal></entry>
         <entry><emphasis>LATIN1</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN2</literal></entry>
         <entry><emphasis>LATIN2</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>,
         <literal>WIN1250</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN3</literal></entry>
         <entry><emphasis>LATIN3</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN4</literal></entry>
         <entry><emphasis>LATIN4</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN5</literal></entry>
         <entry><emphasis>LATIN5</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN6</literal></entry>
         <entry><emphasis>LATIN6</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN7</literal></entry>
         <entry><emphasis>LATIN7</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN8</literal></entry>
         <entry><emphasis>LATIN8</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN9</literal></entry>
         <entry><emphasis>LATIN9</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN10</literal></entry>
         <entry><emphasis>LATIN10</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>MULE_INTERNAL</literal></entry>
         <entry><emphasis>MULE_INTERNAL</emphasis>,
          <literal>BIG5</literal>,
          <literal>EUC_CN</literal>,
          <literal>EUC_JP</literal>,
          <literal>EUC_KR</literal>,
          <literal>EUC_TW</literal>,
          <literal>ISO_8859_5</literal>,
          <literal>KOI8R</literal>,
          <literal>LATIN1</literal> to <literal>LATIN4</literal>,
          <literal>SJIS</literal>,
          <literal>WIN866</literal>,
          <literal>WIN1250</literal>,
          <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>SJIS</literal></entry>
         <entry><emphasis>서버 인코딩으로 지원되지 않음</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>SHIFT_JIS_2004SHIFT_JIS_2004</literal></entry>
         <entry><emphasis>서버 인코딩으로 지원되지 않음</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>SQL_ASCII</literal></entry>
         <entry><emphasis>아무거나(변환이 수행되지 않음)</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>UHC</literal></entry>
         <entry><emphasis>서버 인코딩으로 지원되지 않음</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>UTF8</literal></entry>
         <entry><emphasis>인코딩 모두 지원</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>WIN866</literal></entry>
         <entry><emphasis>WIN866</emphasis>,
          <literal>ISO_8859_5</literal>,
          <literal>KOI8R</literal>,
          <literal>MULE_INTERNAL</literal>,
          <literal>UTF8</literal>,
          <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN874</literal></entry>
         <entry><emphasis>WIN874</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1250</literal></entry>
         <entry><emphasis>WIN1250</emphasis>,
          <literal>LATIN2</literal>,
          <literal>MULE_INTERNAL</literal>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1251</literal></entry>
         <entry><emphasis>WIN1251</emphasis>,
          <literal>ISO_8859_5</literal>,
          <literal>KOI8R</literal>,
          <literal>MULE_INTERNAL</literal>,
          <literal>UTF8</literal>,
          <literal>WIN866</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1252</literal></entry>
         <entry><emphasis>WIN1252</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1253</literal></entry>
         <entry><emphasis>WIN1253</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1254</literal></entry>
         <entry><emphasis>WIN1254</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1255</literal></entry>
         <entry><emphasis>WIN1255</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1256</literal></entry>
         <entry><emphasis>WIN1256</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1257</literal></entry>
         <entry><emphasis>WIN1257</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1258</literal></entry>
         <entry><emphasis>WIN1258</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     자동 문자 집합 변환을 활성화하려면 클라이언트에서 사용하려는 문자 집합(인코딩)을 <productname>PostgreSQL</productname>에 알려 주어야 한다. 
     이렇게 하는 방법에는 몇 가지가 있다.
     <itemizedlist>
      <listitem>
       <para>
        <application>psql</application>에서 <command>\encoding</command> 명령 사용. 
        <command>\encoding</command>을 사용하면 클라이언트 인코딩을 그때그때 변경할 수 있다. 
        예를 들면, 인코딩을 <literal>SJIS</literal>로 변경하려면 다음을 입력한다.
<programlisting>
\encoding SJIS
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        <application>libpq</application>(<xref linkend="libpq-control"/>)에는 클라이언트 인코딩을 제어하는 기능이 있다.
       </para>
      </listitem>

      <listitem>
       <para>
        <command>SET client_encoding TO</command> 사용. 
<programlisting>
SET CLIENT_ENCODING TO '<replaceable>value</replaceable>';
</programlisting>
        또는 표준 SQL 구문 <literal>SET NAMES</literal>을 사용할 수도 있다.
<programlisting>
SET NAMES '<replaceable>value</replaceable>';
</programlisting>

        현재 클라이언트 인코딩을 쿼리하려면,

<programlisting>
SHOW client_encoding;
</programlisting>

        기본 인코딩을 리턴하려면,

<programlisting>
RESET client_encoding;
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        <envar>PGCLIENTENCODING</envar> 사용. 
        환경 변수 <envar>PGCLIENTENCODING</envar>이 클라이언트의 환경에서 정의된 경우 해당 클라이언트 인코딩은 서버 연결 시 자동으로 선택된다. 
        (위에 언급된 다른 방법을 사용하면 나중에 이것을 무시할 수 있다.)
       </para>
      </listitem>

      <listitem>
      <para>
       환경 설정 변수 <xref
       linkend="guc-client-encoding"/> 사용. 
       <varname>client_encoding</varname> 변수가 설정된 경우 해당 클라이언트 인코딩은 서버 연결 시 자동으로 선택된다. 
       (위에 언급된 다른 방법을 사용하면 나중에 이것을 무시할 수 있다.)
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     특정한 문자 변환이 불가능한 경우 사용자가 서버에 대해서는 
     <literal>EUC_JP</literal>를 선택하고 클라이언트에 대해서는 <literal>LATIN1</literal>을 선택한 것으로 추정되며, 
     <literal>LATIN1</literal> 표현이 없는 일본어 문자가 리턴된다. 에러가 리포트된다.
    </para>

    <para>
     클라이언트 문자 집합이 <literal>SQL_ASCII</literal>로 설정된 경우 서버의 문자 집합과 무관하게 인코딩 변환이 비활성화된다. 
     서버의 경우처럼 모든 ASCII 데이터를 사용하지 않을 때는 <literal>SQL_ASCII</literal>는 바람직하지 않다.
    </para>
   </sect2>

   <sect2>
    <title>추가 자료</title>

    <para>
     이 소스는 다양한 인코딩 시스템을 배우는 데 도움이 된다.

     <variablelist>
      <varlistentry>
       <term><citetitle>CJKV Information Processing: Chinese, Japanese, Korean &amp; Vietnamese Computing</citetitle></term>

       <listitem>
        <para>
         <literal>EUC_JP</literal>,
         <literal>EUC_CN</literal>, <literal>EUC_KR</literal>,
         <literal>EUC_TW</literal>에 대한 자세한 설명이 나와 있다.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><ulink url="http://www.unicode.org/"></ulink></term>

       <listitem>
        <para>
         유니코드 컨소시엄 웹사이트.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>RFC 3629</term>

       <listitem>
        <para>
         <acronym>UTF</acronym>-8 (8-bit UCS/Unicode Transformation Format)가 여기에 정의되어 있다.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>

  </sect1>

</chapter>
